[{"title":"Java同步之synchronized关键字","date":"2021-01-26T02:34:57.576Z","path":"2021/01/26/Java同步之synchronized关键字/undefined/","text":"序言在开发中，避免不了多任务的操作，往往一个线程很难满足任务需要，所以就有了多线程，并行的任务，但是当使用多个线程来访问同一个数据时，非常容易出现线程安全问题(比如多个线程都在操作同一数据导致数据不一致),所以我们用同步机制来解决这些问题，其中的一种解决方式就是使用synchronized关键字 使用synchronized主要有四种用法： 第一是在方法声明时使用 放在范围操作符(public等)之后,返回类型声明(void等)之前。这时,线程获得的是 成员锁,即一次只能有一个线程进入该方法,其他线程要想在此时调用该方法,只能排队等候,当前线程(就是在Synchronized方法内部的线程)执行完该方法后,别的线程才能进入，例： public synchronized void method() &#123; // do something &#125; 第二是针对某一代码块使用 synchronized后跟括号,括号里是变量,这样,一次只有一个线程进入该代码块，此时，线程获得的是 成员锁 public int method(int arg1)&#123; synchronized(arg1) &#123; //一次只能有一个线程进入 &#125; &#125; 第三是对某一对象使用 synchronized后面括号里是对象,此时,线程获得的是 对象锁 public void method(String arg)&#123; synchronized (this)&#123; //取得该类实例化后对象的锁 &#125; &#125; 等同于 public synchronized void method(String arg)&#123; //取得Demo实例化后对象的锁 &#125; 第四是对某一类使用。 synchronized后面括号里是类,此时,线程获得的是 对象锁 public static void method(String arg)&#123; synchronized (Demo.class) &#123; //取得Demo.class类的锁 &#125; 等同于： public synchronized static void method(String arg)&#123; //取得Demo.class类的锁 &#125; 性能实现同步机制注意以下几点 多线程：安全性高，性能低 单线程：性能高，安全性低 所以： 不要对线程安全类的所有方法都进行同步操作，只对那些持有共享资源的方法进行同步 如果该类有两种运行环境，单线程环境和多线程环境。则应该为该类提供两种版本：线程安全版本和线程不安全版本(没有同步方法和同步块)。在单线程中环境中，使用线程不安全版本以保证性能，在多线程中使用线程安全版本. 其它 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞 第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 注：synchronized关键字可以修饰方法，也可以修饰代码块，但不能修饰构造器，属性等","tags":[{"name":"synchronized","slug":"synchronized","permalink":"https://goghtsui.github.io/tags/synchronized/"}]},{"title":"Android 适配之dimens adapter","date":"2018-02-06T05:46:45.000Z","path":"2018/02/06/Android-适配之dimens-adapter/undefined/","text":"序言大渣好，马上要过春节了，举国同庆的日子，在这里先祝大家：新年快乐，合家欢里，工作顺利，每天都旺、旺、旺！接下来，进入正题，今天我们的主题是适配，我们都知道 Android 屏幕碎片化特别严重，所以我们不止要开发一款好的应用，而且要在各种手机上都保持一样的效果，至少主流机型没问题，这是我们最头疼的问题，总之适配的工作是不可避免的，适配的方式包括很多内容，关于这一块的内容，我们简单聊一下！ 适配常识对于度量单位，有很多形式，android 中提到的类型有：dp 、ps、px、inch、pt、mm，也就是你可以使用这几种形式的单位，在不同的分辨率下，显示的效果是截然不同的，所以在 Android 中提倡以 dp （与像素无关）来作为统一单位，在实际使用中1dp大约等于1/160 in，而文字统一使用 sp 作为单位，以达到显示的一致性。关于单位的换算，可以看 Android 源码或者百科一下 所以，适配是一个很复杂的工作，简单罗列一下适配的几种形式： 基础适配 使用 dp 而非其他单位 使用 wrap_content, match_parent 与 weight 权重，尽量不写固定尺寸 使用相对布局 配合使用 .9 图片 使用矢量图 资源适配 多套 drawable 资源 多套 layout 资源 多套 values 资源 百分比布局 关于软件以上就是关于适配的一些方式，这里就不再一一详细说明了，接下来重点说一说 values 中 dimens.xml 适配的问题，这就是我来做这个软件的关键所在。 我们在适配 values 时会创建如：values-720×1280、values-sw720dp、values-w720dp 等针对不同分辨率下的尺寸适配方案，我们都知道 dimens.xml 中保存了各种尺寸值，所以，当存在多套 values 适配时，需要将默认的 dimens.xml 尺寸值转换为对应分辨率下的尺寸，无论是 dp 、ps 、px 等，都需要根据不同的比例转换，当 dimens.xml 文件中尺寸越来越多，单位不同时，如果一个个的计算很麻烦，这是发生在我身边的事，维护的以前的项目，现在要重新作适配，很多分辨率下的适配，就 dimens 这一块的适配就好几天（可能有同学会说，写程序的时候就写好，但是试问谁是这么做的，一开始没有人设定适配的方案，而且在第一套方案没有完成之前，谈适配不是太早了吗，每一次的调整都要改好几套，累死不讨好），呵呵…… 而且最后还找了一些软件，但是很不好用，还要把所有的单位统一之后才可以使用，很鸡肋，所以我决定自己写一个统一的方案，可以一键转换的那种，最终，今天的主角，就是来做这件事的，我暂且叫作：Dimens Adapter。 WEB本着方便的原因，我将这个功能提供了两种形式的使用方式，PC端（Windows） 和 Web端，同样的使用效果。 **Web版的入口：http://devtools.net.cn/dimens/ ** **Web版的入口：http://devtools.net.cn/dimens/ ** **Web版的入口：http://devtools.net.cn/dimens/ ** 这款软件，我使用了强大的 Python 语言，至于为什么，自行了解，就边学习边使用，之前已经看过很多遍了，其实还是很好上手的，哈…… ，Web 版本使用的是：阿里ECS云服务器 + Django + uwsgi，在部署的过程中，遇到了很棘手的问题，问题并不多，但是搜不到相关的答案，不过最终还是很幸运的说，换个思路，部署成功了，效果很不错的说 效果如下： 使用 填写目标分辨率 density 填写目标分辨率 sacle density 填写目标分辨率 xdpi 将默认的 dimens.xml 文件的内容复制到这里 这里是转换后的文件内容，没有提供文件下载，自行复制 当1、2、3、4 填写好之后，点击转换，最终展示在 5 里面 PC核心代码变化不大，面对的输出环境不一样，区别于读写操作，本身的 python 文件可以通过追加参数本地运行，也可以作为正常模块使用，最后在UI 方面，使用 Qt，最后打包，一款图形化的软件就诞生了，只需要一个 exe 文件，不需要安装，绿色环保，所见即所得。但是话说遇到了很多的坑，主要在于打包工具的兼容性问题，开发环境安装卸载了很多遍，各种姿势都试过了，但是软件开发或者对程序员来说，就是这样一个不断调试完善的过程，不断填坑的过程。虽然UI丑了点，但是核心功能具备，这就说明了软件迭代的重要性了，哈…… 下载地址：密码un9w 下载地址：密码un9w 下载地址：密码un9w 效果如下 ​ 其实软件的使用很简单，都是一键式的傻瓜操作： 功能讲解： 填写目标分辨率 density 填写目标分辨率 sacle density 填写目标分辨率 xdpi 填写默认的 dimens.xml 文件地址 日志输出区域，成功后会显示目标文件的地址 如果不手动填写 dimens.xml 文件地址，可以浏览选择文件 都填写完毕之后，点击该按钮执行转换 菜单讲解： 主要的说明就是 选项（options） 功能，默认提供了几种比例方案，只要选择对应的方案，就可以填写到指定内容，并选择默认的 dimens.xml 转换即可 可以转换语言（英语、中文） 简单的使用说明、作者信息 使用参考关于密度、分辨率的比例参考如下： 屏幕密度 范围(dpi) 标准分辨率 dp与px 图标尺寸 ldpi(QVGA) ~ 120 240 * 320 1dp=0.75px 36 * 36 mdpi(HVGA) 120 ~ 160 320 * 480 1dp=1px 48 * 48 hdpi(WVGA) 160 ~ 240 480 * 800 1dp=1.5px 72 * 72 xhdpi(720P) 240 ~ 320 720 * 1280 1dp=2px 96 * 96 xxhdpi(1080p) 320 ~ 480 1080 * 1920 1dp=3px 144 * 144 xxxhdpi(2K) 480 ~ 640 1440 × 2560 1dp=4px 192 * 192 提示：图标大小 = px数 * 4 * 12 总结不管是Web还是pc，从专业的角度讲，有点简陋和丑陋，纯属个人爱好和需要，没什么比较的，愿意使用就放心使用，不想用绕道即可，不接受喷子，没有产品经理、项目经理，还不能任性一回？如果有遇到任何问题，可以随时联系：&#x78;&#105;&#97;&#111;&#102;&#x65;&#x6e;&#x67;&#x33;&#53;&#53;&#64;&#115;&#x69;&#x6e;&#x61;&#x2e;&#99;&#x6f;&#x6d;","tags":[{"name":"适配","slug":"适配","permalink":"https://goghtsui.github.io/tags/%E9%80%82%E9%85%8D/"},{"name":"dimens","slug":"dimens","permalink":"https://goghtsui.github.io/tags/dimens/"},{"name":"dimens adapter","slug":"dimens-adapter","permalink":"https://goghtsui.github.io/tags/dimens-adapter/"},{"name":"devtools.net.cn","slug":"devtools-net-cn","permalink":"https://goghtsui.github.io/tags/devtools-net-cn/"}]},{"title":"Android Emulator 更新了 伤害爆炸","date":"2017-12-28T07:44:59.000Z","path":"2017/12/28/Android-Emulator-更新了-伤害爆炸/undefined/","text":"序言最近Google新版的模拟器，性能真是杠杠的，秒开，而且比Genymotion还要快，你敢信？所以，你可以告别额外的软件安装，告别使用真机调试造成的一万点暴击伤害。并且添加了很多功能的支持，还是很强大的，兄dei 你还不赶紧试试？ 下面是官方的内容。 原文地址（需要翻墙） 介绍发布者：Android 产品经理 Jamal Eason 今天，我们高兴地宣布为 Android Emulator 推出 Quick Boot 功能。利用 Quick Boot，您可以在 6 秒内启动 Android Emulator。Quick Boot 会为模拟器会话拍摄快照，因此您可以在数秒内重新加载。Quick Boot 最初随 Android Studio 3.0 在 Canary 更新版本渠道中发布，今天，我们非常高兴地以稳定更新版本形式发布此功能。 除了这个新功能，我们还希望重点介绍一下近期版本中的一些热门功能。自从两年前对 Android Emulator 进行彻底改造以来，我们继续侧重于提升速度、稳定性，以及添加众多功能，加快您的应用开发和测试的速度。鉴于所有近期变更，对您来说，今天绝对值得更新到最新版本的 Android Emulator 并开始使用这些功能。 5 大功能 Quick Boot 今天以稳定功能形式发布，Quick Boot 让您可以在 6 秒内恢复 Android Emulator 会话。在您首次启动带 Android Emulator 的 Android Virtual Device (AVD) 时，它必须执行冷启动（就像接通设备电源），但是，后续启动的速度会非常快，系统将恢复到您上次关闭模拟器时的状态（类似于唤醒设备）。为此，我们完全重新设计了旧版模拟器快照架构，以便与虚拟传感器和 GPU 加速搭配使用。无需其他步骤，因为从 Android Emulator v27.0.2 起，Quick Boot 默认处于启用状态。 如图：Android Emulator 中的 Quick Boot ​ Android CTS 兼容性 在每一个版本的 Android SDK 中，我们都会确保 Android Emulator 可以立即解决您的应用开发需求，从测试与 Android KitKat 的向后兼容性到集成开发者预览版的最新 API，不一而足。为了提高模拟器系统映像的产品质量和可靠性，现在，我们针对 Android 兼容性测试套件 (CTS) 将最终 Android 系统映像版本号限定为 Android Nougat (API 24) 及更高版本 - 官方的 Android 实体设备必须通过相同的测试套件。 Google Play 支持 我们知道许多应用开发者都使用 Google Play 服务，在 Android Emulator 系统映像中确保服务处于最新状态可能非常困难。为了解决这个问题，我们现在提供多种版本并且包含 Play 商店应用的 Android 系统映像。Google Play 映像支持 Android Nougat (API 24) 及更高版本。利用这些新的模拟器映像，您可以在模拟器中通过 Play 商店应用更新 Google Play 服务，就像您在实体的 Android 设备上操作一样。此外，您现在还可以通过 Google Play 商店测试端到端安装、更新和购买流程。 **性能改进 ** 让模拟器快速和高效是我们团队的一个持续目标。我们会持续关注在您的开发机器上运行模拟器的性能影响，尤其是 RAM 使用情况。在最近几个版本的 Android Emulator 中，我们现在可以按需分配 RAM，而不是分配内存并将其固定为在您的 AVD 中定义的最大 RAM 大小。为此，我们将本机管理程序用于 Linux (KVM) 和 macOS® (Hypervisor.Framework)，将增强的 Intel® HAXM（v6.2.1 及更高版本）用于 Microsoft® Windows®，后者使用全新的按需内存分配机制。 ​ 此外，在过去几个版本中，我们还提升了 CPU 和 I/O 性能，同时增强了 GPU 性能，包括 OpenGL ES 3.0 支持。下面通过 ADB 推送等常见任务突出显示了 Android CPU 和 I/O 管道的改进（图例：Android Emulator 的 ADB 推送速度比较）： 对于 GPU 性能，我们创建了一个示例GPU 仿真压力测试应用来衡量一段时间的性能改进。我们发现，最新的模拟器可以比之前渲染更高的帧速率，而且它是少数几个可以按照 Android 规范准确渲染 OpenGL ES 3.0 的模拟器之一。 如图：GPU 仿真压力测试 - Android 应用 如图：Android Emulator 的 GPU 仿真压力测试 更多功能除了这些主要功能外，我们在过去一年还为 Android Emulator 添加了很多其他功能，大家可能没意识到： WLAN 支持 从 API 24 系统映像开始，您可以创建一个能够同时连接到虚拟蜂窝网络和虚拟 WLAN 接入点的 AVD。 Google Cast 支持 使用 Google Play 系统映像时，您可以将屏幕和音频内容投射到位于同一个 WLAN 网络上的 Chromecast 设备。 拖放 APK 和文件 只需将 APK 拖放到 Android Emulator 窗口上即可触发应用安装。您也可以拖动任何其他数据文件，并在 Android Virtual Device 的 /Downloads 文件夹中找到。 主机复制与粘贴 您可以在 Android Emulator 与您的开发机器之间复制和粘贴文本。 虚拟双指张合与缩放 在与 Google 地图等应用交互时，按下 Ctrl 键（在 Microsoft® Windows® 或 Linux 上）或者 ⌘（在 macOS® 上），屏幕上将出现一个手指叠加层来协助进行张合与缩放操作。 GPS 位置 在 Android Emulator 的 Location 标签下手动选择一个 GPS 点或一组 GPS 点。 虚拟传感器 扩展的控制面板中有一个专门的页面，已在 Android Emulator 中支持加速、旋转和近程等传感器。 WebCam 支持 您可以将网络摄像头或笔记本电脑的内置网络摄像头用作 AVD 的虚拟摄像头。在 AVD Manager 的 Advanced Settings 页面中验证您的 AVD 摄像头设置。 主机键盘 您可以使用自己的实体键盘向 Android Virtual Device 输入文本。 虚拟短信和通话 在扩展的控制面板中，您可以触发虚拟的短信或通话来测试具有电话依赖关系的应用。 屏幕缩放 在主工具栏上，点击放大镜图标进入缩放模式，然后选择您想要检查的屏幕区域。 调整窗口大小 只需拖动 Android Emulator 窗口的一个角即可更改为所需大小。 网络代理支持 转到 Settings 页面的 Proxy 标签，为您的 Android Emulator 会话添加一个自定义 HTTP 代理。 错误报告 使用扩展的控制面板中的 Bug Report 部分，您可以为自己的应用快速生成错误报告，与您的团队分享或向 Google 发送反馈。 在 Emulator 文档中详细了解 Android Emulator。 开始使用现在，所有这些功能和改进都可以在 Android Emulator v27.0.2+ 中下载和使用，您可以在 Android Studio 中通过 SDK 管理器获取支持的 Android Emulator 版本。为了获得快速体验，我们建议创建和运行 x86 版本的模拟器系统映像，并安装最新的 Android Emulator、Intel® HAXM（如适用）和图形驱动程序。 我们感谢您提供有关您喜欢的特性、存在的问题或希望看到的功能的任何反馈意见。如果您发现错误或问题，或者想要分享功能请求，欢迎随时向我们提交问题。我们的工作远未完成，但我们希望大家对我们目前的改进感到兴奋。","tags":[{"name":"Android Emulator","slug":"Android-Emulator","permalink":"https://goghtsui.github.io/tags/Android-Emulator/"},{"name":"Quick Boot","slug":"Quick-Boot","permalink":"https://goghtsui.github.io/tags/Quick-Boot/"}]},{"title":"《阿里巴巴Java开发规约》插件p3c使用说明","date":"2017-10-15T02:35:42.000Z","path":"2017/10/15/《阿里巴巴Java开发规约》插件p3c使用说明/undefined/","text":"官方发布说明经过247天的持续研发，阿里巴巴于10月14日在杭州云栖大会上，正式发布众所期待的《阿里巴巴Java开发规约》扫描插件！ 插件全球首发仪式，大牛云集 阿里巴巴大牛天团倾力助阵：毕玄、玄难、索尼、叶渡，淘宝代码第一人多隆、代码规约作者孤尽携手规约项目组成员，以及业界规约生态代表等重磅大咖联合发布阿里巴巴代码规约插件！ 平日低调的大神们，为了这次盛会都来了～ 该插件由阿里巴巴P3C项目组研发。P3C是世界知名的反潜机，专门对付水下潜水艇，寓意是扫描出所有潜在的代码隐患。这个项目组是阿里巴巴开发爱好者自发组织形成的虚拟项目组，把《阿里巴巴Java开发规约》强制条目转化成自动化插件，并实现部分的自动编程。该插件在扫描代码后，将不符合规约的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能，如此爽心悦目的功能是不是很值得拥有？提升代码质量，提高团队研发效能，插件将会一路同行 插件下载地址 https://github.com/alibaba/p3c 或者在Github直接搜索p3c 插件安装Eclipse 准备 Eclipse Juno+ maven3.+ JDK 1.7+ 构建 mvn -U clean install 安装 Help &gt;&gt; Install New Software 然后输入这个地址： https://p3c.alibaba.com/plugin/eclipse/update 点击next 一步一步完成安装之后，重启就可以正常使用了 使用 语言切换 代码解析 ​ Intellij IDEA 准备 项目 JDK 1.7+ Gradle: 3.0+ （需要 JDK 1.8+） 构建 cd p3c-idea gradle clen buildPlugin 使用 ​ 安装 Settings &gt;&gt; Plugins &gt;&gt; Browse repositories… ，然后搜索 ‘alibaba’ ，默认第一个就是，点击右侧的 Install，重启即可使用 注意 如果安装之后出现乱码问题，可以尝试更换IDE字体为：Monospaced 使用 语言切换 在 Tools 菜单里，如图： 设置检测项 在 Settings &gt;&gt; Inspections &gt;&gt; Ali Check 你可以开关检测的约束规范 代码分析 通过上面的图片，可以看到插件提供的代码解析快捷键是：Ctrl+Alt+Shift+J ，使用快捷键之后会出现如下图的选择界面： 可以选择整个 Project 或者选中的 module ，代码分析完成之后可以看到类似如下的结果： 代码自动提示 插件还 提供了自动提示的功能，在我们编写代码的过程中，实时提示： 结语如果你还没有看过或者了解《阿里巴巴Java开发规约》你可以从这里开始： 阿里巴巴Java开发手册》之终极版","tags":[{"name":"阿里巴巴Java开发规约","slug":"阿里巴巴Java开发规约","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6/"},{"name":"p3c","slug":"p3c","permalink":"https://goghtsui.github.io/tags/p3c/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》4-1安全规约（新增）","date":"2017-09-25T03:10:09.000Z","path":"2017/09/25/《阿里巴巴Java开发手册（终极版）》4-1安全规约（新增）/undefined/","text":"【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。说明：查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 【强制】用户请求传入的任何参数必须做有效性验证。说明：忽略参数校验可能导致： page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 【强制】表单、 AJAX 提交必须执行 CSRF 安全过滤。说明： CSRF(Cross - site request forgery) 跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL ，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"安全规约","slug":"安全规约","permalink":"https://goghtsui.github.io/tags/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》3-1单元测试（新增）","date":"2017-09-25T03:00:25.000Z","path":"2017/09/25/《阿里巴巴Java开发手册（终极版）》3-1单元测试（新增）/undefined/","text":"单元测试 【强制】好的单元测试必须遵守 AIR 原则。说明：单元测试在线上运行时，感觉像空气 （AIR） 一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 A： Automatic （自动化） I： Independent （独立性） R： Repeatable （可重复） 【强制】单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。反例： method2 需要依赖 method1 的执行，将执行结果做为 method2 的输入。 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 【强制】单元测试代码必须写在如下工程目录： src/test/java ，不允许写在业务代码目录下。说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。 【推荐】单元测试的基本目标：语句覆盖率达到 70% ；核心模块的语句覆盖率和分支覆盖率都要达到 100%说明：在工程规约的应用分层中提到的 DAO 层， Manager 层，可重用度高的 Service ，都应该进行单元测试。 【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。 B： Border ，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。 C： Correct ，正确的输入，并得到预期的结果。 D： Design ，与设计文档相结合，来编写单元测试。 E： Error ，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。 【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。正例：在 RDC 内部单元测试中，使用 RDC_UNIT_TEST_ 的前缀标识数据。 【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（ UC ）。 【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 【参考】为了更方便地进行单元测试，业务代码应避免以下情况： 构造方法中做的事情过多。 存在过多的全局变量和静态方法。 存在过多的外部依赖。 存在过多的条件语句。说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 【参考】不要对单元测试存在如下误解： 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"单元测试","slug":"单元测试","permalink":"https://goghtsui.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Android-Studio-之依赖方式详解(Compile, Provided...)","date":"2017-08-25T01:47:22.000Z","path":"2017/08/25/Android-Studio-之依赖方式详解(Compile, Provided...)/undefined/","text":"序言我们在项目开发中，不可避免的需要使用到第三方的一些库，或者自己定义的一些lib，所以我们就需要在 build.gradle 文件添加对这些lib的依赖，代码如下： dependencies &#123; compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;) compile &#39;com.android.support:support-v4:25.3.0&#39; ... provided files(&#39;jar/framework.jar&#39;) &#125; 可以看到上面使用到了两种依赖的方式：compile provided ，那么还有没有其它依赖方式？都有哪些？ dependencies下面我们一起看看Studio给我们提供了那些依赖方式： 其实 Studio 已经提供了6种依赖方式：Compile、Provided、APK、Test compile、Debug compile、Release compile 。这里的名字和 dependencies 里面使用的命名是不用的 ，你可以添加几个试试看。那么问题来了，它们有什么不同？继续往下看 区别CompileCompile 是对所有的 build type 以及 favlors 都会参与编译并且打包到最终的 apk 文件中 ProvidedProvided 是对所有的 build type 以及 favlors 只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk APK只会打包到 apk 文件中，而不参与编译，所以不能再代码中直接调用 jar 中的类或方法，否则在编译时会报错 Test compileTest compile 仅仅是针对单元测试代码的编译以及最终打包测试apk时有效，而对正常的 debug 或者 release apk 包不起作用 Debug compileDebug compile 仅仅针对 debug 模式的编译和最终的 debug apk 打包 Release compileRelease compile 仅仅针对 release 模式的编译和最终的 release apk 打包 我相信你看到这些应该是恍然大悟了吧，根据不同的场景使用不同的依赖方式，一定要严谨！ 试问，还有其它的依赖方式吗？好像我在哪里看到过…… 扩展其实除了上面提供的6中依赖方式，还有一些支持的方式：android-apt、annotationProcessor 。 Android-apt 是由一位开发者自己开发的 apt 框架，源代码托管在这里，随着 android Gradle 插件 2.2 版本的发布，Android Gradle 插件提供了名为 annotationProcessor 的功能来完全代替 android-apt ，自此 android-apt 作者在官网发表声明最新的 Android Gradle 插件现在已经支持 annotationProcessor，并警告和或阻止 android-apt ，并推荐大家使用 Android 官方插件 annotationProcessor。 关于注解的使用，不是本文的重点，重点是依赖所提供的功能。 android-apt &amp; annotationProcessor只在编译的时候执行依赖的库，但是库最终不打包到apk中。编译库中的代码没有直接使用的意义，也没有提供开放的 api调用，最终的目的是得到编译库中生成的文件，供我们调用。 总结我曾经错误的将 compile 使用到了 provider 库，很悲剧的出现了方法数超过了65535，于是我开始改造项目，结果各种没效果，最后才了解到是依赖方式的问题，想想有多愚蠢！唉，年轻没经验啊！如果可以的话，尝试去使用每一种方式，看看有什么不同。","tags":[{"name":"Android-Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"Compile","slug":"Compile","permalink":"https://goghtsui.github.io/tags/Compile/"},{"name":"Provided","slug":"Provided","permalink":"https://goghtsui.github.io/tags/Provided/"},{"name":"Test compile","slug":"Test-compile","permalink":"https://goghtsui.github.io/tags/Test-compile/"},{"name":"Debug compile","slug":"Debug-compile","permalink":"https://goghtsui.github.io/tags/Debug-compile/"},{"name":"Release compile","slug":"Release-compile","permalink":"https://goghtsui.github.io/tags/Release-compile/"}]},{"title":"Android Studio 发布 library 到 jcenter 和 maven central","date":"2017-08-08T07:44:17.000Z","path":"2017/08/08/Android-Studio-发布-library-到-jcenter-和-maven-central/undefined/","text":"序言在我们日常的开发中，会遇到各种各样的需求和技术解决方案。所以产生了各位大神提供的各种功能的开源库，并且通过：compile ‘xxxxxxxx’ 就可以使用了，非常方便。可以你有没有想过自己写一个开源库？又或者你已经贡献了很多好的代码，不知道怎么共享，怎么通过 compile 的方式给别人使用？你要知道，装B也是需要技术的。 jcenter &amp; maven central引用如果你留心的话，应该了解到我们使用了两种标准的 libraries 仓库，分别是 jcenter 和 maven central ： jcenter jcenter 是一个托管在 bintray.com 的资源库，你可以在 这里 找到需要的资源为了能在项目中使用 jcenter，我们需要在 project 的 build.gradle 文件中添加对资源库的引用： ​ allprojects &#123; repositories &#123; jcenter() &#125; &#125; ​ maven central Maven Central 是一个托管在 sonatype.org 的资源库，你可以在 这里 找到需要的资源如果在项目中使用 Maven Central，我们需要在 project 的 build.gradle 文件中定义自己的资源库： ​ allprojects &#123; repositories &#123; mavenCentral() &#125; &#125; 请注意，虽然 jcenter 和 Maven Central 都是标准Android library 资源仓库，但他们的托管地址完全不同，它们的内容是由不同提供者提供的，而且之间并没有任何关联。所以也就可能，在 jcenter 中能够找到的 library ，在 Maven Central 中并不能找到，反之亦然。 除了这两个标准的资源库外，我们也可以定义特殊的资源库，引入一些开发者自己托管维护的 library，然后像下面这样添加对该库的引用： repositories &#123; maven &#123; url &#39;http://xxxx.xxxx&#39; &#125; &#125; 最后通过 compile 依赖： dependencies &#123; // 替换对应的配置值 compile &#39;groupId:artifactId:version@aar&#39; &#125; 对比那么为什么有两个标准资源库而不是一个？而且它们都拥有相同的功能：托管 java / Android library ，完全由开发者决定把 library 上传到它们中的一个或两个上。最开始的时候，Android Studio 使用 Maven Central 作为默认资源库，一旦你从老版本的 Android Studio 创建了一个新的项目，mavenCentral() 会自动添加到 build.gradle 中 但是 Maven Central 存在一个较大的问题，即对开发者并不友好。上传 library 比较困难。为了能够做到上传，开发者从某种程度上讲得具备极客的能力。再考虑到其他一些原因，比如安全问题，Android Studio 团队决定把默认资源库改为jcenter，所以新版 Android Studio 创建新项目的时候，默认使用 jcenter() 而不是 mavenCentral()这里列举了一些他们决定从 Maven Central 切换 jcenter 的主要原因： jcenter 通过 CDN 传输 library ，这意味着开发者能够享受更快的加载速度 jcenter 是世界上最大的 java 库，所以能在 Maven Central 里面找到的，基本在 jcenter 里面也能找到 非常容易上传 library 到 jcenter 仓库，没有必要签名或做其他一些在 Maven Central 上很复杂的操作 界面友好 所以，我推荐使用 jcenter 仓库来上传自己的库，而且可以同步到 maven central 。 上传 library 到 jcenter我们对 jcenter 和 maven central 已经了解了，那么就让我们开始最重要环节：上传 其实，这个过程非常简单，一旦你配置成功之后，只需要修改一些值，就可以到处使用了，接下来分步骤给大家讲解一下： 第一步：注册帐号 Bintray 官网 首页默认注册是组织 ， 个人注册地址是：https://bintray.com/signup/oss 个人注册地址是：https://bintray.com/signup/oss 个人注册地址是：https://bintray.com/signup/oss 重要的事情说三遍 注意：不能使用国内的邮箱注册，可以使用 google 帐号，推荐使用 github 帐号注册 获取 api key 登陆之后，点击 右上角你的头像 -&gt; Edit Profile -&gt; API Key API Key 后面会用到，先复制出来，备用 创建个人 Maven 仓库 回到个人主页，点击 Add New Repository 设置库名称、类型、Licenses、描述信息： 库的名称后面会用到 环境配置 创建 module 或者 打开你创建好的module，在 Project 的 build.gradle 中添加 Maven 和 Jfrog Bintray 的依赖： ​ buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:2.3.0&#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // 添加下面两行 classpath &#39;com.github.dcendents:android-maven-gradle-plugin:1.5&#39; classpath &#39;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3&#39; &#125; &#125; allprojects &#123; repositories &#123; jcenter() &#125; &#125; task clean(type: Delete) &#123; delete rootProject.buildDir &#125; 关于版本号，可以去这里查看 Maven 和 Jfrog Bintray 的最新版本 ​ 在 module 的 builde.gradle 开头添加以下配置： //添加这两行 apply plugin: &#39;com.github.dcendents.android-maven&#39; apply plugin: &#39;com.jfrog.bintray&#39; 在 module 的 builde.gradle 末尾添加以下配置： ​ // 项目主页，需要修改 def siteUrl = &#39;https://bintray.com/goghtsui/RxOkRetrofit&#39; // 项目的git地址（必须是git地址，可以不存在），需要修改 def gitUrl = &#39;git@github.com:goghtsui/TvRecyclerView.git&#39; // 上传到 Bintray 的库名称（刚才创建的名称），需要修改 def libName = &quot;RxOkRetrofit&quot; // 这两个参数配置是为了最终生成 compile &#39;com.xxx:xxxx:1.0.0&#39; group version 是关键字，自动识别的，需要修改 group = &quot;com.gogh&quot;; version = &quot;1.0.01&quot; install &#123; repositories.mavenInstaller &#123; // 生成pom.xml和参数 pom &#123; project &#123; packaging &#39;aar&#39; // 可选，项目名称，需要修改 name &#39;RxOkRetrofit&#39; // 可选，项目描述，需要修改 description &#39;Support for http request, use okhttp rxjava and retrofit.&#39; url siteUrl // 项目主页，这里是引用上面定义好 // 软件开源协议，现在一般都是Apache License2.0 licenses &#123; license &#123; name &#39;The Apache Software License, Version 2.0&#39; url &#39;http://www.apache.org/licenses/LICENSE-2.0.txt&#39; &#125; &#125; //填写开发者基本信息，需要修改 developers &#123; developer &#123; id &#39;gaoxiaofeng&#39; // 开发者的id name &#39;gaoxiaofeng&#39; // 开发者名字 email &#39;xiaofeng355@gmail.com&#39; // 开发者邮箱 &#125; &#125; // SCM scm &#123; connection gitUrl // Git仓库地址 developerConnection gitUrl // Git仓库地址 url siteUrl // 项目主页 &#125; &#125; &#125; &#125; &#125; //上传到JCenter Properties properties = new Properties() properties.load(project.rootProject.file(&#39;local.properties&#39;).newDataInputStream()) bintray &#123; // 读取 local.properties 文件里面的 bintray.user 登录用户名 user = properties.getProperty(&quot;bintray.username&quot;) // 读取 local.properties 文件里面的 bintray.apikey key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&#39;archives&#39;] pkg &#123; // 这里的repo值必须要和你创建Maven仓库的时候的名字一样，需要修改 repo = &quot;RxOkRetrofit&quot; // 发布到 JCenter 上的项目名字 name = libName websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true //是否是公开项目 &#125; &#125; // 生成jar包的task task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &#39;sources&#39; &#125; // 生成jarDoc的task task javadoc(type: Javadoc) &#123; options.encoding &quot;UTF-8&quot; options.charSet &#39;UTF-8&#39; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) failOnError false // 忽略注释语法错误，如果用jdk1.8你的注释写的不规范就编译不过 &#125; // 生成javaDoc的jar task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &#39;javadoc&#39; from javadoc.destinationDir &#125; artifacts &#123; archives javadocJar archives sourcesJar &#125; ​ 在 build.gradle 中还需要添加的配置： ​ android&#123; lintOptions &#123; checkReleaseBuilds false abortOnError false &#125; &#125; ​ 在 local.properties 中添加上面需要的参数值： ​ bintray.username= bintray注册的用户名 bintray.apikey= 在文章开头获取的 apikey ​ 上传 环境基本上就配置好了，需要修改的都己经给出，如果编译没有问题，就可以上传了 Windows 环境 gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false ​ Mac OS 环境 如果出现拒绝该命令 ./gradlew: Permission denied，可以先运行 chmod +x gradlew再运行该命令； ./gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false 上面命令中 BINTRAY_USERNAME 是你在 bintray 上注册的用户名，BINTRAY_KEY 是文章开头获取的 API Key，替换了用户名和 API key 回车执行，等到控制台最终输出 BUILD SUCCESSFUL 就表明项目上传成功了 发布到 jcenter这个时候回到 bintray 我们的 maven 仓库中，进入我们刚上传成功的 packge ，可以看到像这样： ​ 刚才新建的库已经有信息了，点击名称打开，会看到以下信息，然后点击 Add to JCenter ： 接下来打开的是提交的页面，如下： 什么都不用填，直接点击 Send 按钮，等待审核！ 至此，我们已经正确的创建、提交了我们的项目到jcenter，当然了，通过审核之后就有可以通过 compile 的方式依赖使用了，屌屌的！ 同步到Maven Central在详情页面，切换到 Maven Central 标签下， 设置好自己的 User token 和 password 点击 Sync： Url方式依赖刚才我们提到过，一些个人维护或者其它平台的libraries 可以通过 url 的形式配置使用，所以，在没有通过审核之前，我们还是可以直接通过库的地址来依赖使用： 找到库的链接地址，点击项目名称打开详情之后，我们可以看到右上角的地址： 在 project 的 build.gradle 添加 url allprojects &#123; repositories &#123; jcenter() // 添加这行 maven &#123;url &#39;右上角的链接&#39;&#125; &#125; &#125; 在 module 的 build.gradle 添加依赖 // 注意，第二个信息是 module 的名称 compile &#39;com.gogh:module名称:1.0.1&#39; // 如果出错，可以使用下面的 @arr 依赖形式 // compile &#39;com.gogh:module名称:1.0.1@arr&#39; 其实我们可以通过 jcenter 项目的详情页，左下角看到不同的引用形式： 总结总的来说，还是非常简单的，只需要注册相应托管服务平台的账号，然后创建对应的项目，再配置本地的项目 pom 信息，上传并提交审核，同时可以同步到 maven central ，就是这么简单！如果你产出了更多更好的优质代码，不妨共享出来造福更多的程序猿！","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"jcenter","slug":"jcenter","permalink":"https://goghtsui.github.io/tags/jcenter/"},{"name":"maven central","slug":"maven-central","permalink":"https://goghtsui.github.io/tags/maven-central/"}]},{"title":"Moto Z Play 去除内核加密和dm-verify","date":"2017-07-05T09:13:35.000Z","path":"2017/07/05/Moto-Z-Play-去除内核加密和dm-verify/undefined/","text":"序由于各种原因，我们需要修改系统已完成定制，所以我们需要想办法去除掉它。 最近迎来了 Moto Z Play 的安全补丁更新，但是由于已经解锁 bootloader，无法正常OTA，所以需要手动刷最新完整底包，或者刷上一个版本然后OTA，更新到最新的 NCN25.137-24 版本，安全补丁是 2017年5月1日 的，无奈最新的完整底包还没有放出，只能刷上一个版本的底包再OTA了。当然了，Google全家桶是必不可少的，但是现在 Moto Z / Moto Z Play 刷 Google 全家桶可没那么容易了，两个问题：内核强制加密、dm-verify 验证！ 内核强制加密 Moto Z / Moto Z Play 开启了强制加密 Data(数据目录) 分区功能 开启强制加密会影响磁盘读写性能、无法修改、不能 ROOT、开机速度慢 dm-verify 验证 这是由 Google 设计的一项用于保护系统的技术。当系统经过修改后，手机将会重启，并且将会无法开机进入系统 关于内核加密，现在第三方的ROM制作团队或者厂商都默认开启了内核加密，这没有任何问题，但是对于喜欢DIY或者定制ROM的人，就相当于是一道墙。 但是，还是有大神来解决的，下面是我整理的一些大神提供的去除内核加密和dm-verify验证的方法（只针对Moto Z / Moto Z Play） 教程准备 需要使用的工具：**Android Image Kitchen ** 官方固件（相应版本底包） 需要在 Linux 或者 有Java环境下 高级文本编辑器：Notepad++ 等 步骤 下载工具解压缩 附件是：Android.Image.Kitchen.v2.4-Win32.zip 解包内核 内核文件一般在底包中都命名为：boot.img ，镜像文件 打开cmd窗口，输入： unpackimg &lt;image-filename.img&gt; 或者可以拖放 img 到 unpackimg.bat，这个脚本会解包 img 并解压到 ramdisk 的一个子目录中。 去除 dm-verify 验证 打开 ramdisk 文件夹，找到 fstab.qcom 文件，并用Notepad++等编辑器打开 找到第9行，将 wait 后面的 ,verify 删掉，即将一下内容： /dev/block/bootdevice/by-name/system /system ext4 ro,barrier=1 wait,verify 修改为： /dev/block/bootdevice/by-name/system /system ext4 ro,barrier=1 wait 假如是 Android 6.0.1，还有一个 charger.fstab.qcom，同样在第九行去掉 ,verify ，可加入 noatime 以提交 io 性能。 /dev/block/bootdevice/by-name/system /system ext4 ro,barrier=1,noatime,discard wait 去除去除强制加密 接着找到第10行，将 forceencrypt 修改为 encryptable ，即将一下内容： &lt;blockquote&gt;/dev/block/bootdevice/by-name/userdata /data f2fs rw,discard,nosuid,nodev,noatime,nodiratime,nobarrier,inline_xattr,inline_data wait,check,formattable,forceencrypt=/dev/block/bootdevice/by-name/metadata 修改为： &lt;blockquote&gt;/dev/block/bootdevice/by-name/userdata /data f2fs rw,discard,nosuid,nodev,noatime,nodiratime,nobarrier,inline_xattr,inline_data wait,check,formattable,encryptable=/dev/block/bootdevice/by-name/metadata 删除 verity_key 删除 ramdisk 文件夹下 verity_key 文件，不删除 verity_key 将会导致国行系统不读卡 重新打包内核 直接点击 repackimg.bat（repackimg.bat 这个批处理脚本不需要输入命令，只要点击运行）。可以直接打包成 image-new.img 文件 关于 cleanup.bat ：清理文件夹并重置为初始状态，消除以下文件与文件夹：split_img + ramdisk的目录和任何新的打包的 ramdisk 或 img 文件 刷入 手机进入bootloader模式，执行以下命令： fastboot flash boot image_new.img 格式化 Data 分区 fastboot -w 注意，只有当格式化 Data 分区后去除加密才可以生效 注意刷入第三方包需要使用第三方recovery ，我使用的是TWRP 3.1.0，所以刷入内核之前要先刷入这个recovery。 附件Android Image Kitchen 点我下载 TWRP 3.1.0","tags":[{"name":"Moto Z","slug":"Moto-Z","permalink":"https://goghtsui.github.io/tags/Moto-Z/"},{"name":"Moto Z Play","slug":"Moto-Z-Play","permalink":"https://goghtsui.github.io/tags/Moto-Z-Play/"},{"name":"内核加密","slug":"内核加密","permalink":"https://goghtsui.github.io/tags/%E5%86%85%E6%A0%B8%E5%8A%A0%E5%AF%86/"},{"name":"dm-verify","slug":"dm-verify","permalink":"https://goghtsui.github.io/tags/dm-verify/"}]},{"title":"Google 发布 Android Studio 3.0 Canary 1","date":"2017-05-24T03:01:45.000Z","path":"2017/05/24/Google-发布-Android-Studio-3-0-Canary-1/undefined/","text":"发布人：Android 产品经理 Jamal Eason 正巧赶上 Google I/O 2017 ，我们提供发布了 Android Studio 3.0 - 今天就可以在我们的 Canary 发布渠道上 下载。Android Studio 是我们的官方 IDE，专门为 Android 开发构建的，我们不断加大投入，改进该 IDE。Android Studio中的功能集专注于加速您的应用程序开发流程并提供针对 Android 平台构建的最新工具。 为加快您的开发流程，Android Studio 3.0 包含了三大主要功能： 一套全新的应用性能分析工具，用于快速诊断性能问题 支持 Kotlin 编程语言 加快大型应用项目的 Gradle 构建速度 Android Studio 3.0 还紧密集成了 Android 平台开发工具，提供以下附加的关键功能： 支持Instant App（即时应用或免安装应用）的开发 在 Android O 模拟器系统映像中包含 Google Play 商店 全新的 Android O 开发向导 总的来说，Android Studio 3.0 的第一个 Canary 版本包含 20 多项新功能。 我们一直在 Android Studio 2.4 的各个 Canary 版本中默默地迭代了这当中的许多功能。直到今天，我们认识到，我们已经添加了许多重要功能，并且，我们必须在Android Gradle插件中引入一个罕见的变化，以提高可扩展性和构建时间，于是，我们将此版本重新编号为 Android Studio 3.0。如果您希望针对 Android O 开发应用，创建免安装应用，开始使用 Kotlin 语言开发，或者希望使用最新的 Android 应用性能工具来提升应用质量，那么，您应立即下载 Android Studio 3.0 Canary 1。 Yutube视频演示地址：Android DevByte - Android Studio 3.0 Canary 1 中的新增功能 开发 Kotlin 编程语言 - 根据行情的需要，Android Studio 3.0 现在包含对 Kotlin 的支持。凭借对此新语言的支持，您可以在现有 Android 应用代码的旁边无缝添加 Kotlin 代码，还可访问 Android Studio 中提供的所有优秀开发工具。您可以选择使用 Code → Convert Java File to Kotlin File 中提供的内置转换工具将 Kotlin 添加到您的项目，也可以选择使用 New Project 向导创建启用 Kotlin 的项目。详细了解 Android 和 Android Studio 中的 Kotlin 语言支持。 ​ Android Studio 中的 Kotlin 语言转换 Java 8 语言功能 - 我们正在继续完善对 Java 8 语言功能和 API 的支持。由于最近弃用 Jack 工具链并迁移到基于 javac 的工具链，对于使用 Java 8 语言功能的项目，您可以在 Android Studio 中访问许多新功能，例如 Instant Run。要更新您的项目以支持全新 Java 8 语言工具链，只需在 Project Structure 对话框中将您的 源代码 和 目标代码 兼容性级别更新至 1.8。了解详情。 ​ 更新 Java 8 语言的 Project Structure 对话框 布局编辑器 - 在此 Android Studio 版本中，您会发现针对布局编辑器的更多增强功能。我们更新了组件树，提供更好用的拖拽式视图插入功能以及全新的错误面板。为配合对 ConstraintLayout 的更新，布局编辑器还支持创建视图 Barrier 和 Group，并增强了链创建功能。了解详情。 ​ 布局编辑器组件树和警告面板 Adaptive Icon 向导 - Android O 引入了自适应启动器图标，其可以在不同的 Android 设备上显示为不同的形状。全新 Adaptive Launcher Icon 向导可创建新旧两种版本的启动器图标资源并可预览自适应图标在不同启动器屏幕图标蒙版上的外观。创建新资源的方法是：右键点击项目中的 /res 文件夹，然后导航至 → New → Image Asset → **Launcher Icons (Adaptive and Legacy) **了解详情。 ​ Adaptive Icon 向导 **XML 字体和可下载字体 **- 现在，使用 Android Studio 中的 XML 字体预览和字体选择工具可以为您的应用（针对 Android O 的应用）更轻松地添加自定义字体。您也可以为您的应用创建可下载的字体资源。使用可下载的字体，您将可以在应用中使用自定义字体，同时又不需要在 APK 中捆绑字体资源。要使用可下载字体，请确保您的设备或模拟器运行的是 Google Play 服务 11.2.63 版或更高版本。了解详情。 ​ 可下载字体资源选取器 ​ XML 字体预览 **Android Things 支持 **- 借助于 Android Studio 3.0，您可以使用 New Project 向导和 New Module 向导中的一组新模板来开始开发 Android Things。Android Things 允许您将自己的 Android 开发知识拓展到物联网 (IoT) 设备类别。了解详情。 ​ Android Things New Module 向导 IntelliJ 平台更新：Android Studio 3.0 Canary 1 包含 IntelliJ 2017.1 版本，其包含 Java 8 语言重构、参数提示、语义突出显示、可拖拽的断点、增强的版本控制搜索等功能。了解详情。 构建 免安装应用支持 - 利用 Android Studio 3.0，您可以在项目中创建免安装应用。免安装应用是一种轻巧的 Android 应用，用户无需安装即可直接运行该应用。为支持免安装应用，Android Studio 引入了两种新模块类型：免安装应用和功能。结合全新的“模块化”重构操作和应用链接助手，Android Studio 可以帮助您将现有应用拓展为免安装应用。为使用此功能，您可以使用 New Module 向导或右键点击某个类并导航至：Refactor → Modularize 了解详情。 ​ Instant App Module 向导 **构建速度的提升 **- 我们继续努力提升构建速度。在此版本中，我们侧重于提升包含大量模块的项目的构建速度。为提升这些项目的构建速度并支持未来的增强功能， *我们对 Android Studio 所使用的 Android Gradle 插件的 API *做出了颠覆性的改动。如果您依赖于之前版本的插件所提供的 API，您应验证与新插件的兼容性并迁移到适用的 API。在您的 build.gradle 文件中测试和更新插件版本。了解详情。 build.gradle dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.0.0-alpha1&#39; &#125; Google 的 Maven 存储区 - 此外，应广大开发者的热切呼声，现在，我们以全新 Maven 存储区的形式在 Android SDK 管理器外部分发 Android 支持库的 Maven 依赖项。对于使用持续集成 (CI) 系统开发的人来说，这样可以简化 Maven 依赖项的管理。结合最新的命令行 SDK 管理器工具和 Gradle 使用时，使用 Google 的 Maven 存储区应该能够简化 CI 构建的管理。要使用全新 Maven 的位置，请在应用模块的 build.gradle 文件中添加以下网址。了解详情。 build.gradle repositories &#123; maven &#123; url &quot;https://maven.google.com&quot; &#125; &#125; 测试和调试 **Google Play 系统映像 **- 在更新 Android O Beta 版本的同时，我们也更新了 Android Emulator O 系统映像，使之包含 Google Play 商店。捆绑 Google Play 商店让您能够使用 Google Play 端到端地测试应用，同时也方便您在 Android Virtual Device (AVD) 中使 Google Play 服务保持最新状态。就像实际设备上的 Google Play 服务更新一样，您也可以在 AVD 上启用同样的更新。 ​ Android Emulator 中的 Google Play 商店 ​ 更新 Android Emulator 中的 Google Play 服务 为确保应用安全性以及与实际设备一致的体验，包含 Google Play 商店的模拟器系统映像已使用发布密钥签名。这意味着您将无法获得高级权限。如果您要求使用高级权限 (root) 来帮助您排查应用问题，您可以使用不包含 Google 应用或服务的 Android 开放源代码项目 (AOSP) 模拟器系统映像。要开始，请确保您使用的是 Android Emulator v26.1+ 和最新的系统映像 API 24+，然后使用设备定义旁边的 Google Play 图标创建一个新 AVD。了解详情。 ​ 包含 Google Play 商店支持的 Android Virtual Device 管理器 Android Emulator 中的 OpenGL ES 3.0 支持 - 我们不断投资，努力给您带来快速开发体验，最新版的 Android Emulator 针对 Android O 系统映像引入了 OpenGL ES 3.0 支持，针对旧版模拟器系统映像，则大幅增强了 OpenGL ES 2.0 的图形性能。在所有操作系统中，大多数最新的显卡均支持 OpenGL ES 2.0 加速。要将 OpenGL ES 3.0 与 Android Emulator 配合使用，开发计算机需要在 Microsoft® Windows® 或 Linux（即将支持 Apple MacOS®）中支持 OpenGL 3.2 或更高版本的主机 GPU 显卡。了解详情。 ​ Android Emulator 中的 OpenGL ES 3.0 Android Emulator 中的应用错误报告程序 - 为帮助记录应用中的错误，我们新增了一种更简便的错误报告生成方法，该报告程序提供所有必要的配置设置以及捕获重现步骤的空间。另外，我们还新增了一个链接，以便您在想要与 Android 团队分享特定模拟器错误时，能够在 Android Issue Tracker 中快速生成错误。要使用此功能，请导航至 Emulator Tool Bar → Extended Controls → Help → Emulator Help → File a Bug。了解详情。 ​ Android Emulator 中的应用错误报告 Android 中的代理支持 **- 针对那些需要使用 HTTP 代理访问互联网的用户，我们新增了一个用户界面，可用于管理模拟器所使用的代理设置。现在，默认情况下，Android Emulator 会使用 Android Studio 中的设置，但您可以在您的网络设置中替换这些设置。要进行配置，请导航至 **Extended Controls → Settings → Proxy。 ​ Android Emulator 代理设置 **Android Emulator 中的 Android Wear 旋转控件 **- 现在，Android Emulator 支持 Android Wear 2.0 模拟器系统映像的旋转控件。现在，对于针对包含旋转输入滚动功能的 Android Wear 设备的应用，测试将更加简单。要启用此功能，请创建针对 Android Wear 的 Emulator AVD，Rotary Input 面板应出现在扩展控件下面。了解详情。 ​ Android Emulator 中的旋转输入 APK 调试 **- 现在，针对不想在 Android Studio 中构建项目、只想在其中调试 APK 的开发者，Android Studio 3.0 版本加入了调试任意 APK的功能。对于在其他开发环境编写 Android C++ 代码而想在 Android Studio 环境中调试和分析 APK 的用户而言，此功能尤为有用。只要您有可调试版本的 APK，您就可以使用新的 APK 调试功能来静态分析、动态分析和调试 APK。而且，如果您可以访问 APK 的源代码，您可以将此源代码链接到 APK 调试流，以提高调试流程的保真度。只需在 Android Studio Welcome Screen 中选择 **Profile or debug APK 或选择 File → Profile or debug APK，即可使用此功能。 了解详情。 ​ 分析或调试 APK ​ APK 调试 布局检查器 **- 您会发现，Android Studio 3.0 中的布局检查器提供几项增强功能，简化了应用布局问题的调试。这几项增强功能包括更好地将属性分组到常用分类中，以及 View Tree 和 Properties 面板中的搜索功能等。在应用运行时，通过 **Tools → Android → Layout Inspector 访问布局检查器。了解详情。 ​ 布局检查器 **设备文件浏览器 **- 应广大用户的热切呼声，我们将设备文件浏览器从 DDMS 移植到 Android Studio 中，新的浏览器允许查看 Android 设备或模拟器的文件和目录结构。现在，您在测试应用时，可以直接在 Android Studio 中快速预览和修改应用数据文件。 ​ 设备文件浏览器 优化工具 Android 分析器 - Android Studio 3.0 包含全新的工具包，以帮助调试应用的性能问题。我们对之前的 Android Monitor 工具集进行彻底重写，代之以 Android 分析器。您将应用部署到正在运行的设备或模拟器后，点击 Android Profiler 标签，即可在实时、统一的视图中访问应用的 CPU、内存和网络活动。每个性能事件映射到 UI 事件时间线中，该时间线突出显示触摸事件、按键和活动变更，以便您更清楚地了解特定事件发生的时间和原因。 点击每个时间线，深入了解应用的性能情况。了解详情。 ​ Android 分析器 - 时间线组合视图 **CPU 分析器 **- 不必要的 CPU 处理和负载峰值是应用性能不佳的征兆。有了 CPU 分析器，您可以触发一个样本或测试的 CPU 跟踪文件，分析应用的 CPU 线程使用情况。然后，您可以使用 CPU 分析器中内置的各种数据视图和过滤器排查 CPU 性能问题。了解详情。 CPU 分析器 内存分析器 - 内存使用效率低，可能导致许多设备问题，包括 UI 反应迟钝和内存不足事件等。内存分析器将之前的堆查看器和分配跟踪器的功能集成到一个丰富的界面中，帮助调试应用中的内存使用问题。您可以通过分析内存分配、堆转储等来诊断各种内存问题。了解详情。 ​ 内存分析器 网络分析器 - 通过优化应用的前台和后台网络使用情况，可以提高应用性能和减少应用流量消耗。通过网络分析器，您可以监控应用的网络活动，检查每个网络请求的有效负载，链接回生成网络请求的源代码行。现在，网络分析器可与 HttpURLConnection、OkHttp 及 Volley 网络库配合使用。网络分析器是一项高级分析功能，可在 Android O 之前版本的设备和模拟器上启用，方法是：在 Run Configuration 框的 Profiling 标签中选中 Enable Advanced Profiling 。除了启用网络请求和有效负载分析外，此复选框还可以启用最高等级事件收集、内存对象计数和内存垃圾回收。对于基于 Android O 的设备和模拟器，只需部署应用即可。了解详情。 ​ 网络分析器 ​ Android O 之前版本的设备中的网络分析器设置 APK 分析器增强功能 - 在 Android Studio 3.0 中，我们对 APK 分析器新增了一些额外的增强功能，以帮助您进一步减小 APK 的大小。通过此功能更新，您现在可以分析免安装应用的 Zip 文件和 AAR，查看类和方法的 dex 字节码。您还可以生成 Proguard 配置规则和在 dex 查看器中加载 Proguard 映射文件。了解详情。 ​ APK 分析器 回顾一下，Android Studio 3.0 Canary 1 包含以下重要的新功能：| 开发 | 测试&amp;调试 || —————————————- | —————————————- || Kotlin 语言 | Emulator OpenGL ES 3.0 支持 || Java 8 语言 | Emulator Google Play 系统映像 || 布局编辑器增强功能 | Emulator 代理支持 || Adaptive Icon 向导 | 应用错误报告程序 || XML 字体和可下载字体 | Android Wear 旋转输入 || Android Things | APK 调试 || Intellij 平台更新 2017.1 | 布局检查器 || / | 设备文件浏览器 | 构建 优化工具 Instant App 支持 CPU 分析器 构建速度的提升 内存分析器 Google 的 Maven 存储区变更 网络分析器 / APK 分析器增强功能 更多详细信息，请查看版本说明 入门指南下载如果您使用的是之前版本的 Android Studio，您可以与稳定版并行安装 Android Studio 3.0 Canary 1。您可以从官方 Android Studio 预览版下载页面下载此更新。如本博文所述，为了支持此 IDE 中的一些新功能，对 Gradle Plugin API 做出了一些颠覆性的改动。因此，您也应在当前项目中将 Android Gradle 插件版本更新至 3.0.0-alpha1，测试和验证您的应用项目设置。 我们感谢您提供有关您喜欢的特性、存在的问题或希望看到的功能的任何反馈意见。如果您发现错误或问题，欢迎随时向我们提交问题。在我们的 Google+ 信息页或 Twitter 上与我们（Android Studio 开发团队）联系。","tags":[{"name":"Android Studio 3.0","slug":"Android-Studio-3-0","permalink":"https://goghtsui.github.io/tags/Android-Studio-3-0/"}]},{"title":"Windows 10 使用之进阶篇","date":"2017-05-10T06:50:57.000Z","path":"2017/05/10/Windows-10-使用之进阶篇/undefined/","text":"序言Windows 10 发布以来一直在使用，而且感觉很不错，为了使用更方便、更优雅，掌握一些小技巧还是非常必要的，内容不多，都是一些简单的日常可以使用的技巧及美化，可以适当提升一下逼格。 技巧透明任务栏有图有真相： 这个壁纸是系统自带的，如果搭配上你喜欢的壁纸，效果一定会更好的！我的桌面也是有文件的，隐藏、显示双击切换。 当然了，效果需要使用一个小软件，当然还有修改注册表的办法，大家自行解决。（重启电脑，需要重新启动软件设置） 下载地址：TranslucentTB.2017.2 桌面其实桌面软件很多，大家可以自己了解一些，我这里用的是 Stardock Fences 2 ，可以分组或分类管理桌面文件，下面是软件的设置页面： 再来看看桌面的效果: 右键桌面拖动松开，就可以创建分组。我不喜欢桌面太多文件，看着很乱，而且从存储空间来说桌面是占用C盘空间的，很宝贵的，所以我都是分类磁盘，不同的磁盘对应存储不同的文件及安装软件，区分开工作和生活的磁盘等方式，而不是直接放在桌面。 完全是个人喜欢问题，不喜勿喷。 命令行win + R 启动运行，输入 cmd，启动命令行模式，命令行模式可以做很多事情的，可以告别鼠标和繁琐的操作了，逼格瞬间提升： calc 打开计算器 charmap 打开字符映射表 chkdsk.exe 磁盘检查（以管理员身份运行命令行模式） cleanmgr 打开磁盘清理工具 自动关机 Shutdown -s -t 600 表示600秒后自动关机 shutdown -a 可取消定时关机 Shutdown -r -t 600 表示600秒后自动重启 control 控制面版 msdt 微软支持诊断工具 notepad 打开记事本 Rstrui 系统还原（谨慎使用） 滑动关机win + R 打开运行，输入 slidetoshutdown 试试什么效果： 输入以上命令执行会出现上面的关机界面，应该是占用半屏位置，由于截图触发按键，向上回弹了而已。我们只需要向下滑动就可以关机，如果不想关机，向上滑动就可以了。 如果觉得麻烦，想长期使用，可以添加一个桌面快捷方式： 创建一个文本文 输入 slidetoshutdown 将文本文档的txt后缀改成cmd或bat 一键结束进程Windows 10系统在运行程序较多时，有时会出现卡顿现象，想要关闭运行程序都难；Windows 10系统关机时，如果运行程序较多，一一结束运行程序，比较烦锁，而我们不关闭运行程序，系统就不能顺利关机或者关机速度慢。我们创建一个一键结束所有运行程序的快捷方式，就可以点击快捷方式，结束所有运行程序。创建一键结束所有运行程序的方法如下（正好还能使用上面的命令）： 桌面右键新建或者命令行模式输入notepad新建一个文本 在文本文档中输入以下内容： taskkill /F /FI &quot;USERNAME eq xxx&quot; /FI &quot;IMAGENAME ne explorer.exe&quot; /FI &quot;IMAGENAME ne dwm.exe&quot; 注意：将字符xxx内容替换为你的用户名 桌面右键，选择【新建】-【快捷方式】 在打开的创建快捷方式窗口的【请键入对象的位置】栏，复制刚才的内容粘贴在这，点击【下一步】 在创建快捷方式 - 键入快捷方式的名称栏输入：一键结束进程（根据自己的需要命名），再点击【完成】 【非必需】替换自己喜欢的图标 这样就在桌面上创建了一个快捷方式，关机时可以一键结束所有进程，是所有的，当然了关于taskkill命令自行脑补，可以自己定制快捷功能。 总结任何一个系统都是值得探索的，无论是手机还是PC，大家赶快搞起来吧！","tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://goghtsui.github.io/tags/Windows-10/"},{"name":"Fences","slug":"Fences","permalink":"https://goghtsui.github.io/tags/Fences/"},{"name":"cmd","slug":"cmd","permalink":"https://goghtsui.github.io/tags/cmd/"},{"name":"slidetoshutdown","slug":"slidetoshutdown","permalink":"https://goghtsui.github.io/tags/slidetoshutdown/"}]},{"title":"关于java.lang.String的intern()方法【基础篇】","date":"2017-04-28T09:10:01.000Z","path":"2017/04/28/关于java-lang-String的intern-方法【基础篇】/undefined/","text":"序言相信在开发过程中，我们对字符串（String）的使用还是非常普遍的，但它也是很讲究的，像内存的占用、线程安全问题，都是需要注意的，无意中了解到一个新的api，就是intern() ，这个到底是干什么的呢？下面就带大家简单了解一下 功能描述官方解释返回字符串对象的规范化表示形式。 一个初始时为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果池内已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。所有字面值字符串和字符串赋值常量表达式都是内部的。字符串字面值在《Java Language Specification》的 §3.10.5 中已定义。 返回：一个字符串，内容与此字符串相同，但它保证来自字符串池中。 总结：s.intern()方法执行的时候，会将池中的字符串与外部的字符串(s)进行比较，如果池中有与之相等的字符串，则不会将外部的字符串放到池中，返回的只是池中的字符串，如果不同则将外部字符串放入池中，并返回其字符串的句柄（引用）– 这样做的好处就是能够节约空间 实战分析示例代码： String a = new String(&quot;ab&quot;); String b = new String(&quot;ab&quot;); String c = &quot;ab&quot;; String d = &quot;a&quot; + &quot;b&quot;; String e = &quot;b&quot;; String f = &quot;a&quot; + e; System.out.println(b.intern() == a); System.out.println(b.intern() == c); System.out.println(b.intern() == d); System.out.println(b.intern() == f); System.out.println(b.intern() == a.intern()); 运行结果： false true true false true 结果分析： 首先说，字面值对应的是字符串池。 接下来说字符串的初始化，有以下形式： // 这种创建方式肯定不会存入字符串池，且是一个全新的对象 String str1 = new String(&quot;&quot;); // 这种方式会存储在字符串池(赋值的是：常量值) String str2 = &quot;hello&quot;; // 这种方式会存储在字符串池(赋值的是：常量值 + 常量值 = 常量值) String str3 = &quot;hello&quot; + &quot;world&quot;; // 这种方式也不会存储在字符串池(赋值的是：常量值 + 变量值 != 常量值) String str4 = str2 + &quot;world&quot;; 那么对比结果分析： a、b 都是用了关键字 new 的方式初始化，c、d、e 直接赋值字符串，f 使用的是字符串常量 + 变量的形式，也不会进入字符串池 因此可以看出来，(b.intern() == a) 和 (b.intern() == c)，采用new 创建的字符串对象不进入字符串池，而且(b.intern() == d) 和 (b.intern() == f) 在字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。","tags":[{"name":"String","slug":"String","permalink":"https://goghtsui.github.io/tags/String/"},{"name":"intern","slug":"intern","permalink":"https://goghtsui.github.io/tags/intern/"}]},{"title":"Android Studio 2.4 Preview 1 发布了！","date":"2017-03-17T03:14:12.000Z","path":"2017/03/17/Android-Studio-2-4-Preview-1-发布了！/undefined/","text":"Android Studio 2.4 Preview 1 版本于2017年3月15日，由Chris Iremonger 发布。但是这个更新只发布到了Canary的开发渠道。所以你需要设置你的Android Studio的跟新渠道为 Canary，而且这是一个初期的版本，所以在接下来的几周会有更多的更新。到底这个版本做了哪些改进呢？让我们一睹为快吧： 代码 在Android Studio 2.4 Preview 1 中，我们升级了IDE从 IntelliJ 2016.2 到 2017.1 EAP，并在 2016.3和2017.1 中增加了许多新功能，包括参数提示，语义突出显示，搜索即时结果，等等。 许多新的 lint 检查 Instant Run Instant Run Debug Issue 234401 现在应该已经解决。如果程序在断点处暂停，则应用程序重新启动。但是如果应用程序没有在断点上暂停且当你只有一个方法实现更改时，它不应该重新启动而且热更新应该工作。 Build 增量dex’ing。Dex’ing现在是在每个类级别完成的。这将允许更多增量，并会导致更快的增量构建。你应该也期望在使用传统多DEX的条件下，提高构建应用的速度（minSdkVersion &lt;21） 执行时的依赖性解析。在以前的版本中，依赖解析在Gradle配置期间发生。通过将依赖关系解析移动到执行期间 ，你应该期望为大型项目改进配置时间。 IDE 在Mac上 Android Studio 被称为“Android Studio 2.4 Preview.app”，使你更容易运行的2.3。 设备文件浏览器 -无缝查看，直接在Android Studio中修改和与设备文件系统交互。此功能取代了以前通过DDMS完成设备文件系统的交互（Dalvik的调试监控服务器） 已知的问题 如果你检查更新，它会告诉你有一个新版本 Android Studio 2.4 Preview 1（Build171.3804684） 。如果您已经安装了相同的版本，请不要尝试重新下载。我们将在 Android Studio 2.4 Preview 2 中修复。 Mac版本可能会提示您无法打开它，因为它是来自不明身份的开发人员。邮件似乎已签名，但有问题。我们将在预览2中更新它。如果您想在预览1中尝试，请右键单击并选择打开 Android Studio 官方描述","tags":[{"name":"Android Studio 2.4 Preview","slug":"Android-Studio-2-4-Preview","permalink":"https://goghtsui.github.io/tags/Android-Studio-2-4-Preview/"}]},{"title":"Android Studio 2.3全面解析","date":"2017-03-15T11:30:32.000Z","path":"2017/03/15/Android-Studio-2-3全面解析/undefined/","text":"序 Android Studio 2.3 已提供下载了，下面让我们来看看官方的描述： Android Studio 2.3 中最令人激动的是质量上的改进，但此版本也加入了少量新功能，它们集成到了开发流程的每一个阶段： 设计应用时，请充分利用面向应用图像的更新版 WebP 支持，也请了解一下更新版ConstraintLayout 内容库支持以及布局编辑器中的小部件选项板。 在开发过程中，Android Studio 新增了一个应用链接助手，它可以帮助您构建一个应用 URI 合并视图，方便您统一查看应用内的 URI。 在构建和部署应用时，使用更新版运行按钮可获得更加直观而又可靠的 Instant Run 体验。 最后，在使用 Android Emulator 测试应用时，您现在可以获得充分的文本复制与粘贴支持。 构建1. Instant Run 改进和 UI 变化 新增的 Instant Run 按钮操作 为体现对质量的重视，我们在 Android Studio 2.3 中对 Instant Run 进行了一些重大更改，以提高该功能的可靠性。Run 操作现在一律会导致应用重新启动，以便让可能需要重新启动的代码更改生效，新增的 Apply Changes 操作会尝试在应用运行时改写代码。为提升可靠性，底层实现进行了大幅度改动，并且还消灭了支持 Instant Run 应用的启动延迟。 了解详情 2. 构建缓存在 Android Studio 2.2 中引入但默认情况下处于停用状态，是一项旨在加快 Android Studio 中构建速度的底层构建优化。由于缓存了分解的 AAR 和 pre-dexed 外部内容库，因此缓存的新构建可加快干净构建的速度。在 Android Studio 2.3 中，这个用户范围构建缓存现在默认情况下处于启用状态。 了解详情 设计1. 约束布局中的链接和比例支持Android Studio 2.3 加入了稳定版 ConstraintLayout 在此版本的 ConstraintLayout, 中，您现在可以将两个或更多个 Android 视图双向链接起来，在一个维度上组成一组。如果您想让两个视图紧邻，但又想将它们散布在空白区域上，此功能就很有帮助。 了解详情 约束布局链接 ConstraintLayout 还支持比例，如果您想在包含布局展开和收缩时保持小部件的纵横比，比例会很有帮助。详细了解有关比例的信息。此外，ConstraintLayout 中的链接和比例还能支持通过 ConstraintSet API 进行编程创建。 约束布局比例 2. 布局编辑器选项板 布局编辑器小部件选项板 布局编辑器中的小部件选项板进行了更新，让您可以通过搜索、排序和过滤找到布局所需的小部件，还能让您先预览小部件，然后再拖动到设计界面上。 了解详情 3. 布局收藏夹 布局编辑器 Properties 面板上的 Favorites Attributes 布局编辑器的 Properties 面板进行了更新，您现在可以小部件为单位保存自己最爱用的属性。只需在高级面板中给属性加注星标，属性即会出现在 Favorites 部分中。 了解详情 4. WebP 支持 WebP 图像转换向导 为帮助您在 APK 中节省空间，Android Studio 现在可以利用项目中的 PNG 资源生成 WebP 图像。WebP 无损格式的体积最多可比 PNG 小 25%。 Android Studio 2.3 新增了一个向导，可通过它将 PNG 转换成无损 WebP，还能用来检查有损 WebP 的编码。右键点击任何非启动器 PNG 文件便可将其转换为 WebP 格式。并且如果您需要编辑图像，还可以右键点击项目中的任何 WebP 文件，将其转换回 PNG 格式。 了解详情 5. 材料图标向导更新 矢量资源向导 矢量资源向导进行了更新，支持搜索和过滤，此外还为每个图标资源提供了标签。 了解详情 开发1. Lint 基线 Lint 基线支持 在 Android Studio 2.3 中，您可以将未解决的 Lint 警告设置为项目中的基线。从那一刻开始，Lint 将只报告新问题。如果应用存在许多旧的 Lint 问题，但您只想集中精力解决新问题，此功能会很有帮助。 了解详情 2. 应用链接助手 应用链接助手 Android Studio 现在进一步简化了应用内 Android 应用链接支持。您可以通过新增的应用链接助手轻松创建新的网址 Intent 过滤器，通过数字资源链接文件声明应用的网站关联，以及进行 Android 应用链接支持测试。要访问应用链接助手，请转到以下菜单位置：Tools → App Link Assistant。 了解详情 3. 模板更新 新增的项目向导模板 默认情况下，Android Studio 2.3 中所有过去包含 RelativeLayout 的模板现在均使用 ConstraintLayout。了解有关模板和约束布局的更多信息。我们还新增了一个 Bottom Navigation Activity 模板，它实现的是底部导航 Material Design 规范。 4. IntelliJ 平台更新Android Studio 2.3 加入了 IntelliJ 2016.2 版，其中包含更新版检查窗口和通知系统等增强功能。 了解详情 测试1. Android Emulator 复制与粘贴 Android Emulator 中的复制与粘贴支持 应普遍要求，我们在最新版 Emulator (v25.3.1) 中恢复了复制与粘贴功能。我们在 Android Emulator 与主机操作系统之间建立了一个共享剪贴板，以便您在两个环境之间复制文本。复制与粘贴兼容 x86 Google API Emulator 系统映像 API 级别 19 (Android 4.4 - Kitkat) 及更高版本。 2. Android Emulator 命令行工具从 Android SDK Tools 25.3 开始，我们将 emulator 从 SDK Tools 文件夹移至一个单独的 emulator 目录，还弃用了“android avd”命令，并将其替换为独立的 avdmanager 命令。emulator和“android avd”之前的命令行参数仍兼容更新后的工具。我们还为 emulator 命令添加了位置重定向。 不过，如果您直接通过命令行创建 Android Virtual Device (AVD)，则应更新所有相应脚本。如果您通过 Android Studio 2.3 使用 Android Emulator，这些变动将不会影响您的工作流。 了解详情 新功能扼要重述一下，Android Studio 2.3 包含下列以及其他新功能： 开发 Lint 基线 更新版 Lint 检查与注解 应用链接助手 模板中默认情况下使用约束布局 Intellij 平台更新 2016.2 构建 Instant Run UI 变化 构建缓存 设计 约束布局链接与比例 布局编辑器中的小部件选项板 属性检查器中的收藏夹 WebP 支持 查找材料图标向导 测试 Emulator 复制与粘贴 Emulator 命令行工具 有关 Android Studio 2.3 的详情，请参阅版本说明 入门指南下载如果您使用的是早期版本的 Android Studio，可以在导航菜单中检查有无稳定版更新（Help → Check for Update [适用于 Windows/Linux]，或者 Android Studio → Check for Updates [适用于 OS X]）。 您还可以从官方下载页面下载 Android Studio 2.3 要充分利用 Android Studio 中所有新增的功能和改进，还应将您当前应用项目中的 Android Gradle 插件版本更新到 2.3.0","tags":[{"name":"Android Studio 2.3","slug":"Android-Studio-2-3","permalink":"https://goghtsui.github.io/tags/Android-Studio-2-3/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》6-3之服务器","date":"2017-03-13T11:54:42.000Z","path":"2017/03/13/《阿里巴巴Java开发手册（终结版）》6-3之服务器/undefined/","text":"工程规约 - 服务器规约 【推荐】高并发服务器建议调小 TCP 协议的 time _ wait 超时时间。说明：操作系统默认 240 秒后，才会关闭处于 time _ wait 状态的连接，在高并发访问下，服务器端会因为处于 time _ wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。正例：在 linux 服务器上请通过变更/ etc / sysctl . conf 文件去修改该缺省值 （ 秒 ） ： net . ipv 4. tcp _ fin _ timeout = 30 【推荐】调大服务器所支持的最大文件句柄数 （File Descriptor ，简写为 fd） 。说明：主流操作系统的设计是将 TCP / UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd 。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“ open too many files ”错误，导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍 （ 与服务器的内存数量相关 ） 。 【推荐】给 JVM 设置- XX :+ HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。说明： OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 【推荐】在线上生产环境， JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。 【参考】服务器内部重定向使用 forward； 外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"服务器规约","slug":"服务器规约","permalink":"https://goghtsui.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》6-2之二方库规约","date":"2017-03-08T06:24:34.000Z","path":"2017/03/08/《阿里巴巴Java开发手册（终结版）》6-2之二方库规约/undefined/","text":"工程规约 - 二方库规约 【强制】定义 GAV 遵从以下规则：1 ） G GroupID 格式： com .{公司/ BU }.业务线. [ 子业务线 ] ，最多 4 级。说明：{公司/ BU } 例如： alibaba / taobao / tmall / aliexpress 等 BU 一级 ； 子业务线可选。正例： com . taobao . jstorm 或 com.alibaba.dubbo.register2 ） A ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。正例： dubbo - client / fastjson - api / jstorm - tool3 ） V Version ：详细规定参考下方。 【强制】二方库版本号命名方式：主版本号.次版本号.修订号 1 ） 主版本号 主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。2 ） 次版本号 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。3 ） 修订号 修订号：保持完全兼容性，修复 BUG 、新增次要功能特性等 说明：注意起始版本号必须为： 1.0.0 ，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 【强制】线上应用不要依赖 SNAPSHOT 版本 （ 安全包除外 ）。说明：不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。 【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行 dependency : resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency : tree 命令，找出差异点，进行&lt; excludes &gt;排除 jar 包。 【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。 【强制】依赖于一个二方库群时，必须定义一个统一版本变量，避免版本号不一致。说明：依赖 springframework - core ,- context ,- beans ，它们都是同一个版本，可以定义一个变量来保存版本：${ spring . version }，定义依赖的时候，引用该版本。 【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId ，相同的 ArtifactId ，但是不同的Version 。 说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个 war ，只能有一个版本号出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 【推荐】所有 pom 文件中的依赖声明放在&lt; dependencies &gt;语句块中，所有版本仲裁放在&lt; dependencyManagement &gt;语句块中。说明：&lt; dependencyManagement &gt;里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖， version 和 scope 都读取自父 pom 。而&lt; dependencies &gt;所有声明在主 pom 的&lt; dependencies &gt;里的依赖都会自动引入，并默认被所有的子项目继承。 【推荐】二方库尽量不要有配置项，最低限度不要再增加配置项。 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：1 ） 精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API 、必要的领域模型对象、 Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号 ； 无 log 具体实现，只依赖日志框架。2 ） 稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"二方库规约","slug":"二方库规约","permalink":"https://goghtsui.github.io/tags/%E4%BA%8C%E6%96%B9%E5%BA%93%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》6-1之应用分层","date":"2017-03-08T06:22:48.000Z","path":"2017/03/08/《阿里巴巴Java开发手册（终结版）》6-1之应用分层/undefined/","text":"工程规约 - 应用分层 修改项：第 1、3 项 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推： 开放接口层：可直接封装 Service 方法暴露成 RPC 接口 ； 通过 Web 封装成 http 接口 ；进行网关安全控制、流量控制等 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染， JS 渲染，JSP 渲染，移动端展示等。 Web 层 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service 层 层：相对具体的业务逻辑服务层。 Manager 层 层：通用业务处理层，它有如下特征： 1） 对第三方平台封装的层，预处理返回结果及转化异常信息 ； 2）对 Service 层通用能力的下沉，如缓存方案、中间件通用处理 ； 3）与 DAO 层交互，对 DAO 的业务通用能力的封装。 DAO 层：数据访问层，与底层 MySQL 、 Oracle 、 Hbase 进行数据交互。 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。 【参考】 （ 分层异常处理规约 ） 在 DAO 层，产生的异常类型有很多，无法用细粒度异常进行catch ，使用 catch(Exception e) 方式，并 throw new DAOException(e) ，不需要打印日志，因为日志在 Manager / Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录日志信息到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。 Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。 【参考】分层领域模型规约： DO（Data Object） ：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO（Data Transfer Object） ：数据传输对象， Service 和 Manager 向外传输的对象。 BO（Business Object） ：业务对象。可以由 Service 层输出的封装业务逻辑的对象。 AO（Application Object） ：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 QUERY ：数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。 VO（View Object） ：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"应用分层","slug":"应用分层","permalink":"https://goghtsui.github.io/tags/%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》5-4之ORM映射","date":"2017-03-03T07:18:09.000Z","path":"2017/03/03/《阿里巴巴Java开发手册（终结版）》5-4之ORM映射/undefined/","text":"ORM 规约 修改项：第 3 项、第 4 项、第 5 项、第 6 项 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。说明：1 ） 增加查询分析器解析成本。2 ） 增减字段容易与 resultMap 配置不一致。 【强制】 POJO 类的 boolean 属性不能加 is ，而数据库字段必须加 is _，要求在 resultMap 中进行字段与属性之间的映射。 说明：参见定义 POJO 类以及数据库字段定义规定，在 中 增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义 ； 反过来，每一个表也必然有一个与之对应。说明：配置映射关系，使字段与 DO 类解耦，方便维护。 【强制】sql. xml 配置参数使用：#{}，# param # 不要使用${} 此种方式容易出现 SQL 注入。 【强制】 iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。 说明：其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList取 start , size 的子集合。正例： Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;size&quot;, size); 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。 说明： resultClass=”Hashtable” ，会置入字段名和属性值，但是值的类型不可控。 【强制】更新数据表记录时，必须同时更新记录对应的 gmt _ modified 字段值为当前时间。 【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，尽量不要更新无改动的字段，一是易出错 ； 二是效率低 ； 三是 binlog 增加存储。 【参考】@ Transactional 事务不要滥用。事务会影响数据库的 QPS ，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 【参考】&lt; isEqual &gt;中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件 ； &lt; isNotEmpty &gt;表示不为空且不为 null 时执行 ； &lt; isNotNull &gt;表示不为 null 值时执行。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"ORM映射","slug":"ORM映射","permalink":"https://goghtsui.github.io/tags/ORM%E6%98%A0%E5%B0%84/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》5-3之SQL语句","date":"2017-03-03T07:17:46.000Z","path":"2017/03/03/《阿里巴巴Java开发手册（终结版）》5-3之SQL语句/undefined/","text":"SQL 规约 修改项：第 4 项 【强制】不要使用 count( 列名 ) 或 count( 常量 ) 来替代 count( * ) ， count( * ) 就是 SQL 92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count( * ) 会统计值为 NULL 的行，而 count( 列名 ) 不会统计此列为 NULL 值的行。 【强制】 count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinctcol 1, col 2 ) 如果其中一列全为 NULL ，那么即使另一列有不同的值，也返回为 0。 【强制】当某一列的值全是 NULL 时， count(col) 的返回结果为 0，但 sum(col) 的返回结果为NULL ，因此使用 sum() 时需注意 NPE 问题。正例：可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)) ,0, SUM(g))FROM table; 【强制】使用 ISNULL() 来判断是否为 NULL 值。说明： NULL 与任何值的直接比较都为 NULL。1 ） NULL&lt;&gt;NULL 的返回结果是 NULL ，而不是 false 。2 ） NULL=NULL 的返回结果是 NULL ，而不是 true 。3 ） NULL&lt;&gt;1 的返回结果是 NULL ，而不是 true 【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明： （ 概念解释 ） 学生表中的 student _ id 是主键，那么成绩表中的 student _ id 则为外键。如果更新学生表中的 student _ id ，同时触发成绩表中的 student _ id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群 ； 级联更新是强阻塞，存在数据库更新风暴的风险 ； 外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正时，删除和修改记录时，要先 select ，避免出现误删除，确认无误才能执行更新语句。 【推荐】 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf -8 编码，那么字符计数方法注意：说明：SELECT LENGTH( “轻松工作” )； 返回为 12SELECT CHARACTER _ LENGTH( “轻松工作” )； 返回为 4如果要使用表情，那么使用 utfmb 4 来进行存储，注意它与 utf -8 编码的区别。 【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger ，有可能造成事故，故不建议在开发代码中使用此语句。说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"SQL语句","slug":"SQL语句","permalink":"https://goghtsui.github.io/tags/SQL%E8%AF%AD%E5%8F%A5/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》5-2之索引规约","date":"2017-03-01T06:52:21.000Z","path":"2017/03/01/《阿里巴巴Java开发手册（终结版）》5-2之索引规约/undefined/","text":"MySQL - 索引规约 修改项：第 1 项、 第 11 项 新增项：第10 项 【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的 ； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 【强制】 超过三个表禁止 join 。需要 join 的字段，数据类型保持绝对一致 ； 多表关联查询时，保证被关联的字段需要有索引。说明：即使双表 join 也要注意表索引、 SQL 性能。 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left( 列名, 索引长度 )) / count( * ) 的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。说明：索引文件具有 B - Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file _ sort 的情况，影响查询性能。正例： where a =? and b =? order by c; 索引： a _ b _ c反例：索引中有范围查找，那么索引有序性无法利用，如： WHERE a &gt;10 ORDER BY b; 索引a _ b 无法排序。 【推荐】利用覆盖索引来进行查询操作，来避免回表操作。说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果， extra 列会出现： using index 。 【推荐】利用延迟关联或者子查询优化超多分页场景。说明： MySQL 并不是跳过 offset 行，而是取 offset + N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】 SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。说明：1 ）consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） ，在优化阶段即可读取到数据。2 ）ref 指的是使用普通的索引 （normal index） 。3 ）range 对索引进行范围检索。反例： explain 表的结果， type = index ，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 【推荐】建组合索引的时候，区分度最高的在最左边。正例：如果 where a =? and b =? ， a 列的几乎接近于唯一值，那么只需要单建 idx _ a 索引即可。说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where a &gt;?and b =? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 【参考】创建索引时避免有如下极端误解：1 ） 宁滥勿缺。认为一个查询就需要建一个索引。2 ） 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。3 ） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 以上内容均整理自《阿里巴巴Java开发手册（终结版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"索引规约","slug":"索引规约","permalink":"https://goghtsui.github.io/tags/%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终结版）》5-1之建表规约","date":"2017-03-01T06:51:25.000Z","path":"2017/03/01/《阿里巴巴Java开发手册（终极版）》5-1之建表规约/undefined/","text":"MySQL - 建表规约 修改项：第 1 项、 第 9 项、第 15 项 【强制】表达是与否概念的字段，必须使用 is _ xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否 ） 。说明：任何字段如果为非负数，必须是 unsigned 。正例：表达逻辑删除的字段名 is_deleted ，1 表示删除，0 表示未删除。 【强制】表名、字段名必须使用小写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例： aliyun _ admin ， rdc _ config ， level 3_ name反例： AliyunAdmin ， rdcConfig ， level 3 name 【强制】表名不使用复数名词。说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如 desc 、 range 、 match 、 delayed 等，请参考 MySQL 官方保留字。 【强制】唯一索引名为 uk _字段名 ； 普通索引名则为 idx _字段名。说明： uk _ 即 unique key；idx _ 即 index 的简称。 【强制】小数类型为 decimal ，禁止使用 float 和 double 。说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【强制】表必备三字段： id , gmt _ create , gmt _ modified 。说明：其中 id 必为主键，类型为 unsigned bigint 、单表时自增、步长为 1。 gmt_create,gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。 【推荐】表的命名最好是加上“业务名称_表的作用”。正例： alipay _ task / force _ project / trade _ config 【推荐】库名与应用名称尽量一致。 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：1 ） 不是频繁修改的字段。2 ） 不是 varchar 超长字段，更不能是 text 字段。正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过 500 万行或者单表容量超过 2 GB ，才推荐进行分库分表。说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围 对象 年龄区间 类型 字节 表示范围 人 150之内 unsigned tinyint 1 无符号值：0 - 255 龟 数百岁 unsigned smallint 2 无符号值：0 - 65535 恐龙化石 数千万年 unsigned int 4 无符号值：0 - 约 42.9 亿 太阳 约50亿年 unsigned bigint 8 无符号值：0 到约 10 的 19 次方 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终结版）","slug":"阿里巴巴Java开发手册（终结版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/"},{"name":"建表规约","slug":"建表规约","permalink":"https://goghtsui.github.io/tags/%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》2-2之日志规约","date":"2017-02-27T03:09:27.000Z","path":"2017/02/27/《阿里巴巴Java开发手册（终极版）》2-2之日志规约/undefined/","text":"异常日志 - 日志规约 【强制】应用中不可直接使用日志系统 （Log 4 j 、 Logback） 中的 API ，而应依赖使用日志框架SLF 4 J 中的 API ，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式：appName _ logType _ logName . log 。 logType :日志类型，推荐分类有stats / desc / monitor / visit 等 ；logName :日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。正例： mppserver 应用中单独监控时区转换异常，如：mppserver _ monitor _ timeZoneConvert . log说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 【强制】对 trace / debug / info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。说明： logger . debug( “ Processing trade with id : “ + id + “ symbol : “ + symbol);如果日志级别是 warn ，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。正例： （ 条件 ） if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); &#125; 正例： （ 占位符 ） logger.debug(&quot;Processing trade with id: &#123;&#125; symbol : &#123;&#125; &quot;, id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log 4 j . xml 中设置 additivity = false 。正例： &lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上抛。正例： logger.error(各类参数或者对象 toString + &quot;_&quot; + e.getMessage(), e); 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志 ； 有选择地输出 info 日志 ； 如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别， error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"日志规约","slug":"日志规约","permalink":"https://goghtsui.github.io/tags/%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》2-1之异常处理","date":"2017-02-27T03:08:57.000Z","path":"2017/02/27/《阿里巴巴Java开发手册（终极版）》2-1之异常处理/undefined/","text":"异常日志 - 异常处理 第 1 项、第 9 项、 第 10 项、第 12 项 【强制】 Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catchNumberFormatException 来实现。 正例： if(obj != null) &#123;...&#125; 反例： try &#123; obj.method() &#125; catch(NullPointerException e)&#123;...&#125; 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try - catch ，这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】 finally 块必须对资源对象、流对象进行关闭，有异常也要做 try - catch 。说明：如果 JDK 7，可以使用 try - with - resources 方式。 【强制】不能在 finally 块中使用 return ， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 【推荐】方法的返回值可以为 null ，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况。 【推荐】防止 NPE ，是程序员的基本修养，注意 NPE 产生的场景：1 ） 返回类型为包装数据类型，有可能是 null ，返回 int 值时注意判空。反例： public int f() { return Integer 对象}; 如果为 null ，自动解箱抛 NPE 。2 ） 数据库的查询结果可能为 null 。3 ） 集合里的元素即使 isNotEmpty ，取出的数据元素也可能为 null 。4 ） 远程调用返回对象，一律要求进行 NPE 判断。5 ） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。6 ） 级联调用 obj . getA() . getB() . getC()； 一连串调用，易产生 NPE 。 正例：使用 JDK8 的 Optional 类来防止 NPE 问题。 【推荐】定义时区分 unchecked / checked 异常，避免直接使用 RuntimeException 抛出，更不允许抛出 Exception 或者 Throwable ，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如： DAOException / ServiceException 等。 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http / api 开放接口必须使用“错误码” ； 而应用内部推荐异常抛出 ； 跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法 、“错误码”、“错误简短信息”。说明：关于 RPC 方法返回方式使用 Result 方式的理由：1 ） 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。2 ） 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message ，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 【参考】避免出现重复的代码 （Don ’ t Repeat Yourself） ，即 DRY 原则。说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto)&#123;...&#125; 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"异常处理","slug":"异常处理","permalink":"https://goghtsui.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-9之其它","date":"2017-02-24T02:16:27.000Z","path":"2017/02/24/《阿里巴巴Java开发手册（终极版）》1-9之其它/undefined/","text":"编程规约 - 其它 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。说明：不要在方法体内定义： Pattern pattern = Pattern . compile( 规则 ); 【强制】 velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx() ，如果是 boolean 基本数据类型变量 （boolean 命名不需要加 is前缀 ） ，会自动调用 isXxx() 方法。说明：注意如果是 Boolean 包装类对象，优先调用 getXxx() 的方法。 【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。说明：如果 var = null 或者不存在，那么 ${var} 会直接显示在页面上。 【强制】注意 Math . random() 这个方法返回是 double 类型，注意取值的范围 0≤ x &lt;1 （ 能够取到零值，注意除零异常 ） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 【强制】获取当前毫秒数 System . currentTimeMillis(); 而不是 new Date() . getTime();说明：如果想获取更加精确的纳秒级时间值，用 System . nanoTime() 。在 JDK 8 中，针对统计时间等场景，推荐使用 Instant 类。 【推荐】不要在视图模板中加入任何复杂的逻辑。说明：根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 【推荐】及时清理不再使用的代码段或配置信息。说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-8之注释规约","date":"2017-02-24T02:15:51.000Z","path":"2017/02/24/《阿里巴巴Java开发手册（终极版）》1-8之注释规约/undefined/","text":"编程规约 - 注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用// xxx 方式。说明：在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释 ； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。说明：对子类的实现要求，或者调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者信息。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例：“ TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。说明：代码被注释掉有两种可能性：1 ） 后续会恢复此段代码逻辑。2 ） 永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉 （ 代码仓库保存了历史代码 ） 。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑 ； 第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路 ； 注释也是给继任者看的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。反例： // put elephant into fridge put(elephant, fridge); 方法名 put ，加上两个有意义的变量名 elephant 和 fridge ，已经说明了这是在干什么，语 义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1 ） 待办事宜 （TODO） : （ 标记人，标记时间， [ 预计处理时间 ]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法 （ 因为它是一个 Javadoc 标签 ） 。2 ） 错误，不能工作 （FIXME） : （ 标记人，标记时间， [ 预计处理时间 ]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"注释规约","slug":"注释规约","permalink":"https://goghtsui.github.io/tags/%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-7之控制语句","date":"2017-02-23T06:25:19.000Z","path":"2017/02/23/《阿里巴巴Java开发手册（终极版）》1-7之控制语句/undefined/","text":"编程规约 - 控制语句 修改项：第 3 项 【强制】在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【强制】在 if / else / for / while / do 语句中必须使用大括号，即使只有一行代码，避免使用下面的形式： if (condition) statements; 【推荐】推荐尽量少用 else ， if - else 的方式可以改写成： if(condition)&#123; ... return obj; &#125; // 接着写 else 的业务逻辑代码; 说明：如果非得使用 if()…else if()…else… 方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： public void today() &#123; if (isBusy()) &#123; System.out.println(“change time.”); return; &#125; if (isFree()) &#123; System.out.println(“go to travel.”); return; &#125; System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return; &#125; 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？正例： //伪代码如下 boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) &#123; ... &#125; 反例： if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123; ... &#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try - catch 操作 （ 这个 try - catch 是否可以移至循环体外 ） 。 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 【参考】方法中需要进行参数校验的场景：1 ） 调用频次低的方法。2 ） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3 ） 需要极高稳定性和可用性的方法。4 ） 对外提供的开放接口，不管是 RPC / API / HTTP 接口。5） 敏感权限入口。 【参考】方法中不需要参数校验的场景：1 ） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查。2 ） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。3 ） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。 以上内容均整理自《阿里巴巴Java开发手册》 ​ 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"控制语句","slug":"控制语句","permalink":"https://goghtsui.github.io/tags/%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-6之并发处理","date":"2017-02-23T06:24:56.000Z","path":"2017/02/23/《阿里巴巴Java开发手册（终极版）》1-6之并发处理/undefined/","text":"编程规约 - 并发处理 修改项：第 6 项 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。说明：资源驱动类、工具类、单例工厂类都需要注意。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例： public class TimerTaskThread extends Thread &#123; public TimerTaskThread()&#123; super.setName(&quot;TimerTaskThread&quot;); ... &#125; 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。2） CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static ，必须加锁，或者使用 DateUtils 工具类。正例：注意线程安全，使用 DateUtils 。亦推荐如下处理： private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @ Override protected DateFormat initialValue() &#123; return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); &#125; &#125;; 说明：如果是 JDK 8 的应用，可以使用 Instant 代替 Date ， LocalDateTime 代替 Calendar ，DateTimeFormatter 代替 Simpledateformatter ，官方给出的解释： simple beautiful strongimmutable thread - safe 。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁 ； 能锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁。说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。说明：线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A 、 B 、 C ，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。说明：注意，子线程抛出异常堆栈，不能在主线程 try - catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。说明： Random 实例包括 java . util . Random 的实例或者 Math . random() 实例。正例：在 JDK 7 之后，可以直接使用 API ThreadLocalRandom ，在 JDK 7 之前，可以做到每个线程一个实例。 【推荐】通过双重检查锁 （double - checked locking）（ 在并发场景 ） 实现延迟初始化的优化问题隐患 ( 可参考 The “ Double - Checked Locking is Broken “ Declaration) ,推荐问题解决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） ，将目标属性声明为 volatile 型 。反例： class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; 【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count ++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count . addAndGet( 1 ); 如果是 JDK 8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。 【参考】 ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。 以上内容均整理自《阿里巴巴Java开发手册》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"并发处理","slug":"并发处理","permalink":"https://goghtsui.github.io/tags/%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-5之集合处理","date":"2017-02-21T07:16:28.000Z","path":"2017/02/21/《阿里巴巴Java开发手册（终极版）》1-5之集合处理/undefined/","text":"编程规约 - 集合处理 修改项：第 9 项 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：1） 只要重写 equals ，就必须重写 hashCode 。2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 【强制】 ArrayList 的 subList 结果不可强转成 ArrayList ，否则会抛出 ClassCastException异常： java . util . RandomAccessSubList cannot be cast to java . util . ArrayList ;说明： subList 返回的是 ArrayList 的内部类 SubList ，并不是 ArrayList ，而是ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 list . size() 。 说明：使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配内存空间，并返回新数组地址 ； 如果数组元素大于实际所需，下标为 [ list . size() ] 的数组元素将被置为 null ，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 正例： List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array); 反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其它类型数组将出现 ClassCastException 错误。 【强制】使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add / remove / clear 方法会抛出 UnsupportedOperationException 异常。说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays . asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;; List list = Arrays.asList(str); 第一种情况： list.add(“c”); 运行时异常。第二种情况： str[0]= “gujin”; 那么 list.get(0) 也会随之修改。 【强制】泛型通配符&lt;? extends T &gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 &lt;? super T&gt; 不能使用 get 方法，做为接口调用赋值时易出错。说明：扩展说一下 PECS(Producer Extends Consumer Super) 原则：第一、频繁往外读取内容的，适合用&lt;? extends T &gt;。第二、经常往里插入的，适合用 &lt;? super T&gt; 。 【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) &#123; if(&quot;1&quot;.equals(temp))&#123; a.remove(temp); &#125; &#125; 正例： Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext())&#123; String temp = it.next(); if(删除元素的条件)&#123; it.remove(); &#125; &#125; 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 【强制】 在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays . sort ，Collections . sort 会报 IllegalArgumentException 异常。说明：1 ） 自反性： x ， y 的比较结果和 y ， x 的比较结果相反。2 ） 传递性： x &gt; y , y &gt; z ,则 x &gt; z 。3 ） 对称性： x = y ,则 x , z 比较结果和 y ， z 比较结果相同。反例：下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125; &#125; 【推荐】集合初始化时，指定集合初始值大小。说明： HashMap 使用 HashMap(int initialCapacity) 初始化，正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loaderfactor）默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16（即默认值）。反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大， resize 需要重建 hash 表，严重影响性能。 【推荐】使用 entrySet 遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历。说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value 。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK 8，使用 Map . foreach 方法。正例： values() 返回的是 V 值集合，是一个 list 集合对象 ；keySet() 返回的是 K 值集合，是一个 Set 集合对象 ；entrySet() 返回的是 K - V 值组合集合。 【推荐】高度注意 Map 类集合 K / V 能不能存储 null 值的情况，如下表格： 集合类 Key Value Super 说明 Hashtable 不允许为 null 不允许为 null Dictionary 线程安全 ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术 TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全 HashMap 允许为 null 允许为 null AbstractMap 线程不安全 反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储 null 值时会抛出 NPE 异常。 【参考】合理利用好集合的有序性 (sort) 和稳定性 (order) ，避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则依次排列的。如： ArrayList 是 order / unsort；HashMap 是 unorder / unsort；TreeSet 是order / sort 。 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。 以上内容均整理自《阿里巴巴Java开发手册》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"集合处理","slug":"集合处理","permalink":"https://goghtsui.github.io/tags/%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-4之OOP规约","date":"2017-02-20T03:17:33.000Z","path":"2017/02/20/《阿里巴巴Java开发手册（终极版）》1-4之OOP规约/undefined/","text":"编程规约 - OOP规约 修改项：第 17 项、第 18 项 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 【强制】所有的覆写方法，必须加@ Override 注解。反例： getObject() 与 get 0 bject() 的问题。一个是字母的 O ，一个是数字的 0，加@ Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）正例： public User getUsers(String type, Integer... ids) 【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@ Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。说明：java . net . URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode) 。接口提供方既然明确是过时接口，那么有义务同时提供新的接口 ； 作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 。正例： &quot; test &quot; .equals(object); 反例： object.equals( &quot; test &quot; ); 说明：推荐使用 java . util . Objects # equals （JDK 7 引入的工具类 ） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。说明：对于 Integer var =? 在-128 至 127 之间的赋值， Integer 对象是在IntegerCache . cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 【强制】关于基本数据类型与包装数据类型的使用标准如下：1 ） 所有的 POJO 类属性必须使用包装数据类型。2 ） RPC 方法的返回值和参数必须使用包装数据类型。3 ） 所有的局部变量【推荐】使用基本数据类型。说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。正例：数据库的查询结果可能是 null ，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例：比如显示成交总额涨跌情况，即正负 x %， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。反例： POJO 类的 gmtCreate 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败 ； 如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】 POJO 类必须写 toString 方法。使用 IDE 的中工具： source &gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super . toString 。说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString() 方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。说明： String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;); //预期大于 3，结果是 3 System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter方法。说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好 ； 保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法 ； 而私有方法外部一般不需要特别关心，是一个黑盒实现 ； 因为方法信息价值较低，所有 Service 和 DAO 的 getter / setter 方法放在类体最后。 【推荐】 setter 方法中，参数名称与类成员变量名称一致， this .成员名=参数名。在getter / setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。反例： public Integer getData()&#123; if(true) &#123; return data + 100; &#125; else &#123; return data - 100; &#125; &#125; 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 反例： String str = &quot;start&quot;; for(int i=0; i&lt;100; i++)&#123; str = str + &quot;hello&quot;; &#125; 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 【推荐】 final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：1） 不允许被继承的类，如： String 类。2） 不允许修改引用的域对象，如： POJO 类的域变量。3） 不允许被重写的方法，如： POJO 类的 setter 方法。4） 不允许运行过程中重新赋值的局部变量。5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用 Object 的 clone 方法来拷贝对象。说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 【推荐】类成员与方法访问控制从严：1 ） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 。2 ） 工具类不允许有 public 或 default 构造方法。3 ） 类非 static 成员变量并且与子类共享，必须是 protected 。4 ） 类非 static 成员变量并且仅在本类使用，必须是 private 。5 ） 类 static 成员变量如果仅在本类使用，必须是 private 。6 ） 若是 static 成员变量，必须考虑是否为 final 。7 ） 类成员方法只供类内部调用，必须是 private 。8 ） 类成员方法只对继承类公开，那么限制为 protected 。说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。 以上内容均整理自《阿里巴巴Java开发手册》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"OOP规约","slug":"OOP规约","permalink":"https://goghtsui.github.io/tags/OOP%E8%A7%84%E7%BA%A6/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-3之格式规约","date":"2017-02-16T02:04:17.000Z","path":"2017/02/16/《阿里巴巴Java开发手册（终极版）》1-3之代码格式/undefined/","text":"编程规约 - 代码格式 修改项：第 2 项、第 4 项 新增项：第 6 项 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行 ； 如果是非空代码块则：1 ） 左大括号前不换行。2 ） 左大括号后换行。3 ） 右大括号前换行。4 ） 右大括号后还有 else 等代码则不换行 ； 表示终止右大括号后必须换行。 【强制】 左小括号和字符之间不出现空格 ； 同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。反例： if (空格 a == b 空格) 【强制】 if / for / while / switch / do 等保留字与左右括号之间都必须加空格。 【强制】任何二目、三目运算符的左右两边都需要加一个空格。说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 【强制】缩进采用 4 个空格，禁止使用 tab 字符。说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character ；而在 eclipse 中，必须勾选 insert spaces for tabs 。正例： （ 涉及 1-5 点 ） public static void main(String args[]) &#123; // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 &#125; &#125; ​ 【强制】注释的双斜线与注释内容之间有且仅有一个空格。正例： // 注释内容，注意在 // 和注释内容之间有一个空格。 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。2 ） 运算符与下文一起换行。3 ） 方法调用的点符号与下文一起换行。4 ） 在多个参数超长，逗号后进行换行。5 ） 在括号前不要换行，见反例。正例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;); 反例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例：下例中实参的” a “,后边必须要有一个空格。 method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 【强制】 IDE 的 text file encoding 设置为 UTF -8 ; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。 【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a 、 b 、 c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明：没有必要插入多行空格进行隔开。 以上内容均整理自《阿里巴巴Java开发手册》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"代码格式","slug":"代码格式","permalink":"https://goghtsui.github.io/tags/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-2之常量定义","date":"2017-02-15T06:22:17.000Z","path":"2017/02/15/《阿里巴巴Java开发手册（终极版）》1-2之常量定义/undefined/","text":"编程规约 - 常量定义 修改：第 3 项、第 5 项 【强制】不允许出现任何魔法值 （ 即未经定义的常量 ） 直接出现在代码中。反例： String key =&quot; Id # taobao _&quot;+ tradeId； cache . put(key , value); 【强制】 long 或者 Long 初始赋值时，必须使用大写的 L ，不能是小写的 l ，小写容易跟数字1 混淆，造成误解。说明： Long a = 2 l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。正例：缓存相关常量放在类 CacheConsts 下 ； 系统配置相关常量放在类 ConfigConsts 下。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。1 ） 跨应用共享常量：放置在二方库中，通常是 client . jar 中的 constant 目录下。2 ） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义 了表示“是”的变量：类 A 中： public static final String YES = &quot; yes &quot; ; 类 B 中： public static final String YES = &quot; y &quot; ; A . YES . equals(B . YES) 预期是 true ，但实际返回为 false ，导致产生线上问题。3 ） 子工程内部共享常量：即在当前子工程的 constant 目录下。4 ） 包内共享常量：即在当前包下单独的 constant 目录下。5 ） 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。 正例： public Enum &#123; MONDAY( 1 ) , TUESDAY( 2 ) , WEDNESDAY( 3 ) , THURSDAY( 4 ) , FRIDAY( 5 ) ,SATURDAY( 6 ) , SUNDAY( 7 ); &#125; 以上内容均整理自《阿里巴巴Java开发手册》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"},{"name":"常量定义","slug":"常量定义","permalink":"https://goghtsui.github.io/tags/%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/"}]},{"title":"《阿里巴巴Java开发手册（终极版）》1-1之命名规范","date":"2017-02-10T07:31:56.000Z","path":"2017/02/10/《阿里巴巴Java开发手册（终极版）》1-1之命名规范/undefined/","text":"编程规约 - 命名规约 修改项：第 3 项 添加项：第 11 项 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例： _name / __name / $Object / name_ / name$ / Object$ 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。反例： DaZhePromotion [ 打折 ] / getPingfenByName() [ 评分 ] / int 某变量 = 3 正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO 正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion ​反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX _ STOCK _ COUNT 反例： MAX _ COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分，数组定义如下： String[] args;反例：请勿使用 String args[] 的方式来定义。 【强制】 POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型 boolean isSuccess； 的属性，它的方法也是 isSuccess() ， RPC框架在反向解析的时候，“以为”对应的属性名称是 success ，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com . alibaba . open . util 、类名为 MessageUtils（ 此规则参考spring 的框架结构 ） 【强制】杜绝完全不规范的缩写，避免望文不知义。反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi ，此类随意缩写严重降低了代码的可阅读性。 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。 正例：从远程仓库拉取代码的类命名为：PullCodeFromRemoteRepository反例：变量 int a; 的随意命名方式 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。正例： public class OrderFactory; public class LoginProxy; public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。正例： 接口方法签名： void f(); 接口基础常量表示： String COMPANY = &quot; alibaba &quot; ; 反例： 接口方法定义： public abstract void f(); 说明： JDK 8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。 接口和实现类的命名有两套规则：1 ） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。正例： CacheServiceImpl 实现 CacheService 接口。2 ） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名 （ 通常是– able 的形式 ） 。正例： AbstractTranslator 实现 Translatable 。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字： DealStatusEnum， 成员名称： SUCCESS / UNKOWN _ REASON 。 【参考】各层命名规约：A) Service / DAO 层方法命名规约1 ） 获取单个对象的方法用 get 做前缀。2 ） 获取多个对象的方法用 list 做前缀。3 ） 获取统计值的方法用 count 做前缀。4 ） 插入的方法用 save/insert 做前缀。5 ） 删除的方法用 remove/delete 做前缀。6 ） 修改的方法用 update 做前缀。B) 领域模型命名规约1 ） 数据对象： xxxDO ， xxx 即为数据表名。2 ） 数据传输对象： xxxDTO ， xxx 为业务领域相关的名称。3 ） 展示对象： xxxVO ， xxx 一般为网页名称。4 ） POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO 。 以上内容均整理自《阿里巴巴Java开发手册（终极版）》 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册终极版","slug":"阿里巴巴Java开发手册终极版","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E7%BB%88%E6%9E%81%E7%89%88/"},{"name":"命名规约","slug":"命名规约","permalink":"https://goghtsui.github.io/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E7%BA%A6/"}]},{"title":"","date":"2017-02-10T06:48:31.000Z","path":"2017/02/10/《阿里巴巴Java开发手册》之终极版修订！/undefined/","text":"已经同步最终版 序言首先，这肯定是一个非常重大的消息。绝对是Java程序员的福利啊，终于结束了一个公司一套规范的编程生涯。这对业界规范来说也起到了很好的推动作用。俗话说：无规矩不方圆，生活中各种法律道德的约束，出门还有交规的限制。相信小伙伴们一定经历过 坑，有了这本规范手册，你是不是该好好学习一下呢？ 目录章节内容分五大类，总共19章节： 索引 一级目录 二级目录 一 编程规约 命名规约、常量定义、代码格式、OOP规约、集合处理、并发处理、控制语句、注释规约、其它 二 异常日志 异常处理、日志规约 三 单元测试 无 四 安全规约 无 五 MySQL数据库 建表规约、索引规约、SQL语句、ORM映射 六 工程结构 应用分层、二方库依赖、服务器 手册专有名词（新增） POJO（ Plain Ordinary Java Object ）: 在本手册中，POJO 专指只有 setter / getter / toString 的简单类，包括 DO/DTO/BO/VO 等。 GAV（ GroupId、ArtifactctId、Version ）: Maven 坐标，是用来唯一标识 jar 包。 OOP（ Object Oriented Programming ）: 本手册泛指类、对象的编程处理方式。 ORM（ Object Relation Mapping ）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS, mybatis 等框架。 NPE（ java.lang.NullPointerException ）: 空指针异常。 SOA（ Service-Oriented Architecture ）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。 一方库: 本工程内部子项目模块依赖的库（jar 包）。 二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。 三方库: 公司之外的开源库（jar 包）。 IDE（ Integrated Development Environment ）: 用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指 IntelliJ IDEA和 eclipse。 ​ 总结阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目； 此次首度公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 下载 提供Gitbook在线阅读和pdf下载：查看福利","tags":[{"name":"阿里巴巴Java开发手册（终极版）","slug":"阿里巴巴Java开发手册（终极版）","permalink":"https://goghtsui.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89/"}]},{"title":"Java对象内存占用分析","date":"2017-01-19T08:15:48.000Z","path":"2017/01/19/Java对象内存占用分析/undefined/","text":"原文地址：查看原文 序言之前说过在Android中关于enum的使用，对内存的占用比较大，所以就了解了一下内存占用方面，基本上大同小异，下面是我觉得比较全面的描述，重新排版、整理，如果有时间，希望你能好好了解一下。 下面的内容深入分析并验证了不同Java对象占用内存空间大小的情况。对于不同的jvm实现，Java对象占用的内存空间大小可能不尽相同，本文主要分析HotSpot jvm中的情况，实验环境为64位window10系统、JDK1.8，使用JProfiler进行结论验证。 Java对象内存布局Java对象的内存布局包括 对象头(Header) 实例数据(Instance Data) 补齐填充(Padding) 对象头：在64位机器上，默认不开启指针压缩（-XX:-UseCompressedOops）的情况下，对象头占用12bytes，开启指针压缩（-XX:+UseCompressedOops）则占用16bytes。 实例数据：原生类型（primitive type）的内存占用如下： Primitive Type Memory Required(bytes) byte, boolean 1 byte short, char 2 bytes int, float 4 bytes long, double 8 bytes 注：对象引用（reference）类型在64位机器上，关闭指针压缩时占用4bytes， 开启时占用8bytes 对齐填充：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。例如，一个包含两个属性的对象：int和byte，并不是占用17bytes(12+4+1)，而是占用24bytes（对17bytes进行8字节对齐） Java对象内存占用首先根据以上的计算规则，进行一个简单的验证。使用下面的程序进行验证： public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; TestObject testObject = new TestObject(); Thread.sleep(600 * 1000); System.out.println(testObject); &#125; &#125; class TestObject &#123; private int i; private double d; private char[] c; public TestObject() &#123; this.i = 1; this.d = 1.0; this.c = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;; &#125; &#125; TestObject对象有四个属性，分别为int, double, Byte, char[]类型。在打开指针压缩(-XX:+UseCompressedOops)的情况下，在64位机器上，TestObject占用的内存大小应为： 12(Header) + 4(int) + 8(double) + 4(reference) = 28 (bytes)，加上8字节对齐，最终的大小应为32 bytes。 JProfiler中的结果为： 可以看到,TestObject占用的内存空间大小（Shallow Size）为32 bytes。 关于Retained Size和Shallow Size的区别，可以参看：Shallow Size和 Retained Size的区别 当指针压缩关闭时(-XX:-UseCompressedOops)，在64位机器上，TestObject占用的内存大小应为： 16(Header) + 4(int) + 8(double) + 8(reference) = 36 (bytes), 8字节对齐后为 40 bytes。 JProfile的结果为： 包装类型包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小等于对象头大小加上底层基础数据类型的大小。 包装类型的对象内存占用情况如下： Numberic Wrappers +useCompressedOops -useCompressedOops Byte, Boolean 16 bytes 24 bytes Short, Character 16 bytes 24 bytes Integer, Float 16 bytes 24 bytes Long, Double 24 bytes 24 bytes 数组64位机器上，数组对象的对象头占用24 bytes，启用压缩后占用16字节。比普通对象占用内存多是因为需要额外的空间存储数组的长度。基础数据类型数组占用的空间包括数组对象头以及基础数据类型数据占用的内存空间。由于对象数组中存放的是对象的引用，所以对象数组本身的大小=数组对象头+length * 引用指针大小，总大小为对象数组本身大小+存放的数据的大小之和。 举两个例子： int[10]: 开启压缩：16 + 10 * 4 = 56 bytes； 关闭压缩：24 + 10 * 4 = 64bytes。 new Integer[3]: 关闭压缩： Integer数组本身：24(header) + 3 * 8(Integer reference) = 48 bytes; 总共：48 + 3 * 24(Integer) = 120 bytes。 开启压缩： Integer数组本身：16(header) + 3 * 4(Integer reference) = 28(padding) -&gt; 32 (bytes) 总共：32 + 3 * 16(Integer) = 80 (bytes) String在JDK1.7及以上版本中，String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode, 部分源代码如下： public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 &#125; 因此，在关闭指针压缩时，一个String本身需要 16(Header) + 8(char[] reference) + 4(int) = 32 bytes。除此之外，一个char[]占用24 + length * 2 bytes(8字节对齐), 即一个String占用的内存空间大小为： 56 + length * 2 bytes (8字节对齐)。举几个例子。 一个空字符串(“”)的大小应为：56 + 0 * 2 bytes = 56 bytes。JProfiler结果： 字符串”abc”的大小应为：56 + 3 * 2 = 62(8字节对齐)-&gt;64 (bytes) 字符串”abcde”的大小应为：56 + 5 * 2 = 66-&gt;72 (bytes) 字符串”abcde”在开启指针压缩时的大小为： String本身：12(Header) + 4(char[] reference) + 4(int hash) = 20(padding) -&gt; 24 (bytes); 存储数据：16(char[] header) + 5*2 = 26(padding) -&gt; 32 (bytes) 总共：24 + 32 = 56 (bytes) 常用数据结构内存占用根据上面的内存占用计算规则，可以计算出一个对象在内存中的占用空间大小情况，下面举例分析下Java中的Enum, ArrayList及HashMap的内存占用情况，读者可以仿照分析计算过程来计算其他数据结构的内存占用情况。 注： 下面的分析计算基于HotSpot Jvm, JDK1.8, 64位机器，开启指针压缩。 枚举类创建enum时，编译器会生成一个相关的类，这个类继承自java.lang.Enum。Enum类拥有两个属性变量，分别为int的ordinal和String的name, 相关源码如下： public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; /** * The name of this enum constant, as declared in the enum declaration. * Most programmers should use the &#123;@link #toString&#125; method rather than * accessing this field. */ private final String name; /** * The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this field. It is designed * for use by sophisticated enum-based data structures, such as * &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. */ private final int ordinal; &#125; 以下面的TestEnum为例进行枚举类的内存占用分析 public enum TestEnum &#123; ONE(1, &quot;one&quot;), TWO(2, &quot;two&quot;); private int code; private String desc; TestEnum(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; public int getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; &#125; 这里TestEnum的每个实例除了父类的两个属性外，还拥有一个int的code及String的desc属性，所以一个TestEnum的实例本身所占用的内存大小为： 12(header) + 4(ordinal) + 4(name reference) + 4(code) + 4(desc reference) = 28(padding) -&gt; 32 bytes. 总共占用的内存大小为：按照上面对字符串类型的分析，desc和name都占用：48 bytes。所以TestEnum.ONE占用总内存大小为： 12(header) + 4(ordinal) + 4(code) + 48 * 2(desc, name) + 4(desc reference) + 4(name reference) = 128 (bytes) JProfiler中的结果可以验证上述分析： ArrayList在分析ArrayList的内存之前，有必须先了解下ArrayList的实现原理。ArrayList实现List接口，底层使用数组保存所有元素。其操作基本上是对数组的操作。下面分析下源代码： 1. 底层使用数组保存数据： /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access 2. 构造方法：ArrayList提供了三种方式的构造器，可以构造一个默认的空列表、构造一个指定初始容量的空列表及构造一个包含指定collection元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列。 /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 3. 存储：ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)等，这里着重介绍一下add(E e)方法。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; add方法将指定的元素添加到此列表的尾部。这里注意下ensureCapacityInternal方法，这个方法会检查添加后元素的个数是否会超过当前数组的长度，如果超出，数组将会进行扩容。 /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&#39;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 如果初始时没有指定ArrayList大小，在第一次调用add方法时，会初始化数组默认最小容量为10。看下grow方法的源码： /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 从上述代码可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组扩容的增长是原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，应该尽量避免数组容量的扩张。当可预知要保存的元素的数量时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。 ArrayList其他操作读取删除等原理这里不作介绍了。 4. 内存占用下面开始分析ArrayList的内存占用情况。ArrayList继承AbstractList类，AbstractList拥有一个int类型的modCount属性，ArrayList本身拥有一个int类型的size属性和一个数组属性。所以一个ArrayList实例本身的的大小为： 12(header) + 4(modCount) + 4(size) + 4(elementData reference) = 24 (bytes) 下面分析一个只有一个Integer(1)元素的ArrayList实例占用的内存大小。 ArrayList&lt;Integer&gt; testList = Lists.newArrayList(); testList.add(1); 根据上面对ArrayList原理的介绍，当调用add方法时，ArrayList会初始化一个默认大小为10的数组，而数组中保存的Integer(1)实例大小为16 bytes。则testList占用的内存大小为： 24(ArrayList itselft) + 16(elementData array header) + 10 * 4(elemetData reference) + 16(Integer) = 96 (bytes) JProfiler中的结果验证了上述分析： HashMap要分析HashMap的内存占用，同样需要先了解HashMap的实现原理。 1. HashMap的数据结构HashMap是一个“链表散列”的数据结构，即数组和链表的结合体。 从图上可以看出，HashMap底层是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，初始化一个数组，源码如下： /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; Node是链表中一个结点，一个Node对象保存了一对HashMap的Key,Value以及指向下一个节点的指针，源码如下： /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; &#125; 2. 构造方法HashMap提供了四种方式的构造器，分别为指定初始容量及负载因子构造器，指定初始容量构造器，不指定初始容量及负载因子构造器，以及根据已有Map生成新Map的构造器。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 如果不指定初始容量及负载因子，默认的初始容量为16， 负载因子为0.75。 负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。 HashMap有一个容量阈值属性threshold，是根据初始容量和负载因子计算得出threshold=capacity*loadfactor， 如果HashMap中数组元素的个数超过这个阈值，则HashMap会进行扩容。HashMap底层的数组长度总是2的n次方，每次扩容容量为原来的2倍。扩容的目的是为了减少hash冲突，提高查询效率。而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 3. 数据的存储 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //初始化数组的大小为16，容量阈值为16*0.75=12 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果key的hash值对应的数组位置没有元素，则新建Node放入此位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 关于HashMap数据的读取这里就不作介绍了。 4. HashMap内存占用这里分析一个只有一组键值对的HashMap, 结构如下： Map&lt;Integer, Integer&gt; testMap = Maps.newHashMap(); testMap.put(1, 2); 首先分析HashMap本身的大小。HashMap对象拥有的属性包括： /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; HashMap继承了AbstractMap&lt;K,V&gt;, AbstractMap有两个属性： transient Set&lt;K&gt; keySet; transient Collection&lt;V&gt; values; 所以一个HashMap对象本身的大小为： 12(header) + 4(table reference) + 4(entrySet reference) + 4(size) + 4(modCount) + 4(threshold) + 8(loadFactor) + 4(keySet reference) + 4(values reference) = 48(bytes) 接着分析testMap实例在总共占用的内存大小。根据上面对HashMap原理的介绍，可知每对键值对对应一个Node对象。根据上面的Node的数据结构，一个Node对象的大小为： 12(header) + 4(hash reference) + 4(key reference) + 4(value reference) + 4(next pointer reference) = 28 (padding) -&gt; 32(bytes) 加上Key和Value两个Integer对象，一个Node占用内存总大小为：32 + 2 * 16 = 64(bytes) JProfiler中结果： 下面分析HashMap的Node数组的大小。根据上面HashMap的原理可知，在不指定容量大小的情况下，HashMap初始容量为16，所以testMap的Node[]占用的内存大小为： 16(header) + 16 * 4(Node reference) + 64(Node) = 144(bytes) JProfile结果： 所以，testMap占用的内存总大小为： 48(map itself) + 144(Node[]) = 192(bytes) JProfile结果： 这里只用一个例子说明如何对HashMap进行占用内存大小的计算，根据HashMap初始化容量的大小，以及扩容的影响，HashMap占用内存大小要进行具体分析，不过思路都是一致的。 总结以上对计算Java对象占用内存的基本规则及方法进行了介绍，并通过分析枚举类，ArrayList, HashMap的内存占用情况介绍了分析复杂对象内存占用的基本方法，实际工作中需要精确计算Java对象内存占用情况的场景不多，不过保持一个良好的开发规范和约束是有必要的，而且对内存敏感的手机及用户来说，这是一个值得关注的问题，了解这方面内容还是必不可少的。","tags":[{"name":"内存","slug":"内存","permalink":"https://goghtsui.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"JVM","slug":"JVM","permalink":"https://goghtsui.github.io/tags/JVM/"}]},{"title":"Android知识点之enum","date":"2017-01-19T07:18:15.000Z","path":"2017/01/19/Android知识点之enum/undefined/","text":"序言问题 enum在Android应不应该使用？ 解决方案关于enum，Android Developers中这样一句话： enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android 就是说enum比静态常量两倍多的内存占用，应该尽量减少使用。当然了，这里说的是减少并不是禁止，要知道，enum的产生，注定其必定有适合的应用场景，而且它带来的代码简洁性和可读性，都是不可小觑的。 所以，如果在不使用enum的情况下是有替代方案的： 使用静态常量的形式替代 使用Typedef Annotations替代 第一种没什么说的，下面就重点说一说第二种，就是通过注解的形式来代替，注解是由 support 包提供的功能，如果使用，需要添加 support 包到module。 直接上代码吧： // 定义申请常量列表，声明NavigationMode形式的注解（三个注解是固定形式） @IntDef(&#123;NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS&#125;) @Retention(RetentionPolicy.SOURCE) public @interface NavigationMode &#123;&#125; // 声明静态常量 public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; 如果它被当作参数或者返回值时你可以这样写： // 使用注解装饰目标方法 @NavigationMode public abstract int getNavigationMode(); // 添加注解 public abstract void setNavigationMode(@NavigationMode int mode); 相信看到这些代码，就不需要什么说明了吧，就按照这样的形式使用就行。通过注解的方式去实现，你可以通过@IntDef和@StringDef来声明不同的数据类型。 结论如果你还不太确定你应不应该使用enum，你可以看看这篇文章： 在Android中到底该不该使用enum","tags":[{"name":"enum","slug":"enum","permalink":"https://goghtsui.github.io/tags/enum/"},{"name":"Annotations","slug":"Annotations","permalink":"https://goghtsui.github.io/tags/Annotations/"},{"name":"IntDef","slug":"IntDef","permalink":"https://goghtsui.github.io/tags/IntDef/"},{"name":"StringDef","slug":"StringDef","permalink":"https://goghtsui.github.io/tags/StringDef/"}]},{"title":"Android知识点之Tanlayout","date":"2017-01-19T01:56:58.000Z","path":"2017/01/19/Android知识点之Tablayout/undefined/","text":"序言开发过程中多多少少会遇到一些坑，也会留下一些坑，还有一些小的容易忽略的细节，或者从其他大牛那里了解到的知识点，发现了就整理下来，做个备注，如果恰好有人遇到了，拿走别客气。 Tablayout问题 为什么tablayout的英文（字母）标签名称默认全是大写？ 解决方案tablayout + viewpager + fragment的分页模式很常见了（这只是其中一种），这个不是重点，重点是tablayout的文字属性。 可能你使用tablayout的显示分类都是中文的， 比如：新闻、数码、设计、前端… 不知道你有没有使用过英文或者说字母的标签名称，你可以直接使用Android Studio 创建一个默认的分页的module，默认标题是英文的，所以你可以看到显示出来全部都是大写的，如果正好使用了这样的名称，那么恭喜你，你可以不用往下看了。但是由于我所使用的是首字母大写的形式，所以最后发现是一个属性的问题：textAllCaps 最终的解决方案是，你可以为tablayout自定义一个style，设置textAllCaps属性为false： &lt;style name=&quot;TabLayout.LowerCase&quot; parent=&quot;Widget.Design.TabLayout&quot;&gt; &lt;item name=&quot;tabTextAppearance&quot;&gt;@style/TabTextAppearance&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;TabTextAppearance&quot; parent=&quot;TextAppearance.Design.Tab&quot;&gt; &lt;item name=&quot;textAllCaps&quot;&gt;false&lt;/item&gt; &lt;/style&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; style=&quot;@style/TabLayout.LowerCase&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabMode=&quot;scrollable&quot;/&gt;","tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"https://goghtsui.github.io/tags/TabLayout/"},{"name":"enum","slug":"enum","permalink":"https://goghtsui.github.io/tags/enum/"}]},{"title":"Android之应用是否有启动页面(具有CATEGORY_LAUNCHER属性)","date":"2016-12-14T11:24:34.000Z","path":"2016/12/14/Android之应用是否有启动页面-具有CATEGORY-LAUNCHER属性/undefined/","text":"序言最近遇到一个问题，就是判断这个应用是否具有启动页面，即是不是插件或者服务类应用，不需要展示页面的应用。相信开发过Launcher应用的小伙伴肯定知道这个问题怎么解决。很简单，都是细节问题，稍加注意即可，大牛还请绕路。 实战篇获取所有安装的应用使用这个方法： public void getInstalledApps(Context context) &#123; PackageManager packageManager = context.getPackageManager(); List&lt;PackageInfo&gt; list = packageManager.getInstalledPackages(packageManager.GET_ACTIVITIES); for (PackageInfo p : list) &#123; AppInfoEntity infoEntity = new AppInfoEntity(); infoEntity.setAppName(packageManager.getApplicationLabel(p.applicationInfo).toString()); infoEntity.setAppIcon(p.applicationInfo.loadIcon(packageManager)); infoEntity.setAppPkgName(p.applicationInfo.packageName); infoEntity.setApkPath(p.applicationInfo.sourceDir); File file = new File(p.applicationInfo.sourceDir); infoEntity.setAppSize((int) file.length()); int flags = p.applicationInfo.flags; if ((flags &amp; ApplicationInfo.FLAG_SYSTEM) &gt; 0) &#123; // 系统应用 &#125; else &#123; // 安装应用 &#125; &#125; &#125; 没错你获取到是所有系统中存在的应用，包括系统和用户安装的，但是恶心的是，所有的插件类，或者系统的服务应用等都一起返回了，但是我们并不需要将这些应用展示给用户，因为他们不是用来与用户交互的，那我们需要自己过滤吗？答案肯定不是的，只是我们获取的方式不对，继续往下看，换个姿势试试： public List&lt;AppInfoEntity&gt; getInstalledApps(Context context) &#123; Intent mainIntent = new Intent(Intent.ACTION_MAIN, null); mainIntent.addCategory(Intent.CATEGORY_LAUNCHER); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; allApps = packageManager.queryIntentActivities(mainIntent, 0); for (int i = 0; i &lt; allApps.size(); i++) &#123; AppInfoEntity infoEntity = new AppInfoEntity(); ResolveInfo info = allApps.get(i); infoEntity.setAppIcon(info.activityInfo.loadIcon(packageManager)); infoEntity.setAppName(packageManager.getApplicationLabel(info.activityInfo.applicationInfo).toString()); ENTITYLIST.add(infoEntity); &#125; return ENTITYLIST; &#125; 很明显可以看出，这种方式是由针对性的，通过构建一个具有 Intent.CATEGORY_LAUNCHER 属性的intent，即有启动页面的应用，所以以这种方式筛选出来的应用就是我们可以展示给用户的应用了，包括系统的和用户安装的 总结小功能点，平时不太注意，没有什么多说的，其实多看看api就都明白了，没有做不到的，只有想不到的。","tags":[{"name":"CATEGORY_LAUNCHER","slug":"CATEGORY-LAUNCHER","permalink":"https://goghtsui.github.io/tags/CATEGORY-LAUNCHER/"}]},{"title":"Android判断某个应用是否安装","date":"2016-12-14T10:36:40.000Z","path":"2016/12/14/Android判断某个应用是否安装/undefined/","text":"序言在应用开过过程中有这样一个场景：判断某个应用是否已经安装了。你一定会说这个有什么难的，是的，这个问题很简单，不为别的，就为记个笔记，大牛勿喷 代码篇包名检查public static boolean isInstalled(Context context, String packageName) &#123; try &#123; PackageInfo packageInfo = context.getPackageManager().getPackageInfo(packageName.trim() , PackageManager.COMPONENT_ENABLED_STATE_DEFAULT); if (packageInfo != null) &#123; // 说明某个应用使用了该包名 return true; &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return false; &#125; ACTION检查 方案一 public static boolean isInstalledByAction(Context context, String action) &#123; final PackageManager packageManager = context.getPackageManager(); final Intent intent = new Intent(action); List&lt;ResolveInfo&gt; list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); if(list.size() &gt; 0)&#123; // 说明某个应用的activty使用了该action return true; &#125; return false; &#125; 方案二 public static boolean isInstallByAction(Context context, String action) &#123; PackageManager packageManager = context.getPackageManager(); Intent intent = new Intent(action); List&lt;ResolveInfo&gt; resolveInfo = packageManager .queryIntentActivities(intent, PackageManager.GET_INTENT_FILTERS);// AS这里报错，但是不影响编译 if (resolveInfo.size() == 0) &#123; // 说明没有任何应用使用该action return false; &#125; // 说明有某个的某个应用的activity使用了该action return true; &#125; 总结这三种方案，话说我使用的最多的就是包名，action的从来没注意过，但是开发过程中遇到了，还是记个笔记吧。 我们都知道action是配置在AndroidManifest.xml中组件的IntentFilter属性里的，所以这些方法最终校验的都是该属性。","tags":[{"name":"GET_INTENT_FILTERS","slug":"GET-INTENT-FILTERS","permalink":"https://goghtsui.github.io/tags/GET-INTENT-FILTERS/"},{"name":"MATCH_DEFAULT_ONLY","slug":"MATCH-DEFAULT-ONLY","permalink":"https://goghtsui.github.io/tags/MATCH-DEFAULT-ONLY/"}]},{"title":"ARGB_8888-ALPHA_8-ARGB_4444-RGB_565的区别","date":"2016-12-12T07:45:45.000Z","path":"2016/12/12/ARGB-8888-ALPHA-8-ARGB-4444-RGB-565的区别/undefined/","text":"序言作为Android开发程序猿，OOM的异常相比都遇到过吧，对内存及性能的优化，一直以来都是一个很头疼的问题。Bitmap就是其中的一大杀手，一般使用都是需要经过压缩或者取缩略图的，可能会影响其尺寸大小，然而除了尺寸大小，我们还应该关注一下其色彩相关的细节。 Bitmap.Config在Bitmap类中，有一个内部类Config，是枚举类型，在构造Bitmap的时候会最为参数使用到：createBitmap(int width, int height, Bitmap.Config config)，这里面有什么需要注意的地方呢？ 就是下面这几个枚举值： ALPHA_8 每个像素存储一个单一的透明度（alpha）通道 没有颜色信息存储（没有RGB通道） 每像素占用1字节（8位） GRB_565 每像素存储2个字节（16位），只有RGB通道 R-红色存储5位的精度 G-绿色存储6位的精度 B-蓝色存储5位的精度 此配置可以用在使用不透明的位图，不需要色彩保真度高的地方 ARGB_4444 每像素存储2个字节（16位） R、G、B颜色通道和透明(alpha)通道，每个通道占用4位 有alpha通道的图片可以使用该属性 已废弃，因为该属性下图片质量差 在SDK版本为KITKAT，使用这个属性创建bitmap默认会被ARGB_8888代替 ARGB_8888 每像素存储4个字节（32位） RGB和alpha通道存储8位的精度 这个属性很灵活，创建的高质量的bitmap，建议使用 总结最后，我们来计算一下bitmap的大小： bitmap大小 = 像素数 * 每个像素的内存大小 = bitmap的长 * bitmap的宽 * 每像素占用内存位数 计算一张480 * 800的bitmap的大小（以ARGB_8888为例）： 480 * 800 * 4（ARGB_8888每像素占用字节） = 1 536 000 byte =&gt; 1 536 000 / 1024 = 1500 kb（1.5M） 这样我们就可以精确计算bitmap的大小了，是不是说ARGB_8888占用内存比较大，就不去使用了呢？并不是这样的，分析如下： ALPHA_8 只有alpha通道，使用场景单一，不推荐 ARGB_4444 已经废弃，且创建的位图质量差，不推荐 ARGB_565 能够在保证图片质量的情况下减少内存开销，唯一缺点就是没有alpha通道 ARGB_8888 能够创建高质量的图片，但是内存开销比较大 所以，并没有哪个属性更好，只有更合适，依据场景和需求使用不同的属性","tags":[{"name":"ARGB","slug":"ARGB","permalink":"https://goghtsui.github.io/tags/ARGB/"},{"name":"Bitmap.Config","slug":"Bitmap-Config","permalink":"https://goghtsui.github.io/tags/Bitmap-Config/"}]},{"title":"Retrofit 1 之 log得请求与响应","date":"2016-12-08T09:38:25.000Z","path":"2016/12/08/Retrofit-1-之-log得请求与响应/undefined/","text":"序言在Retrofit使用中，或者说在项目开发过程中，调试是必须的一中技能和方式，其中就包括日志的形式，那么在Retrofit的使用中，应该以怎样的姿态使用日志功能呢？接下来就让我们一起去看看吧。 Retrofit 1默认情况下Retrofit 1是没有启用日志功能的，但是日志功能的开启和使用非常容易，请看代码： RestAdapter.Builder builder = new RestAdapter.Builder() .setEndpoint(API_LOCATION) .setLogLevel(RestAdapter.LogLevel.FULL) // this is the important line .setClient(new OkClient(new OkHttpClient())); 如您所见，日志包括整个请求和响应正文。虽然这可能是有用的和必要的，但信息可能太多，反而影响了日志的可读性及应用的性能。 日志等级 NONE 没有任何日志，而且会提升你的应用性能。 BASIC 仅记录请求方法和URL以及响应状态代码和执行时间。 HEADERS 记录基本信息以及请求和响应头 HEADERS_AND_ARGS 记录基本信息以及请求和响应对象的toString()信息。 FULL 记录请求和响应的头，主体和元数据。 Retrofit 2请看另外一篇博客：Retrofit 2 之 log得请求与响应 总结在没有必要的情况下，还是不要开启日志功能，因为这本身是一个消耗性能的事情，当然，合理的使用日志功能，是完善应用的一个很好的途径。","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://goghtsui.github.io/tags/Retrofit/"}]},{"title":"Retrofit 2 之 log得请求与响应","date":"2016-12-08T09:09:37.000Z","path":"2016/12/08/Retrofit-2-之-log得请求与响应/undefined/","text":"序言Retrofit 1集成了用于基本请求和响应调试的日志功能，但是在Retrofit 2中被移除了，因为所需的HTTP层现在完全基于OkHttp。由于许多开发人员要求在Retrofit 2中提供日志记录功能，OkHttp的开发人员在2.6.0版本中添加了一个日志拦截器，接下来，你将看到怎样添加和使用日志拦截器。 Retrofit 1请看另外一篇博客：Retrofit 1 之 log得请求与响应 Retrofit 2Retrofit 2完全依赖于OkHttp进行任何网络操作。OkHttp的开发者已经发布了一个日志拦截器集成的版本，你可以通过以下方式添加依赖： compile &#39;com.squareup.okhttp3:logging-interceptor:3.3.1&#39; 在OkHttp中，默认是没有拦截日志的，我们需要添加日志拦截器给OkHttp，并且已经提供了日志拦截器，我们只需要激活它给OkHttpClient： HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); // set your desired log level logging.setLevel(Level.BODY); OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); // add your other interceptors … // add logging as last interceptor httpClient.addInterceptor(logging); // &lt;-- this is the important line! Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient.build()) .build(); 日志等级日志太多会影响Android显示，OkHttp日志拦截器提供了四个等级的日志：NONE 、BASIC 、 HEADERS 、BODY 。它们分别包含哪些信息？接下来让我们一起去看看： None 没有任何日志，而且会提升你的应用性能。 Basic 日志请求类型、url、请求正文的大小、响应状态和响应正文的大小。 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 (277-byte body) D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (543ms, -1-byte body) Headers 日志请求和响应头、请求类型、url、响应状态。 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 D/HttpLoggingInterceptor$Logger: Accept: application/json D/HttpLoggingInterceptor$Logger: Content-Type: application/json D/HttpLoggingInterceptor$Logger: --&gt; END POST D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1039ms) D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8 D/HttpLoggingInterceptor$Logger: cache-control: no-cache D/HttpLoggingInterceptor$Logger: vary: accept-encoding D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:24:20 GMT D/HttpLoggingInterceptor$Logger: Connection: keep-alive D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1 D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446020610352 D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446020610369 D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP Body 日志请求和响应标头和正文。 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795 D/HttpLoggingInterceptor$Logger: Content-Disposition: form-data; name=&quot;description&quot; D/HttpLoggingInterceptor$Logger: Content-Transfer-Encoding: binary D/HttpLoggingInterceptor$Logger: Content-Type: application/json; charset=UTF-8 D/HttpLoggingInterceptor$Logger: Content-Length: 37 D/HttpLoggingInterceptor$Logger: D/HttpLoggingInterceptor$Logger: &quot;hello, this is description speaking&quot; D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795-- D/HttpLoggingInterceptor$Logger: --&gt; END POST (277-byte body) D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1099ms) D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8 D/HttpLoggingInterceptor$Logger: cache-control: no-cache D/HttpLoggingInterceptor$Logger: vary: accept-encoding D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:33:40 GMT D/HttpLoggingInterceptor$Logger: Connection: keep-alive D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1 D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446021170095 D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446021170107 D/HttpLoggingInterceptor$Logger: Perfect! D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP (8-byte body) 总结请根据相应的log等级正确的使用日志管理，这样可以避免不必要的性能消耗。","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://goghtsui.github.io/tags/Retrofit/"}]},{"title":"Retrofit 1.x和Retrofit 2.x的不同","date":"2016-12-07T03:11:28.000Z","path":"2016/12/07/Retrofit-1-x和Retrofit-2-x的不同/undefined/","text":"序言Retrofit库已经发布很久了，已经是主流的Http client库之一，使用简单、高效，但是随着版本的升级，也出现了一些疑难杂症，下面就详细给大家讲解一下，给大家填填坑： 官方描述：Type-safe HTTP client for Android and Java by Square.官网地址：Square-Retrofit.Github地址：Github-Retrofit. 到现在已经经历了1.x到2.x的过程，这自然是一个越来越完善、越强大的趋势，但是Square还是坑了我们一把。在1.x到2.x的迭代过程中，并不是平滑升级的，而是发生了很大的转变，为了防止更多的人遇到这些坑，我就把我了解的一些不同给大家说一所，当然，哪里描述有问题，表述不正确的随时回复。 Retrofit 1.x -&gt; Retrofit 2.xRetrifit 1系列最高是1.9.0，Retrofit 2 系列目前最高 2.1.0。 Maven &amp; Gradle 依赖 在Retrofit 1中，你需要导入底层的HTTP客户端。默认情况下，Retrofit 2将OkHttp最为默认的底层库，它已经作为Retrofit 2本身的依赖。 compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39; 假如你想要使用指定版本的OkHttp，那么你可以这样写： compile (&#39;com.squareup.retrofit2:retrofit:2.1.0&#39;) &#123; // 移除 Retrofit 的 OkHttp exclude module: &#39;okhttp&#39; &#125; // 添加自定义的依赖库 compile &#39;com.squareup.okhttp3:okhttp:3.3.1&#39; Maven: Retrofit &amp; OkHttp &lt;dependency&gt; &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt; &lt;artifactId&gt;retrofit&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; Retrofit 2默认不集成Gson和RxJava的。之前，你不需要担心任何集成转换器，现在你需要导入转换器，当然RxJava也需要手动导入，下文还会详细描述： Converter compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39; RxJava compile &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39; RestAdapter —&gt; Retrofit Retrofit 1.9 RestAdapter.Builder builder = new RestAdapter.Builder(); Retrofit 2.x Retrofit.Builder builder = new Retrofit.Builder(); setEndpoint —&gt; baseUrl Retrofit 1.9 RestAdapter adapter = new RestAdapter.Builder() .setEndpoint(API_BASE_URL); .build(); YourService service = adapter.create(YourService.class); 注: 在你调用Retrofit.Builder的build()方法之前, 你至少需要定义API_BASE_URL. Retrofit 2.x Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL); .build(); YourService service = retrofit.create(YourService.class); Base Url处理 Retrofit 1.x public interface UserService &#123; @POST(&quot;me&quot;) User me(); &#125; RestAdapter adapter = RestAdapter.Builder() .setEndpoint(&quot;https://your.api.url/v2/&quot;); .build(); UserService service = adapter.create(UserService.class); // the request url for service.me() is: // https://your.api.url/v2/me Retrofit 2.x Retrofit 2.x 使用了全新的url处理方式，内部是通过HttpUrl.resolve()**方式创建的URL，类似于**的链接，这一点非常重要。我学习的时候看到有三种展示方式： url：https://your.api.url/me public interface UserService &#123; @POST(&quot;/me&quot;) Call&lt;User&gt; me(); &#125; Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://your.api.url/v2&quot;); .build(); UserService service = retrofit.create(UserService.class); // the request url for service.me() is: // https://your.api.url/me url：https://your.api.url/me public interface UserService &#123; @POST(&quot;me&quot;) Call&lt;User&gt; me(); &#125; Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://your.api.url/v2&quot;); .build(); UserService service = retrofit.create(UserService.class); // the request url for service.me() is: // https://your.api.url/me url：https://your.api.url/v2/me public interface UserService &#123; @POST(&quot;me&quot;) Call&lt;User&gt;me(); &#125; Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://your.api.url/v2/&quot;); .build(); UserService service = retrofit.create(UserService.class); // the request url for service.me() is: // https://your.api.url/v2/me 经过我的测试（Retrofit 2.1.0），baseUrl必须是以 / 结尾（即@GET不以**/**开头），不然会报错：java.lang.IllegalArgumentException: baseUrl must end in /: https://your.api.url/v2/me ，所以，在2.1.0的版本，我们要注意这一点，如果这里有问题，还请留言反馈。 动态URL 在你的url无法立即获取或者使用的时候，你可以配置动态的url来使用，在Retrofit 2.x你可以将HTTP请求注解留空，然后将**@url**作为方法参数的注解，请看以下示例代码： public interface UserService &#123; @GET public Call&lt;File&gt; getZipFile(@Url String url); &#125; OkHttp集成OkHttp 在Retrofit 1.x里是可选的。如果你想让Retrofit使用OkHttp作为HTTP连接接口，你需要手动包含OkHttp依赖。但是在Retrofit 2.x中，OkHttp 是必须的，并且自动设置为了依赖。下面的代码来自Retrofit 2.0的pom文件： &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; OkHttp 使用Call 来封装响应，如果你想使用OkHttp特定的版本，不想使用内部的版本，你可以按照以下代码手动配置： compile (&#39;com.squareup.retrofit2:retrofit:2.1.0&#39;) &#123; // exclude Retrofit’s OkHttp peer-dependency module and define your own module import exclude module: &#39;okhttp&#39; &#125; compile &#39;com.squareup.okhttp3:okhttp:3.3.1&#39; OkHttp拦截器在Retrofit 1.x中，你可以使用RequestInterceptor来拦截一个请求，但是它已经从Retrofit 2.x 移除了，因为HTTP连接层已经转为OkHttp。结果就是，现在我们必须转而实用OkHttp里面的Interceptor。首先你需要实用Interceptor创建一个OkHttpClient对象，然后使用如下Retrofit.Builder()的client()方法设置你自定义的增强版OkHttp： OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); httpClient.addInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request original = chain.request(); // Customize the request Request request = original.newBuilder() .header(&quot;Accept&quot;, &quot;application/json&quot;) .header(&quot;Authorization&quot;, &quot;auth-token&quot;) .method(original.method(), original.body()) .build(); Response response = chain.proceed(request); // Customize or return the response return response; &#125; &#125;); OkHttpClient client = httpClient.build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://your.api.url/v2/&quot;); .client(client) .build(); 同步&amp;异步 请求在Retrofit 1.x中，通过在service接口中不同的方法声明来区分，同步方法需要一个返回类型，异步的方法需要一个统一的Callback作为最后一个参数。 接口声明 Retrofit 1.x public interface UserService &#123; // Synchronous Request @POST(&quot;/login&quot;) User login(); // Asynchronous Request @POST(&quot;/login&quot;) void getUser(@Query String id, Callback&lt;User&gt; cb); &#125; Retrofit 2.x 在Retrofit 2.x中，service中方法的声明没有区别，返回类型都被统一封装到一个Call类型里面： public interface UserService &#123; @POST(&quot;/login&quot;) Call&lt;User&gt; login(); &#125; 请求执行 Retrofit 1.x // synchronous User user = userService.login(); // asynchronous userService.login(new Callback&lt;User&gt;() &#123; @Override public void success(User user, Response response) &#123; // handle response &#125; @Override public void failure(RetrofitError error) &#123; // handle error &#125; &#125;); Retrofit 2.x 对于Retrofit 2.x，返回类型都被统一封装到了Call类型里，所以使用了完全不同的执行方式： // 同步 Call&lt;User&gt; call = userService.login(); User user = call.execute().body(); // 异步 Call&lt;User&gt; call = userService.login(); call.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; // response.isSuccessful() is true if the response code is 2xx if (response.isSuccessful()) &#123; User user = response.body(); &#125; else &#123; int statusCode = response.code(); // handle request errors yourself ResponseBody errorBody = response.errorBody(); &#125; &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; // handle execution failures like no internet connectivity &#125; &#125; 注：在Retrofit 2.x中，即使请求不成功onResponse()**方法也会被执行，但是Response类提供了isSuccessful()方法用于检查请求结果（返回的状态码2xx），如果状态代码不是2xx，您需要自己处理错误。如果在失败的情况下，你希望自己解析错误响应信息，你可以通过使用ResponseBody类的errorBody()**方法自己解析对象。 取消请求使用Retrofit 1.x，即使请求尚未执行，也无法取消。在Retrofit 2.x这一点已经得到了改善，即如果HTTP调度器没有执行该它，你最终可以取消任何请求。 Call&lt;User&gt; call = userService.login(); User user = call.execute().body(); // changed your mind, cancel the request call.cancel(); 你不需要关心是同步还是异步请求，只要你足够的及时，OkHttp不会发送出任何的请求。 转换器Retrofit 1.x对Gson集成并作为默认的JSON转换器，但是Retrofit 2.x没有集成任何转换器，需要你自定义转换器，如果你想使用Gson作为转换器，你可以按照以下方式使用兄弟库： 添加依赖compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39; 还有其它很多可用的转换器，根据自己的喜欢手动添加即可： Gson: com.squareup.retrofit2:converter-gson:2.1.0 Moshi: com.squareup.retrofit2:converter-moshi:2.1.0 Jackson: com.squareup.retrofit2:converter-jackson:2.1.0 SimpleXML: com.squareup.retrofit2:converter-simplexml:2.1.0 ProtoBuf: com.squareup.retrofit2:converter-protobuf:2.1.0 Wire: com.squareup.retrofit2:converter-wire:2.1.0 假如，没有你想使用的依赖库，你可以继承Converter.Factory抽象类，可以去这里参考编写：转换器实现示例 添加转换器 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://your.api.url/v2/&quot;); .addConverterFactory(ProtoConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); 上面代码中添加了两个转换器，你是不是要会选择哪个使用？这一点很重要：添加的顺序决定了使用的顺序，默认使用第一个转换器，如果第一个转换器不可用，会使用第二个转化器。所以，你可以多添加几个转换器，这是允许的，但是一定要注意顺序。 RxJava集成Retrofit 1 已经集成了三个请求执行机制：同步，异步和RxJava。Retrofit 2 仅仅同步和异步默认是可用的，因此，Retrofit开发团队创建了一种将额外的执行机制插入Retrofit的方法。你可以为你的应用程序添加多个机制，如RxJava或Futures。为了使Retrofit恢复RxJava的支持，需要添加两个依赖： 第一个依赖是 RxJava的 CallAdapter，这是为了告诉Reftrofit有新的方式来处理请求。这就意味着你可以通过定义CustomizedCall 来替换Call ，在 RxJava 的情况下，我们需要将返回值Call 修改为 Observable。 第二个依赖是需要AndroidSchedulers类，这是需要在Android的主线程上订阅代码。 compile &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39; 接下来需要的是在创建service实例之前将新的 CallAdapter 添加到 Retrofit 对象。 Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl); .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); 首先，我们声明一个service接口。之后，我们假设有一个userService实例被创建，并且可以直接利用Observable来观察Android的主线程。我们还将一个新的Subscriber传递给subscribe方法，它将最终返回成功的响应或错误。 public interface UserService &#123; @POST(&quot;/me&quot;) Observable&lt;User&gt; me(); &#125; // this code is part of your activity/fragment Observable&lt;User&gt; observable = userService.me(); observable .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .subscribe(new Subscriber&lt;User&gt;() &#123; @Override public void onCompleted() &#123; // handle completed &#125; @Override public void onError(Throwable e) &#123; // handle error &#125; @Override public void onNext(User user) &#123; // handle response &#125; &#125;); 默认没有日志记录这个内容相对独立，就单独拿出来说吧，请查看另外两篇文章： Retrofit 1 日志使用 Retrofit-1-之-log得请求与响应 Retrofit 2 日志使用 Retrofit-2-之-log得请求与响应 总结这些内容摘自官方和日常使用总结，基本上覆盖了日常开发使用，所以你还需要在使用中不断的探索。Retrofit真的是非常的简单、高效，给你填了很多坑，节省了你的开发时间，虽然你需要花些时间去了解它，但是一旦你可以熟练的使用它，那么他带给你的惊喜是你无法想象的，所以，你又有什么理由不去使用它呢？ 其实你可以通过官方的Changelog来详细了解以下： Changelog","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://goghtsui.github.io/tags/Retrofit/"}]},{"title":"Android开发之[暗码]","date":"2016-10-27T03:18:53.000Z","path":"2016/10/27/Android开发之[暗码]/undefined/","text":"序言什么是暗码？不同厂商的手机都会隐藏代码，用来查看系统及固件版本，或者进行硬件的测试，当然Android手机也不例外，除了好像计算机一样能显示更详细的手机信息外，更可重设为原厂设定，更新相机等。但部份代码要谨慎使用，因为可能令手机失去原有的功能，确认在了解其功能的前提下再去尝试，具体的有哪些暗码大家自行搜索吧。 暗码怎么使用呢？在手机拨号页面，输入:** *#*#munber#*#* *,number对应的就是暗码了。我这里就说一个我经常用到的暗码，以MOTO Z play为例：__\\#*#4636#*#*__，显示手机信息、使用情况统计数据、WiFi information、CMAS测试提示、用户首选网络列表、IMS Setting，其中短信中心的号码设置就在这里设置的。那么这个暗码的功能，最为开发者的我们能不能使用呢？答案是绝对可以的，话说你可以给自己的应用留一些后门或者debug开关，亦或者打开特定的页面，功能还是很屌的，下面进入正题吧 功能描述首先，这个暗码的捕获及解析是系统来完成的，系统在解析完成暗码之后会发送一个广播出来,系统源码： \\android\\packages\\apps\\Dialer\\src\\com\\android\\dialer\\SpecialCharSequenceMgr.java /** * Handles secret codes to launch arbitrary activities in the form of *#*#&lt;code&gt;#*#*. * If a secret code is encountered an Intent is started with the android_secret_code://&lt;code&gt; * URI. * * @param context the context to use * @param input the text to check for a secret code in * @return true if a secret code was encountered */ static boolean handleSecretCode(Context context, String input) &#123; // Secret codes are in the form *#*#&lt;code&gt;#*#* int len = input.length(); if (len &gt; 8 &amp;&amp; input.startsWith(&quot;*#*#&quot;) &amp;&amp; input.endsWith(&quot;#*#*&quot;)) &#123; final Intent intent = new Intent(SECRET_CODE_ACTION, Uri.parse(&quot;android_secret_code://&quot; + input.substring(4, len - 4))); context.sendBroadcast(intent); return true; &#125; return false; &#125; 也可以看出来 SECRET_CODE_ACTION 也是从这里发出来的，所以我们需要做的就是创建一个receiver来接受该广播。这样，我们就可以通过intent拿到这个暗码，与我们设定的暗码匹配比较，继而完成相关的业务逻辑。 使用暗码 自定义的receiver： public class SecretReceiver extends BroadcastReceiver &#123; private static final String ACTION = &quot;android.provider.Telephony.SECRET_CODE&quot;; private static final String SECRET_CODE = &quot;2016&quot;; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(ACTION))&#123; if(intent.getData().getHost().equals(SECRET_CODE))&#123; Intent target = new Intent(context, MainActivity.class); target.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(target); &#125; &#125; &#125; &#125; 非常简单的一段代码，就是接收到暗码的广播，启动一个页面 在AndroidManifest.xml中注册该receiver，并设置识别的暗码： &lt;receiver android:name=&quot;.SecretReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SECRET_CODE&quot; /&gt; &lt;data android:scheme=&quot;android_secret_code&quot; android:host=&quot;2016&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 只需要这两步，一个简单的暗码启动页面就完成了，亲测可行。 执行暗码上面的方法我们已经可以识别自定义的暗码了，那么如何执行暗码呢？其实还是交给系统去执行的，和拨打电话是一个原理： Uri uri = Uri.parse(&quot;android_secret_code://&quot; + code); Intent intent = new Intent(ACTION, uri); context.sendBroadcast(intent); 总结可能会有童鞋问道：那我定义一个和系统一样的暗码，会怎么样？告诉你，就是：没你什么事。 系统暗码系统捕获并处理，不会告诉你的，你想多了，不然系统给你搞坏了咋办，哈。。其实这个功能研发本身很简单，但是如果利用好这个功能，还是可以做出一些很特别的东西的，大不了可以装逼用啊。 ToT","tags":[{"name":"SECRET_CODE","slug":"SECRET-CODE","permalink":"https://goghtsui.github.io/tags/SECRET-CODE/"},{"name":"SECRET_CODE_ACTION","slug":"SECRET-CODE-ACTION","permalink":"https://goghtsui.github.io/tags/SECRET-CODE-ACTION/"}]},{"title":"Android Studio: Error running app: Instant Run requires 'Tools | Android | Enable ADB integration' to be enabled","date":"2016-10-19T07:17:38.000Z","path":"2016/10/19/Android-Studio-Error-running-app-Instant-Run-requires-Tools-Android-Enable-ADB-integration-to-be-enabled/undefined/","text":"在Android Studio使用过程中遇到一些异常情况，记下来做个笔记。 错误信息Error running app: Instant Run requires ‘Tools | Android | Enable ADB integration’ to be enabled. 解决方案","tags":[{"name":"Instant Run","slug":"Instant-Run","permalink":"https://goghtsui.github.io/tags/Instant-Run/"},{"name":"Enable ADB integration","slug":"Enable-ADB-integration","permalink":"https://goghtsui.github.io/tags/Enable-ADB-integration/"}]},{"title":"Android Studio 2.2 新特性","date":"2016-10-11T09:54:42.000Z","path":"2016/10/11/Android-Studio-2-2-新特性/undefined/","text":"序言今年的 I/O 2016 Google 放出了 Android Studio 2.2 的预览版，透露改进了多项功能，现在已经发布了 Android Studio 2.2 的正式版，按照 Google 的说法，此版本包含增强功能，主要面向三大主题：速度、智能和 Android 平台支持。通过新增的布局编辑器等功能加快开发速度，快速而直观地创建应用用户界面。利用新增的 APK 分析器、增强的布局检查器、扩展的代码分析、IntelliJ 的 2016.1.3 功能等，进行更智能的开发。 作为正式版 Android 应用开发 IDE，Android Studio 2.2 支持 Android 7.0 Nougat 中所有最新的开发者功能（例如代码自动完成），可帮助您添加多种 Android 平台功能，例如多窗口支持、Quick Settings API 或重新设计的通知，当然还有用于测试这些功能的内置 Android Emulator。 在此版本中，我们将 Android Frameworks 与 IDE 整合到一起创建约束布局。这个全新的布局管理器功能强大，可帮助您以扁平的流线型层次结构设计庞大而复杂的布局。ConstraintLayout 是与新的布局编辑器同时构建的，可像标准 Android 支持库那样集成到您的应用中。 Android Studio 2.2 新增了 20 多项功能，涉及开发流程的每个主要阶段：设计、开发、构建和测试。从使用新的 ConstraintLayout 设计 UI，到使用 Android NDK 开发 C++ 代码，到使用最新的 Jack 编译器进行构建，再到为应用创建 Espresso 测试案例，Android Studio 2.2 都是您不容错过的最新版本。 新特性设计Layout Editor(布局编辑器)本次更新带来了全新的布局编辑器，我们以后调 UI 将更方便。打开一个 XML 文件，默认的 Design 模式如下图所示，主要包含 Palette、Component Tree、Toolbar、Design Editor、Properties 五部分，直接可视化的操作使布局更加方便易操作。 当然对于习惯写 XML 代码的同学来说可以点击左下角的 Text 切换到代码格式，但是右边依然可以实时预览。Text 模式下的截图如下： 这里有个小技巧，可以操作快捷键 Control+Shift+Right/Left 来进行左右切换。然后我们可以通过 Toolbar 那一栏来配置我们预览的主题外观 Constraint Layout(约束布局)Constraint Layout 翻译过来我把它叫约束布局，它也是今年 Google 全新推出的一种布局，它更强大，简单来说，用 Constraint Layout 可以实现之前需要各种嵌套才能实现的效果，我们知道过多的布局嵌套对性能影响是很大的，因为 Constraint Layout 更强大，所以属性也就特别多，不过 Google 完全提供了一种可视化的操作，一张动图你们感受下： 关于 Constraint Layout 的详细用法 Google 官方有个教程，想学习的可以看一下： Using ConstraintLayout to design your views 上面链接需要科学上网，英文阅读有困难的不妨看下这篇博客： Android ConstraintLayout详解 开发Samples BrowserGitHub 上 Google 有个叫 Google Samples 的组织，罗列了 Google 的上百个关于一些代码的示例，而这其中大部分都是 Android 相关的，比如 NavigationDrawer 不会用了，google 有个 android-NavigationDrawer 的示例。而这次 Google 直接把他关联到 Android Stduio 了，你可以在 Android Studio 选中一个类直接右键点击 Find Sample Code ，神奇的事情发生了： 上图可以看到以选中 PackageManager 为例，下面直接出现了一些 Google Sample 相关的代码，方便你快速查找该用法，而且还有个链接直接指向到 Android Developer 官网该类的详细介绍 Improved C++ Support（改进的 C++ 支持）现在可以使用 CMake 或 ndk-build 从 Gradle 编译 C++ 项目。现在可将项目从 CMake 构建系统无缝迁移到 Android Studio。Android Studio 中的新项目向导对 C++ 提供了支持，此外，还对 C++ 编辑和调试体验进行了大量的问题修复。 构建Instant Run Improvements(Instant Run改进)Instant Run 的推出确实很不错，但是第一次编译会比较慢。我们先来看下 Google 官方的更新说明： 在此版本中，我们对 Instant Run 的稳定性和可靠性进行了大量的改进。如果您之前禁用了 Instant Run，建议重新启用，如果今后仍遇到问题，请告诉我们。（Settings → Build, Execution, Deployment → Instant Run [适用于 Windows/Linux], Preferences → Build, Execution, Deployment → Instant Run [适用于 OS X]）。打开方法见下图： Build cache (Experimental)(缓存构建)升级2.2之后会提示升级gradle 为了加快 Gradle 的编译速度，Google 新增了一个编译缓存的功能，不过目前还是实验性的，具体用法就是在你的 gradle.properties 文件里加上这么一行代码： android.enableBuildCache=true 总体来说升级了 Gradle，加上这么一句代码，确实感觉编译快了些，大家可以自行感受下。每次编译生成的缓存在 ~/users/.android/build-cache 目录下，如果缓存过多可以手动删除该目录进行清除。 APK Analyzer（apk解析器）Google 推出了一个 APK 分析器，现在可以很方便的使用 Android Studio 进行 APK 分析。具体用法点击 Build -&gt; Analyze APK 然后选择你要分析的 APK 文件就可以了。 可以方便的查看全部文件和大小 可以直接查看 AndroidManifest.xml 文件 可以直接查看资源文件 可以直接查看 dex 文件 两个 apk 进行比较 以后人人都会逆向 APK 了。 测试Virtual Sensors in the Android Emulator（虚拟传感器）Google 这次同样改进了模拟器，这次让模拟器支持虚拟传感器，你们感受下。 Espresso Test Recorder (Beta)（测试记录器（测试版））Google 为测试新增了一个功能，就是我们可以对操作进行录像，然后根据我们的操作生成一些测试脚本，而且配合 Firebase 将更方便。 理论上来说此功能很不错，可以解放了测试人员的双手，只不过该功能还是测试，应该很不稳定，而且国内行情结合 Firebase 很困难，对开发意义不大，可以持续关注。 GPU Debugger (Beta)（GPU 调试程序（测试版））GPU 调试程序现在为测试版。现在，您可捕获 Android 设备上的 OpenGL ES 命令流，然后在 Android Studio 内重播该命令流以便对其进行分析。也可全面检查任何指定 OpenGL ES 命令的 GPU 状态，以更好地了解和调试您的图形输出。 总结除以上之外，此次更新还包括对 Java 8 的支持，Jack 编译器的改进，可以调试 GPU，改进了对 C++ 的支持等，总体来说此次更新推出了不少提升 Android 开发效率的工具，性能上也做了优化，值得大家更新！ 官方更新说明 官方各版本描述","tags":[{"name":"Android Studio2.2","slug":"Android-Studio2-2","permalink":"https://goghtsui.github.io/tags/Android-Studio2-2/"}]},{"title":"Android Studio升級2.2打包报错 - ...xxx-stripped.ap_ specified for property resourceFile does not exist","date":"2016-10-10T09:54:23.000Z","path":"2016/10/10/Android-Studio升級2-2打包报错-xxx-stripped-ap-specified-for-property-resourceFile-does-not-exist/undefined/","text":"序言在升级了Android Studio 2.2 之后，使用Build -&gt; Generate Signed Apk 打包apk报错，之前是一只没问题的，肯定是2.2的一些特性搞的鬼，google了一下，原来是 Instant Run 的问题。 问题错误日志： \\build\\intermediates\\res\\xxx-stripped.ap_&#39; specified for property &#39;resourceFile&#39; does not exist 解决方案Files -&gt; Settings -&gt; Build, Execution, Development -&gt; Instant Run – 把第一个勾选去掉 总结首先说，我在module中使用了资源优化： buildTypes &#123; release &#123; shrinkResources false minifyEnabled false proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; 如果将 shrinkResources 设置成 true 就需要通过上面提到的设置，如果设置为false就不需要关闭 instant run 的功能了，因为 instant run 不支持 shrinkResources。 stackoverflow的解决方案 官方描述：关于 Instant Run","tags":[{"name":"Android Studio2.2","slug":"Android-Studio2-2","permalink":"https://goghtsui.github.io/tags/Android-Studio2-2/"},{"name":"xxx-stripped.ap_","slug":"xxx-stripped-ap","permalink":"https://goghtsui.github.io/tags/xxx-stripped-ap/"}]},{"title":"Android Studio | Intellij 翻译插件 Easy Translation","date":"2016-08-16T14:08:34.000Z","path":"2016/08/16/Android-Studio-Intellij-翻译插件-Easy Translation/undefined/","text":"序言相信现在做Android开发的都已经从Eclipes转Android Studio（AS）了吧，我们都知道，它是Google推出的，基于IntelliJ IDEA的开发工具，提供了集成的 Android 开发工具用于开发和调试。 基于Gradle的构建支持 Android 专属的重构和快速修复 提示工具以捕获性能、可用性、版本兼容性等问题 支持ProGuard 和应用签名 基于模板的向导来生成常用的 Android 应用设计和组件 功能强大的布局编辑器，可以让你拖拉 UI 控件并进行效果预览 安装为了学技术不得不一点一点的肯那些英文文档，在AS中我们官方注释也是英文的，单词还要复制出来找google翻译，是不是很麻烦，为了方便大家，我写了一个简单的翻译插件，没错，遇到不懂得单词，马上就能翻译出来，和有道词典的效果差不多，其实是可以中英互译的，该插件支持基于IntelliJ IDEA的开发环境，下面就说说在AS/IntelliJ下怎么使用： 直接在编译器下载安装：File -&gt; Settings -&gt; Plugins -&gt; Browse Repositories -&gt; 搜索Easy-Translation -&gt; 点击右侧的Install -&gt; 重启 即可。 AS可以从官方下载手动安装，插件是以jar的形式提供的，打开AS：File -&gt; Settings -&gt; Plugins -&gt; Install plugin from disk -&gt; 选择jar包 -&gt; 重启即可。 插件下载地址1 插件下载地址2 使用 在编辑页面，双击以选中你想要翻译的词语或语句 _第一种形式_：使用快捷键Alt + A，会通过弹窗的形式将翻译结果展示出来，支持鼠标操作 _第二种形式_：使用快捷键Alt + S，通过ToolWindow的形式显示翻译结果，默认是弹窗，可以选择贴边（这样比较方便查看） 通过快捷键Shift + F10可以选择在网页查看翻译结果（只提供Google和有道翻译） 注意 如果出现乱码，可以修改一下字体：File -&gt; Settings -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; UI Options -&gt; Name(eg. Microsoft YaHei) 如果翻译出错，稍后重试即可；因为查询会有限制，当然你可以通过：File -&gt; Settings -&gt;Other Settings -&gt; Easy-Translation设置自己的有道API 总结虽然只是一个小功能，但是还是挺实用的，使用了有道翻译API，如果觉得好用的就打个赏吧，谢谢","tags":[{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"https://goghtsui.github.io/tags/Intellij-IDEA/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"plugin","slug":"plugin","permalink":"https://goghtsui.github.io/tags/plugin/"}]},{"title":"关于OpenJDK你了解多少？","date":"2016-08-10T13:55:30.000Z","path":"2016/08/10/关于OpenJDK你了解多少？/undefined/","text":"序言2015年12月底，谷歌宣布，他们正在用开源的 OpenJDK 替换 Oracle JavaAPI。这次方向上的改变看起来与 Sun/Oracle 与 谷歌之间的法律纠纷有关，该纠纷认为谷歌在使用 Java 开发安卓操作系统时违反了 Sun/Oracle 的版权和专利权。 本文与 Sun/Oracle 和谷歌的法律纠纷无关。谷歌现在加入了 IBM、RedHat、Apple（还有其他企业）的队伍专注于 OpenJDK，这意味着什么？意识到这点之后我想弄清楚，对于 JDK 用户，现在是不是应该考虑一下 OpenJDK 历史从Java7开始，OpenJDK就是Java的参考实现（Reference Implementation）。下图的时间线可以让你了解一下OpenJDK的历史: OpenJDK由许多软件库组成，主要有corba,hotspot,jaxp,jaxws,jdk,langtools,以及nashorn。在OpenJDK8和OpenJDK9之间没有新的软件库加入，但有很多改变和结构调整，主要是因为Jigsaw—Java自身的模块化 Java通过引导一个旧版本的Java——例如，Java以其自身为构件建立。旧的组件被组合在一起创建一个新的组件，即成为下一阶段的结构单元。 OpenJDK8使用JDK7编译和构建，类似地，OpenJDK9 则使用JDK8编译构建。理论上，OpenJDK8是可以使用从其自身创建的影像编译的，同理，OpenJDK9也能用OpenJDK9编译。使用一个叫做循环启动影像的进程——创建OpenJDK的JDK影像，使用同样的影像，OpenJDK再一次被编译。也可以用make命令实现OpenJDK的编译： $ make bootcycle-images # Build images twice, second time with newly built JDK make命令在OpenJDK8和OpenJDK9下都提供了很多设置选项，可以通过命名的方式建立独立的组件或模块。如下： $ make [component-name] | [module-name] 甚至并行运行多个构建过程，如下： $ make JOBS= # Run parallel make jobs 最后，用install选项安装上述已构建的组件，如下： $ make install 特性 性能与可伸缩性 就我能够看到的性能测试而言，闭源的 Oracle JDK 和 OpenJDK 之间在性能上似乎并没有很大的差别。然而，至少后来我看到的一则明确的消息说，开源版本的性能已经与 Oracle 的产品并驾齐驱了，这或许是一个理由，让我们至少对开源版本的用法做一下评估。 社区进展 随着开源开发者持续对源代码进行改进，OpenJDK 很有可能已经超过 Oracle 发布的版本。另外，开源世界为各种思想和概念提供了实现的可能，这通常在闭源的企业环境中是不可能的 关于开源解决方案如何成为主角的一个例子是 PostgreSQL 数据库。随着 9.5.0 版于 2016 年 1 月初的发布，致力于该产品的贡献者已经使该产品获得了巨大的成功。PostgreSQL 的用户包括：雅虎、Sony在线、BASF、Reddit、Instagram以及 TripAdvisor（只是随便举几个例子） 包管理 OpenJDK 也具有了通过类似 brew 这样的包管理器下载/更新 JDK 的能力。JDK 的自动更新能力，对某些人来说可能不算什么，但对于大型的 JDK 实现而言，其作用是巨大的 许可证问题 假如你处在类似谷歌的位置，使用 Oracle 的 JDK 有可能会导致违反版权/专利权，那么迁移到 OpenJDK 就是一个应该考虑的选项。从我的非专业、非律师的角度来看，我并不十分肯定的是，仅仅通过采用 OpenJDK是否就能让谷歌完全摆脱困境 跟从趋势 如果你本来就是一个开源软件的粉丝，那么 OpenJDK 的目前版本已经稳定，而且性能上接近（如果不是相等的话）Oracle 的产品。再说，跟从由谷歌、IBM、RedHat、Apple 共同设定的趋势，可能是一注安全的赌注，这应该有助于说服你看一下开源 JDK","tags":[{"name":"openjdk","slug":"openjdk","permalink":"https://goghtsui.github.io/tags/openjdk/"}]},{"title":"getDimension、getDimensionPixelOffset、getDimensionPixelSize初级篇","date":"2016-07-21T14:24:31.000Z","path":"2016/07/21/getDimension、getDimensionPixelOffset、getDimensionPixelSize初级篇/undefined/","text":"序言在Android应用开发的过程中，我们肯定会遇到一个问题 - 适配 ，这是一个非常头疼的问题，因为你面对的是各式各样的、千奇百怪的屏幕尺寸和分辨率，所以你不可能适配所有机型，只能适配主流的机型及分辨率，所以我们会配置不同分辨率的values（如：values-sw600dp，values-sw720dp），在values下面会有这样一个文件：dimens.xml，我们一般会在里面定义一些视图的尺寸值，可以是不同的单位，如：dp、dip、sp、pt、px、mm、in ，那么我们怎么读取这些值得？ 官方APIgoogle给我们提供了三个api使用：getDimension，getDimensionPixelOffset和getDimensionPixelSize，你都使用过吗？它们有什么不同？有什么使用场景？接下来就带大家简单了解一下这三个api的不同。首先得还是先看一下官方文档，这才是最权威的不是嘛。 getDimension 包 ： android.content.res.Resources Added in API level 1 float getDimension (int id) Retrieve a dimensional for a particular resource ID. Unit conversions are based on the current DisplayMetrics associated with the resources. Parameters description id int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier. Returns description float Resource dimension value multiplied by the appropriate metric. Throws description Resources.NotFoundException Throws NotFoundException if the given ID does not exist. See also: getDimensionPixelOffset(int) getDimensionPixelSize(int) getDimensionPixelOffset Added in API level 1 int getDimensionPixelOffset (int id) Retrieve a dimensional for a particular resource ID for use as an offset in raw pixels. This is the same as getDimension(int), except the returned value is converted to integer pixels for you. An offset conversion involves simply truncating the base value to an integer. Parameters description id int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier. Returns description int Resource dimension value multiplied by the appropriate metric and truncated to integer pixels. Throws description Resources.NotFoundException Throws NotFoundException if the given ID does not exist. See also: getDimension(int) getDimensionPixelSize(int) getDimensionPixelSize Added in API level 1 int getDimensionPixelSize (int id) Retrieve a dimensional for a particular resource ID for use as a size in raw pixels. This is the same as getDimension(int), except the returned value is converted to integer pixels for use as a size. A size conversion involves rounding the base value, and ensuring that a non-zero base value is at least one pixel in size. Parameters description id int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier. Returns description int Resource dimension value multiplied by the appropriate metric and truncated to integer pixels. Throws description Resources.NotFoundException Throws NotFoundException if the given ID does not exist. See also: getDimension(int) getDimensionPixelOffset(int) 解析下面通过代码来看看具体的使用：dimens.xml &lt;dimen name=&quot;custom_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;custom_textsize&quot;&gt;16sp&lt;/dimen&gt; &lt;dimen name=&quot;test_margin&quot;&gt;3.5dp&lt;/dimen&gt; &lt;dimen name=&quot;test_textsize&quot;&gt;3.5sp&lt;/dimen&gt; 调用: // dp - 16 float dp1 = getResources().getDimension(R.dimen.custom_margin); int dp2 = getResources().getDimensionPixelOffset(R.dimen.custom_margin); int dp3 = getResources().getDimensionPixelSize(R.dimen.custom_margin); // dp - 3.5 float dp4 = getResources().getDimension(R.dimen.test_margin); int dp5 = getResources().getDimensionPixelOffset(R.dimen.test_margin); int dp6 = getResources().getDimensionPixelSize(R.dimen.test_margin); // sp - 16 float sp1 = getResources().getDimension(R.dimen.custom_textsize); int sp2 = getResources().getDimensionPixelOffset(R.dimen.custom_textsize); int sp3 = getResources().getDimensionPixelSize(R.dimen.custom_textsize); // sp - 3.5 float sp4 = getResources().getDimension(R.dimen.custom_textsize); int sp5 = getResources().getDimensionPixelOffset(R.dimen.custom_textsize); int sp6 = getResources().getDimensionPixelSize(R.dimen.custom_textsize); String log = &quot;getDimension(16dp) = &quot; + dp1 + &quot;\\n&quot; + &quot;getDimensionPixelOffset(16dp) = &quot; + dp2 + &quot;\\n&quot; + &quot;getDimensionPixelSize(16dp) = &quot; + dp3 + &quot;\\n&quot; + &quot;\\n&quot; + &quot;getDimension(dp3.5) = &quot; + dp4 + &quot;\\n&quot; + &quot;getDimensionPixelOffset(dp3.5) = &quot; + dp5 + &quot;\\n&quot; + &quot;getDimensionPixelSize(dp3.5) = &quot; + dp6 + &quot;\\n&quot; + &quot;\\n&quot; + &quot;getDimension(sp16) = &quot; + sp1 + &quot;\\n&quot; + &quot;getDimensionPixelOffset(sp16) = &quot; + sp2 + &quot;\\n&quot; + &quot;getDimensionPixelSize(sp16) = &quot; + sp3 + &quot;\\n&quot; + &quot;\\n&quot; + &quot;getDimension(sp3.5) = &quot; + sp4 + &quot;\\n&quot; + &quot;getDimensionPixelOffset(sp3.5) = &quot; + sp5 + &quot;\\n&quot; + &quot;getDimensionPixelSize(sp3.5) = &quot; + sp6; Log.d(&quot;LauncherActivity&quot;, log); 输出： densityDpi：160 scale：1.0 fontScale：1.0 getDimension(16dp) = 16.0 getDimensionPixelOffset(16dp) = 16 getDimensionPixelSize(16dp) = 16 getDimension(3.5dp) = 3.5 getDimensionPixelOffset(3.5dp) = 3 getDimensionPixelSize(3.5dp) = 4 getDimension(16sp) = 16.0 getDimensionPixelOffset(16sp) = 16 getDimensionPixelSize(16sp) = 16 getDimension(3.5sp) = 3.5 getDimensionPixelOffset(3.5sp) = 3 getDimensionPixelSize(3.5sp) = 4 densityDpi：240 scale：1.5 fontScale：1.5 getDimension(16dp) = 24.0 getDimensionPixelOffset(16dp) = 24 getDimensionPixelSize(16dp) = 24 getDimension(3.5dp) = 5.25 getDimensionPixelOffset(3.5dp) = 5 getDimensionPixelSize(3.5dp) = 5 getDimension(16sp) = 24.0 getDimensionPixelOffset(16sp) = 24 getDimensionPixelSize(16sp) = 24 getDimension(3.5sp) = 5.25 getDimensionPixelOffset(3.5sp) = 5 getDimensionPixelSize(3.5sp) = 5 总结通过上面的代码就可以说明问题了，我们可以看到以下几点： 三个方法都是将源数据乘以scale getDimension的返回值是float类型，getDimensionPixelOffset和getDimensionPixelSize的返回值是int类型 三个方法返回的都是px值，即将dp或者sp等值转换为px值 getDimensionPixelOffset()是直接将小数位舍弃，而getDimensionPixelSize()则会进行四舍五入 像setWidth(int)、setHeight(int)这种都是px，根据自己的情况选择getDimensionPixelSize()或getDimensionPixelOffset() 像setTextSize()：一个参数的是sp；两个参数的是unit和px","tags":[{"name":"getDimension","slug":"getDimension","permalink":"https://goghtsui.github.io/tags/getDimension/"},{"name":"getDimensionPixelOffset","slug":"getDimensionPixelOffset","permalink":"https://goghtsui.github.io/tags/getDimensionPixelOffset/"},{"name":"getDimensionPixelSize","slug":"getDimensionPixelSize","permalink":"https://goghtsui.github.io/tags/getDimensionPixelSize/"}]},{"title":"Android刷机-命令篇","date":"2016-05-21T08:20:30.000Z","path":"2016/05/21/Android刷机-命令篇/undefined/","text":"序言命令行刷机和线刷本质差不多，一个是工具一个是手动的。线刷包解压出来一般都是一些镜像文件（.img），像基带、内核、系统、recovery、boot等，要先关机，进入线刷（bootloader）模式下。如果电脑上有adb环境（没有就下载adb工具），直接执行 adb reboot bootloader 进入到线刷模式，下面就给出一些常用命令行（MOTO 为例） 命令行1、刷入手机闪存分区表（请不要乱刷其他机型的，可能导致变砖，请在有教程指引下操作） fastboot flash partition gpt.bin 2、刷入摩托罗拉bootleader（请一定不要跨机型刷，或者降版本刷，否则分分钟变砖） fastboot flash motoboot motoboot.img 3、刷入基带 fastboot flash modem NON-HLOS.bin 4、刷入efs射频表 fastboot flash fsg fsg.mbn 5、清理基带缓存 fastboot erase modemst1 6、清理efs射频表 fastboot erase modemst2 7、刷入缓存 fastboot flash cache cache.img 8、输入用户数据 fastboot flash userdata userdata.img 9、重新进入bootleader模式 fastboot reboot-bootloader 10、刷入内核部分 fastboot flash boot boot.img 11、刷入系统恢复模式模块 fastboot flash recovery recovery.img 12、刷入系统部分（有可能system.img被分割为很多个文件 system.*****.01啥的，逐个替换内容中的system.img，按照数字顺序执行即可） fastboot flash system system.img 或 fastboot flash system system.01 fastboot flash system system.02 fastboot flash system system.03 13、这句一般是用在解锁后跨版本升级，清理fastboot模式缓存，作用也是让新的分区表生效，从而可以加载非本区域的原版系统，比如用在国行刷亚太底包上，就可能会用到这一句 fastboot oem fb_mode_clear 14、还有一些基带相关的： fastboot flash sbl1 sbl1.mbn fastboot flash dbi sdi.mbn fastboot flash aboot emmc_appsboot.mbn fastboot flash tz tz.mbn fastboot flash LOGO logo.bin fastboot flash misc misc.img fastboot flash oppostanvbk static_nvbk.bin 15、类似双清操作，一般刷机完成之后执行一下这句话，有的不执行可能卡在开机画面 fastboot -w 总结没什么技术含量，什么文件使用什么命令行，不过一般的线刷包不会这么多文件，命令行刷机还是需要有一定刷机经验的，还是那句话：刷机有风险，操作需谨慎","tags":[{"name":"fastboot","slug":"fastboot","permalink":"https://goghtsui.github.io/tags/fastboot/"},{"name":"adb","slug":"adb","permalink":"https://goghtsui.github.io/tags/adb/"},{"name":"bootloader","slug":"bootloader","permalink":"https://goghtsui.github.io/tags/bootloader/"}]},{"title":"Android刷机-基础篇","date":"2016-05-21T08:19:57.000Z","path":"2016/05/21/Android刷机-基础篇/undefined/","text":"序言 刷机有风险，操作需谨慎 先看看维基百科对刷机的解释： 刷机是一般的手机发烧友最开始接触到的相当有技术含量的一个词，泛指通过软件或者手机自身的OTA文件对系统文件进行更改从而使手机达到自己想要的或者更好的使用效果。有时，智能手机的系统被损坏，造成功能缺失或无法开机，也通常用刷机的方法恢复 刷机在Android系统中用得更广泛，随着Android系统不断升级，用户需要通过刷机来升级自身设备，或者用户想要体验更加流畅的操作与不同而进行第三方ROM进行刷机，也有一些工具或软件可以简化刷机流程 通常第一方ROM指的是操作系统开发者所发布的原生版本(如Google开发的原生Android版本)，第二方指的是个手机制造商所开发出的版本(如HTC的Sense或Sony的接口)，第三方则是由其他人或团队所开发(如Android中的Cygenmode(CM)团队， Slim等) 方式Android刷机分为四种方式：线刷，卡刷，软刷和厂刷 软刷：就是利用甜椒、精灵、大师等一键刷机软件进行傻瓜式刷机 卡刷：就是把刷机包直接放到SD卡上，然后通过手机的Recovery刷入 线刷：就是通过计算机上的软件把刷机包用数据线连接手机载入到手机内存中，使其作为“第一启动”的刷机方法。线刷软件都为计算机软件，一般来说不同手机型号有不同的刷机软件 厂刷：寄回厂子刷机，安全性最高，但时间上会更久 软刷和厂刷没什么多说的，都相当于是找人代工了，这里只讲解卡刷和线刷 线刷线刷也是比较方便快捷的，其实和软刷有异曲同工之妙，不同的手机品牌需要不同的工具（PC软件），下面是我了解的一些，其他的就自己找找吧，也有可能没有 手机品牌 线刷工具 三星 Odin MOTO RSD Lite 小米 MiFlash 联想 SP_Flash_Tool 华为 HUAWEI Multi-Upgrade Software 通用线刷步骤： 下载对应手机厂商线刷工具并安装 下载对应手机型号驱动并安装 下载官方提供的刷机包或OTA包 关机，通过组合键进入线刷模式（不同手机组合键不同，自行搜索），通常也叫挖煤模式（甚至网上有卖挖煤神器的） 通过数据线（最好是原装数据线）链接电脑，如果驱动安装正常，就能正常连接手机，一般软件都会有链接提示，然后就是通过软件选择相应的刷机包（或者是需要先解压，在软件界面选择不同文件） 开始刷机，等待读条完成 注：线刷要保证电量足够，不建议新手操作，这里面的细节很多，很多手机出厂都是上锁的，像htc还分S-ON和S-OFF，默认线刷只是平刷或更高版本，不能降级刷，这些步骤是核心步骤，其实还有一种手动的线刷的方式，就是通过命令手动刷镜像文件，和工具的原理一样，详情请看下一篇文章","tags":[{"name":"卡刷","slug":"卡刷","permalink":"https://goghtsui.github.io/tags/%E5%8D%A1%E5%88%B7/"},{"name":"线刷","slug":"线刷","permalink":"https://goghtsui.github.io/tags/%E7%BA%BF%E5%88%B7/"}]},{"title":"Http协议简介","date":"2016-03-02T06:20:33.000Z","path":"2016/03/02/Http协议简介/undefined/","text":"原作者：吾爱源地址：点击跳转 序言我们平时在浏览网页的时候都是使用浏览器，输入你要的网址后回车，就会显示出我们所想要的内容，看似这个简单的用户操作行为的背后，Web的工作原理是怎样的呢？到底隐藏了些什么呢？ 对于传统的上网流程，系统它是这么做的：浏览器本身它是一个客户端，当输入URL地址的时候，浏览器首先会去请求DNS服务器，通过DNS查询获取相应的域名所对应的IP地址，然后通过这个映射的IP地址找到IP对应的服务器，并建立连接，等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理，返回HTTP Response（响应）包，客户端浏览器收到来自服务器的响应后就开始渲染这个Response包里的主体（body）部分，等收到全部的内容后断开与该服务器之间的连接。 一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端客户端内部也是浏览器实现的)。 Web服务器的工作原理可以简单地定义为： 1 客户机通过TCP/IP协议建立到服务器的TCP连接 2 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档 3 服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 4 客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果 一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。 URL和DNS解析我们浏览网页都是通过URL访问的，那么URL到底是怎么样的呢？URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源, 基本格式如下： html scheme://host[:port#]/path/.../[?query-string][#anchor] scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.qixing318.com:80/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor 锚 DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它从事将主机名或域名转换为实际IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。 DNS工作原理更详细的DNS解析的过程如下，这个过程有助于我们理解DNS的工作模式 1 在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qixing318.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qixing318.com域服务器，重复上面的动作，进行查询，直至找到www.qixing318.com主机。 6 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 DNS解析的整个流程所谓 递归查询过程 就是 “查询的递交者” 更替, 而 迭代查询过程 则是 “查询的递交者”不变。 举个例子来说，你想知道某个一起上法律课的女孩的电话，并且你偷偷拍了她的照片，回到寝室告诉一个很仗义的哥们儿，这个哥们儿二话没说，拍着胸脯告诉你，甭急，我替你查(此处完成了一次递归查询，即，问询者的角色更替)。然后他拿着照片问了学院大四学长，学长告诉他，这姑娘是xx系的；然后这哥们儿马不停蹄又问了xx系的办公室主任助理同学，助理同学说是xx系yy班的，然后很仗义的哥们儿去xx系yy班的班长那里取到了该女孩儿电话。(此处完成若干次迭代查询，即，问询者角色不变，但反复更替问询对象)最后，他把号码交到了你手里。完成整个查询过程。通过上面的步骤，我们最后获取的是IP地址，也就是浏览器最后发起请求的时候是基于IP来和服务器做信息交互的。 HTTP协议详解HTTP协议是Web工作的核心，所以要了解清楚Web的工作方式就需要详细的了解清楚HTTP是怎么样工作的。 HTTP是一种让Web服务器与浏览器(客户端)通过Internet发送与接收数据的协议,它建立在TCP协议之上，一般采用TCP的80端口。它是一个请求、响应协议–客户端发出一个请求，服务器响应这个请求。 在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。 HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web程序引入了Cookie机制来维护连接的可持续状态。 HTTP协议是建立在TCP协议之上的，因此TCP攻击一样会影响HTTP的通讯，例如比较常见的一些攻击：SYN Flood是当前最流行的DoS（拒绝服务攻击）与DdoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。 HTTP请求包（浏览器信息）我们先来看看Request包的结构, Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。 header和body之间有个空行，请求包的例子所示: GET /domains/example/ HTTP/1.1 请求行: 请求方法 请求URI HTTP协议/协议版本 Host：www.qixing318.com. 服务端的主机名 User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4 客户端浏览器信息 Accept：text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 客户端能接收的mine类型 Accept-Encoding：gzip,deflate,sdcn 是否支持流压缩 Accept-Charset：UTF-8,*;q=0.5 客户端字符编码集 “\\r\\n\\r\\n” 空行,用于分割请求头和消息体 “\\r\\n\\r\\n” 空行,消息体,请求资源参数,例如POST传递的参数 HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 通过fiddler抓包可以看到如下请求信息:上图为：fiddler抓取的GET信息 上图为：fiddler抓取的POST信息 GET和POST的区别: 1 我们可以看到GET请求消息体为空，POST请求带有消息体。 2 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的body中。 3 GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。 4 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 HTTP响应包（服务器信息）我们再来看看HTTP的response包，他的结构如下： HTTP/1.1 200 OK 状态行 Server: nginx/1.0.8 服务器使用的WEB软件名及版本 Date:Date: Tue, 30 Oct 2012 04:14:25 GMT 发送时间 Content-Type: text/html 服务器发送信息的类型 Transfer-Encoding: chunked 表示发送HTTP包是分段发的 Connection: keep-alive 保持连接状态 Content-Length: 90 消息主体内容长度 \\r\\n 空行，用来分割消息头和主体 &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”… 消息体部分 Response包中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 状态码详细查询 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 我们看下面这个图展示了详细的返回信息，左边可以看到有很多的资源返回码，200是常用的，表示正常信息，302表示跳转。response header里面展示了详细的信息。【上图：访问一次网站的全部请求信息】 HTTP协议是无状态的和Connection: keep-alive的区别无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间。 请求实例 【上图为：一次请求的request和response】 上面这张图我们可以了解到整个的通讯过程，同时细心的读者是否注意到了一点，一个URL请求但是左边栏里面为什么会有那么多的资源请求(这些都是静态文件，go对于静态文件有专门的处理方式)。 这个就是浏览器的一个功能，第一次请求url，服务器端返回的是html页面，然后浏览器开始渲染HTML：当解析到HTML DOM里面的图片连接，css脚本和js脚本的链接，浏览器就会自动发起一个请求静态资源的HTTP请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。 网页优化方面有一项措施是减少HTTP请求次数，就是把尽量多的css和js资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。","tags":[{"name":"http协议","slug":"http协议","permalink":"https://goghtsui.github.io/tags/http%E5%8D%8F%E8%AE%AE/"}]},{"title":"实用bat脚本[笔记]","date":"2016-03-01T03:41:36.000Z","path":"2016/03/01/实用bat脚本-笔记/undefined/","text":"垃圾清理 一个自定义的pc端系统垃圾清理批处理文件，可以配合各大电脑管家使用： @echo off color 0a title ********系统垃圾清理******** echo 正在清除系统垃圾文件，请稍后...... echo 删除补丁备份目录 RD %windir%\\$hf_mig$ /Q /S echo 把补丁卸载文件夹的名字保存成patchs.txt dir %windir%\\$NtUninstall* /a:d /b &gt;%windir%\\patchs.txt echo 从patchs.txt中读取文件夹列表并且删除文件夹 for /f %%i in (%windir%\\patchs.txt) do rd %windir%\\%%i /s /q echo 删除patchs.txt del %windir%\\patchs.txt /f /q echo 删除补丁安装记录内容（下面的del /f /s /q %systemdrive%\\*.log已经包含删除此类文件） del %windir%\\KB*.log /f /q echo 删除系统盘目录下临时文件 del /f /s /q %systemdrive%\\*.tmp echo 删除系统盘目录下临时文件 del /f /s /q %systemdrive%\\*._mp echo 删除系统盘目录下日志文件 del /f /s /q %systemdrive%\\*.log echo 删除系统盘目录下GID文件(属于临时文件，具体作用不详) del /f /s /q %systemdrive%\\*.gid echo 删除系统目录下scandisk（磁盘扫描）留下的无用文件 del /f /s /q %systemdrive%\\*.chk echo 删除系统目录下old文件 del /f /s /q %systemdrive%\\*.old echo 删除回收站的无用文件 del /f /s /q %systemdrive%\\recycled\\*.* echo 删除系统目录下备份文件 del /f /s /q %windir%\\*.bak echo 删除应用程序临时文件 del /f /s /q %windir%\\prefetch\\*.* echo 删除系统维护等操作产生的临时文件 rd /s /q %windir%\\temp &amp; md %windir%\\temp echo 删除当前用户的COOKIE（IE） del /f /q %userprofile%\\cookies\\*.* echo 删除internet临时文件 del /f /s /q &quot;%userprofile%\\local settings\\temporary internet files\\*.*&quot; del /f /s /q &quot;%userprofile%\\Local Settings\\Temporary Internet Files\\*.*&quot; echo 删除当前用户日常操作临时文件 del /f /s /q &quot;%userprofile%\\local settings\\temp\\*.*&quot; del /f /s /q &quot;%userprofile%\\Local Settings\\Temp\\*.*&quot; echo 删除访问记录（开始菜单中的文档里面的东西） del /f /s /q &quot;%userprofile%\\recent\\*.*&quot; echo echo 恭喜您！清理全部完成！ echo. &amp; pause 右键 -&gt; 已管理员身份运行 即可，不会存在任何风险，当然你也可以自己添加路径或者相关的处理，可以说是绿色安全 启动应用 @echo off color 0a title ********快速启动******** echo 1、QQ echo 2、Exit set /p s=请输入应用的编号，按Enter启动应用： if %s% equ 1 goto a if %s% equ 2 goto b :a start &quot;&quot; &quot;E:\\Program Files (x86)\\Tencent\\QQ\\Bin\\QQ.exe&quot; echo QQ启动完成！ exit :b exit 这个就非常简单了，一个if判断，指定对应应用的绝对路径，启动指定的应用，还可以打开指定的路径的，因为我比较喜欢简洁的桌面，有了这个脚本，桌面上就不用放置很多快捷方式了 adb shell 这个适用于Win系统下对手机执行一些操作，原因是命令行执行了adb shell之后，无法继续使用shell的相关命令，那么我们可以先将命令输出到一个文件里，在读取出来就可以了,以删除文件为例： adb root adb remount echo cd /sdcard/ &gt;&gt; temp.txt echo rm -r 1.txt &gt;&gt; temp.txt echo exit &gt;&gt; temp.txt adb shell &lt; temp.txt","tags":[{"name":"bat","slug":"bat","permalink":"https://goghtsui.github.io/tags/bat/"},{"name":"批处理文件","slug":"批处理文件","permalink":"https://goghtsui.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"}]},{"title":"Android之自定义actionbar[笔记]","date":"2016-03-01T03:06:22.000Z","path":"2016/03/01/Android之自定义actionbar[笔记]/undefined/","text":"自定义actionbar或toolbar的属性样式： &lt;style name=&quot;detail_actionbar_style&quot; parent=&quot;AppBaseTheme&quot;&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;!--&lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;--&gt; &lt;!--&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;--&gt; &lt;!--&lt;item name=&quot;android:windowIsFloating&quot;&gt;false&lt;/item&gt;--&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowActionBar&quot;&gt;false&lt;/item&gt; &lt;!-- actionbar --&gt; &lt;item name=&quot;android:windowActionBarOverlay&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:actionBarStyle&quot;&gt;@style/ActionBar.Style.Transparent&lt;/item&gt; &lt;item name=&quot;android:actionOverflowButtonStyle&quot;&gt;@style/OverFlow&lt;/item&gt; &lt;/style&gt; &lt;!-- actionbar --&gt; &lt;style name=&quot;ActionBar.Transparent&quot; parent=&quot;@android:style/Theme.Holo.Light&quot;&gt; &lt;item name=&quot;android:windowActionBarOverlay&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:actionBarStyle&quot;&gt;@style/ActionBar.Style.Transparent&lt;/item&gt; &lt;item name=&quot;android:actionOverflowButtonStyle&quot;&gt;@style/OverFlow&lt;/item&gt; &lt;/style&gt; &lt;!-- 实现Actionbar的透明度 --&gt; &lt;style name=&quot;ActionBar.Style.Transparent&quot; parent=&quot;@android:style/Widget.Holo.ActionBar&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:titleTextStyle&quot;&gt;@style/ActionBarText&lt;/item&gt; &lt;/style&gt; &lt;!-- 标题文字 --&gt; &lt;style name=&quot;ActionBarText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;19sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@android:color/white&lt;/item&gt; &lt;/style&gt; &lt;!-- 重写actionbar中 OverFlow的属性 --&gt; &lt;style name=&quot;OverFlow&quot; parent=&quot;@android:style/Widget.Holo.ActionButton.Overflow&quot;&gt; &lt;item name=&quot;android:src&quot;&gt;@drawable/custom_actionbar_overflow&lt;/item&gt; &lt;/style&gt;","tags":[{"name":"沉浸式状态栏","slug":"沉浸式状态栏","permalink":"https://goghtsui.github.io/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"}]},{"title":"Java之HashMap和HashTable的不同","date":"2016-02-19T07:13:32.000Z","path":"2016/02/19/Java之HashMap和HashTable的不同/undefined/","text":"HashTable和HashMap的6个不同点：Java热门面试题例子 HashTable和HashMa的区别是面试题中经常被问到的问题。还有其他比较热门的问题，像ArrayList和Vector、Comparator和Comparable。这些问题经常在面试中被问题，以检查我们是否正确理解集合类的使用和拥有的替代解决方案的知识。这两者之间的不同，包括6个点，分别是Synchronization_、_Null keys and values_、_Iterating values_、_Fail fast iterator_、_Performance_、_Superclass HashTable和HashMap的不同1.Synchronization or Thread Safe : 这是它们最重要的不同点。HashMap不是同步的，并且不是是线程安全的。相反，HashTable是线程安全和同步的。 什么时候使用HashMap？答案是如果你的应用不需要任何多线程任务，就是说HashMap适用于没有线程的应用。HashTable应该在多线程应用中使用。 扩展：Java提供了ConcurrentHashMap，它是HashTable的替代品，比HashTable的扩展性更好。HashMap可以通过下面的语句进行同步： Map m = Collections.synchronizeMap(hashMap); 2. Null keys and null values : HashMap允许一个空的key和多个空的value， 然而HashTable不允许空的键值。 3. Iterating the values: HashMap对象的值是通过Iterator迭代的。HashTable是除vector之外惟一的一个使用了enumerator迭代器来迭代其对象值的类。 4. Fail-fast iterator : 在HashMap中是fail-fast迭代器，而HashTable的emumerator不是。根据Oracle Docs,如果HashTable对象的iterator以任何方式被创建之后它在“结构上”被修改，那么除了迭代器自己的remove方法，否则迭代器将抛出ConcurrentModificationException异常。 结构上的更改指的是删除或者插入一个元素（hashtable和hashmap），因此，由Hashtable的键和元素方法返回的enumerations不是Fail-fast。关于iterator and enumeration的不同. 扩展：如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 5. Performance :HashMap是比较快的，并且使用了很少的内存。在单个的线程环境中，不同步的对象通常在性能上是比同步的对象要好的。 6.Superclass and Legacy :HashTable是Dictionary的子类，在jdk 1.7中已经过时了，因此它不再被使用。它是最好的外部实现同步的方法，或者使用一个ConcurrentMap实现（如ConcurrentHashMap）HashMap是AbstractMap的子类，尽管HashMap和HashTable有不同的父类，但是他们都继承了抽象类“Map”。 HashMap和HashTable的例子import java.util.Hashtable; public class HashMapHashtableExample &#123; public static void main(String[] args) &#123; Hashtable&lt;String,String&gt; hashtableobj = new Hashtable&lt;String, String&gt;(); hashtableobj.put(&quot;Alive is &quot;, &quot;awesome&quot;); hashtableobj.put(&quot;Love&quot;, &quot;yourself&quot;); System.out.println(&quot;Hashtable object output :&quot;+ hashtableobj); HashMap hashmapobj = new HashMap(); hashmapobj.put(&quot;Alive is &quot;, &quot;awesome&quot;); hashmapobj.put(&quot;Love&quot;, &quot;yourself&quot;); System.out.println(&quot;HashMap object output :&quot;+hashmapobj); &#125; &#125; 输出结果： Hashtable object output :&#123;Love=yourself, Alive is =awesome&#125; HashMap object output :&#123;Alive is =awesome, Love=yourself&#125; HashMap和Hashtable的相似之处 1.插入顺序： 随着时间的推移，HashMap和HashTable都不能保证集合的顺序，相反的，使用LinkedHashMap不会因为时间的推移而改变顺序。 2.Map接口： HashMap和HashTable都是实现了Map接口。 3.存和取的方法： HashMap和HashTable为存取提供了稳定的时间性能 4.内部原理： HashMap和HashTable遵顼的是散列的原则：[HashMap是如何工作的？][3] HashMap和HashTable什么时候使用？ 1. 单线程应用在非线程应用中，HashMap要优于HashTable的，简单来说，使用HashMap在非同步或者单线程的应用中。 2. 多线程应用我们应该避免使用Hashtable，因为这个类在最近的jdk1.8中过时了。Oracle已经提供了很好的替代的类：ConcurrentHashMap，对于多线程应用，使用ConcurrentHashMap而不是Hashtable。 总结 区别 HashMap HashTable 同步 NO Yes 线程安全 NO Yes 空键值 一个空键，任意空值 不允许空键值 迭代类型 Fail fast迭代器 Fail safe迭代器 性能 快 作比较慢 父类和遗弃 AbstractMap，NO Dictionary , Yes","tags":[{"name":"HashTable","slug":"HashTable","permalink":"https://goghtsui.github.io/tags/HashTable/"},{"name":"HashMap","slug":"HashMap","permalink":"https://goghtsui.github.io/tags/HashMap/"}]},{"title":"Android之Matrix","date":"2016-02-19T07:11:37.000Z","path":"2016/02/19/Android之Matrix/undefined/","text":"原作者： Qiengo源地址： 点击跳转 Matrix的数学原理在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下： Matrix的对图像的处理可分为四类基本变换： Translate - 平移变换 Rotate - 旋转变换 Scale - 缩放变换 Skew - 错切变换 从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。 针对每种变换，Android提供了pre、set和post三种操作方式。其中： set - 用于设置Matrix中的值。 pre - 是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。 post - 是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。 除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。 下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。 一、 平移变换 假定有一个点的坐标是 ，将其移动到 ，再假定在x轴和y轴方向移动的大小分别为： 如下图所示： 不难知道： 如果用矩阵来表示的话，就可以写成： 二、 旋转变换 2.1 围绕坐标原点旋转：假定有一个点 ，相对坐标原点顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图： 那么， 如果用矩阵，就可以表示为： 2.2 围绕某个点旋转如果是围绕某个点顺时针旋转，那么可以用矩阵表示为： 可以化为： 很显然， 1. 是将坐标原点移动到点后， 的新坐标。 2. 是将上一步变换后的，围绕新的坐标原点顺时针旋转 。 3. 经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。 所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。 三、 缩放变换 理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即 用矩阵表示就是： 缩放变换比较好理解，就不多说了。 四、 错切变换 错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。 比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。 下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。 假定一个点经过错切变换后得到，对于水平错切而言，应该有如下关系： 用矩阵表示就是： 扩展到3 x 3的矩阵就是下面这样的形式： 同理，对于垂直错切，可以有： 在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是： 五、 对称变换 除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 经过对称变换后得到， 如果对称轴是x轴，难么， 用矩阵表示就是： 如果对称轴是y轴，那么， 用矩阵表示就是： 如果对称轴是y = x，如图： 那么， 很容易可以解得： 用矩阵表示就是： 同样的道理，如果对称轴是y = -x，那么用矩阵表示就是： 特殊地，如果对称轴是y = kx，如下图： 那么， 很容易可解得： 用矩阵表示就是： 当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。 如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的： 需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换： 要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换： 关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。 第二部分 代码验证在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：其尺寸为162 x 251。 每种变换的结果，请见代码之后的说明。 package com.pat.testtransformmatrix; import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Matrix; import android.os.Bundle; import android.util.Log; import android.view.MotionEvent; import android.view.View; import android.view.Window; import android.view.WindowManager; import android.view.View.OnTouchListener; import android.widget.ImageView; public class TestTransformMatrixActivity extends Activity implements OnTouchListener &#123; private TransformMatrixView view; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); view = new TransformMatrixView(this); view.setScaleType(ImageView.ScaleType.MATRIX); view.setOnTouchListener(this); setContentView(view); &#125; class TransformMatrixView extends ImageView &#123; private Bitmap bitmap; private Matrix matrix; public TransformMatrixView(Context context) &#123; super(context); bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie); matrix = new Matrix(); &#125; @Override protected void onDraw(Canvas canvas) &#123; // 画出原图像 canvas.drawBitmap(bitmap, 0, 0, null); // 画出变换后的图像 canvas.drawBitmap(bitmap, matrix, null); super.onDraw(canvas); &#125; @Override public void setImageMatrix(Matrix matrix) &#123; this.matrix.set(matrix); super.setImageMatrix(matrix); &#125; public Bitmap getImageBitmap() &#123; return bitmap; &#125; &#125; public boolean onTouch(View v, MotionEvent e) &#123; if(e.getAction() == MotionEvent.ACTION_UP) &#123; Matrix matrix = new Matrix(); // 输出图像的宽度和高度(162 x 251) Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; + view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight()); // 1. 平移 matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight() view.setImageMatrix(matrix); // 下面的代码是为了查看matrix中的元素 float[] matrixValues = new float[9]; matrix.getValues(matrixValues); for(int i = 0; i &lt; 3; ++i) &#123; String temp = new String(); for(int j = 0; j &lt; 3; ++j) &#123; temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; &#125; Log.e(&quot;TestTransformMatrixActivity&quot;, temp); &#125; // // 2. 旋转(围绕图像的中心点) // matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 3. 旋转(围绕坐标原点) + 平移(效果同2) // matrix.setRotate(45f); // matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f); // matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 4. 缩放 // matrix.setScale(2f, 2f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 5. 错切 - 水平 // matrix.setSkew(0.5f, 0f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 6. 错切 - 垂直 // matrix.setSkew(0f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // 7. 错切 - 水平 + 垂直 // matrix.setSkew(0.5f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 8. 对称 (水平对称) // float matrix_values[] = &#123;1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 9. 对称 - 垂直 // float matrix_values[] = &#123;-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // 10. 对称(对称轴为直线y = x) // float matrix_values[] = &#123;0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(), // view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + &quot;\\t&quot;; // &#125; // Log.e(&quot;TestTransformMatrixActivity&quot;, temp); // &#125; view.invalidate(); &#125; return true; &#125; &#125; 下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵 1.平移 输出的结果： 请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。 2.旋转(围绕图像的中心点) 输出的结果： 它实际上是 matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f); 这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式， matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); 所产生的转换矩阵就是： 而 matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f); 的意思就是在上述矩阵的左边再乘以下面的矩阵： 关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。所以它实际上就是： 出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。 3.旋转(围绕坐标原点旋转，在加上两次平移，效果同2) 根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道： matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); 等价于 matrix.setRotate(45f); matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f); matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f); 其中matrix.setRotate(45f)对应的矩阵是： matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f) 对应的矩阵是： 由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。 matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f) 对应的矩阵是： 这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。 所以综合起来， matrix.setRotate(45f); matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f); matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f); 对应的矩阵就是： 这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的： 因此，此处变换后的图像和2中变换后的图像时一样的。![][307] 4.缩放变换 程序所输出的两个矩阵分别是： 其中第二个矩阵，其实是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。 5.错切变换(水平错切) 代码所输出的两个矩阵分别是： 其中，第二个矩阵其实是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 6.错切变换(垂直错切) 代码所输出的两个矩阵分别是： 其中，第二个矩阵其实是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 7.错切变换(水平+垂直错切) 代码所输出的两个矩阵分别是： 其中，后者是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 8.对称变换(水平对称) 代码所输出的两个各矩阵分别是： 其中，后者是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 9.对称变换(垂直对称) 代码所输出的两个矩阵分别是： 其中，后者是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 10.对称变换(对称轴为直线y = x) 代码所输出的两个矩阵分别是： 其中，后者是下面两个矩阵相乘的结果： 大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 11.关于先乘和后乘的问题 由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例： 越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。 当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate()，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。","tags":[{"name":"Matrix","slug":"Matrix","permalink":"https://goghtsui.github.io/tags/Matrix/"}]},{"title":"Android Material Design入门","date":"2015-12-31T01:41:32.000Z","path":"2015/12/31/Android-Material-Design入门/undefined/","text":"原作者：Ravi Tamada原文地址：http://www.androidhive.info/…with-material-design/ 你可能听说了在Android Lollipop（棒棒糖）版本中有关Material Design的介绍。在Material Design中，介绍了许多新的东西，像Material主题、新的widget、自定义阴影、矢量图片和自定义动画。如果你还没有使用过Material Design，那么这篇文章会给你一个好的开始。 在这个教程中，我们将学习Material Design开发基础的步骤，比如编写自定义主题、使用RecyclerView实现导航抽屉。 通过下面的链接获取更多的关于Material Design的知识： Material Design SpecificationsCreating Apps with Material Design 本文资源链接： 源码下载：点击获取视频演示地址：Yutube 1. 下载Android Studio在进一步了解之前,下载Android Studio并且进行必须的设置，因为之后我将使用Android Studio做教程讲解。如果你是第一次尝试Android Studio，通过概述文档了一下Android Studio。 2. Material Design颜色自定义Material Design提供了一些其颜色主题的自定义属性，但是我们使用主要的五种，来自定义整个主题： colorPrimaryDark – 应用于通知栏的背景色 colorPrimary – 这是应用最主要的颜色，应用于toolbar的背景色 textColorPrimary – 这是文字的颜色，应用于toolbar的标题 windowBackground – 这是应用默认的背景色 navigationBarColor – 这个颜色定义了底部导航按钮的背景色 你可以通过Material Design颜色模型，去选择适合你应用的一套颜色 3. 创建 Material Design 主题1. 在Android Studio中，通过File ⇒ New Project`**并且填写其他需要的选项，来创建一个新的工程，当被提示选择默认的Activity时，选择Blank Activity**即可 2. 打开res ⇒ values ⇒ strings.xml并且添加以下文字： strings.xml &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Material Design&lt;/string&gt; &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt; &lt;string name=&quot;action_search&quot;&gt;Search&lt;/string&gt; &lt;string name=&quot;drawer_open&quot;&gt;Open&lt;/string&gt; &lt;string name=&quot;drawer_close&quot;&gt;Close&lt;/string&gt; &lt;string name=&quot;nav_item_home&quot;&gt;Home&lt;/string&gt; &lt;string name=&quot;nav_item_friends&quot;&gt;Friends&lt;/string&gt; &lt;string name=&quot;nav_item_notifications&quot;&gt;Messages&lt;/string&gt; &lt;!-- navigation drawer item labels --&gt; &lt;string-array name=&quot;nav_drawer_labels&quot;&gt; &lt;item&gt;@string/nav_item_home&lt;/item&gt; &lt;item&gt;@string/nav_item_friends&lt;/item&gt; &lt;item&gt;@string/nav_item_notifications&lt;/item&gt; &lt;/string-array&gt; &lt;string name=&quot;title_messages&quot;&gt;Messages&lt;/string&gt; &lt;string name=&quot;title_friends&quot;&gt;Friends&lt;/string&gt; &lt;string name=&quot;title_home&quot;&gt;Home&lt;/string&gt; &lt;/resources&gt; 3. 打开res ⇒ values ⇒ colors.xml并且添加以下颜色值，如果你没有找到colors.xml，就新建一个文件即可 colors.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#F50057&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#C51162&lt;/color&gt; &lt;color name=&quot;textColorPrimary&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;windowBackground&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;navigationBarColor&quot;&gt;#000000&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#FF80AB&lt;/color&gt; &lt;/resources&gt; 4. 打开res ⇒ values ⇒ dimens.xml并添加以下尺寸值 dimens.xml &lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name=&quot;activity_horizontal_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;activity_vertical_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;nav_drawer_width&quot;&gt;260dp&lt;/dimen&gt; &lt;/resources&gt; 5. 打开res ⇒ values ⇒ styles.xml并添加以下样式。这些样式适用于所有的安卓版本，这里我定义主题的名字为：MyMaterialTheme styles.xml &lt;resources&gt; &lt;style name=&quot;MyMaterialTheme&quot; parent=&quot;MyMaterialTheme.Base&quot;&gt; &lt;/style&gt; &lt;style name=&quot;MyMaterialTheme.Base&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 6. 在res下新建一个文件夹：values-v21，在这下面新建另外一个styles.xml天下一下样式，这些延时只适用于Android Lollipop版本 styles.xml &lt;resources&gt; &lt;style name=&quot;MyMaterialTheme&quot; parent=&quot;MyMaterialTheme.Base&quot;&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 7. 现在我们已经准备好了基本的Material Design样式，为了应用这个主题，打开AndroidManifest.xml并通过标签下的android:theme attribute of属性为应用设置该主题 android:theme=&quot;@style/MyMaterialTheme&quot; 在设置了该主题之后，你的AndroidManifest.xml应该是下面的样子： AndroidManifest.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;info.androidhive.materialdesign&quot; &gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/MyMaterialTheme&quot; &gt; &lt;activity android:name=&quot;.activity.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 现在运行你的应用，你可以看到通知栏的颜色已经是我们设置的样式的颜色了。 3.1 添加Toolbar(Action Bar) 添加toolbar是非常容易的，你需要做的就是，为toolbar创建一个单独的layout，在其他layout中需要显示的地方使用。 8. 新建一个xml文件res ⇒ layout ⇒ toolbar.xml并添加android.support.v7.widget.Toolbar控件，这个toolbar具有特定的宽度和主题 toolbar.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:local=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; local:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; local:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; 9. 打开主Activity的布局文件(activity_main.xml)，并通过&lt;include/&gt;来添加对toolbar的使用 activity_main.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include android:id=&quot;@+id/toolbar&quot; layout=&quot;@layout/toolbar&quot; /&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; 运行这个应用，并且看看toolbar是不是显示在屏幕上 现在让我们试着给toolbar添加标题和交互 10. 下载这个搜索图标，在Android Studio中通过Image Asset来引用它 11. 右键res ⇒ New ⇒ Image Asset，会显示一个弹窗来引入资源，找到你下载的搜索图标，Asset Type选择Action Bar and Tab Icons，并命名为ic_search_action 12. 图标导入完成之后，打开res ⇒ menu ⇒ menu_main.xml并且添加下面的搜索菜单： menu_main.xml &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:title=&quot;@string/action_search&quot; android:orderInCategory=&quot;100&quot; android:icon=&quot;@drawable/ic_action_search&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_settings&quot; android:title=&quot;@string/action_settings&quot; android:orderInCategory=&quot;100&quot; app:showAsAction=&quot;never&quot; /&gt; &lt;/menu&gt; 13. 现在打开MainActivity.java并且做如下修改： 1.继承的activity是AppCompatActivity 2.调用setSupportActionBar()并传递toolbar对象，以设置toolbar为可用状态 复写onCreateOptionsMenu()**和onOptionsItemSelected()**方法来设置toolbar的交互行为 MainActivity.java import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; public class MainActivity extends AppCompatActivity &#123; private Toolbar mToolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mToolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(mToolbar); getSupportActionBar().setDisplayShowHomeEnabled(true); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; &#125; 在做了以上修改之后，如果你运行应用，你应该能够在toolbar中看到搜索图标和更多菜单选项了 3.2 添加导航抽屉 添加导航抽屉，同样是按照之前lollipop的方式，但是如果菜单项使用列表视图，在Material design中要使用RecyclerView。因此让我们看看怎样实现RecyclerView导航抽屉。 14. 在你项目的java文件夹中，新建三个包：_activity_、_adapter_、_model_，并且把_MainActivity.java_移动到_activity_包下，这样来保证项目的条理性 15. 打开model下的build.gradle，添加下面的依赖，然后执行Build ⇒ Rebuild Project来下载必须的库 build.gradle dependencies &#123; compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) compile &#39;com.android.support:appcompat-v7:22.2.0&#39; compile &#39;com.android.support:recyclerview-v7:22.2.+&#39; &#125; 16. 在_model_包下，新建一个class文件，命名为NavDrawerItem.java，添加以下代码，这个class是一个实体类，它定义了导航抽屉里每一行的菜单项 NavDrawerItem.java package info.androidhive.materialdesign.model; /** * Created by Ravi on 29/07/15. */ public class NavDrawerItem &#123; private boolean showNotify; private String title; public NavDrawerItem() &#123; &#125; public NavDrawerItem(boolean showNotify, String title) &#123; this.showNotify = showNotify; this.title = title; &#125; public boolean isShowNotify() &#123; return showNotify; &#125; public void setShowNotify(boolean showNotify) &#123; this.showNotify = showNotify; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; &#125; 17. 在res ⇒ layout之下，新建一个布局文件，叫做nav_draw_row.xml添加以下代码。这个layout渲染的导航抽屉每一行的视图，如果你想要自定义导航抽屉菜单项，你应该修改这个文件，现在只有一个TextView nav_drawer_row.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:clickable=&quot;true&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;30dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:textSize=&quot;15dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/RelativeLayout&gt; 18. 下载这个个人信息的图标，并把它粘贴到drawable 文件夹下，这一步是可选的，但是这个图标在导航抽屉的header中有使用到 19. 新建一个layout命名fragment_navigation_drawer.xml，并且添加以下代码。这个layout呈现了整个导航抽屉的视图，它包含了头部部分，用于展示用户信息、RecyclerView来展示列表视图 fragment_navigation_drawer.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;RelativeLayout android:id=&quot;@+id/nav_header_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;140dp&quot; android:layout_alignParentTop=&quot;true&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;ImageView android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:src=&quot;@drawable/ic_profile&quot; android:scaleType=&quot;fitCenter&quot; android:layout_centerInParent=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/drawerList&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/nav_header_container&quot; android:layout_marginTop=&quot;15dp&quot; /&gt; &lt;/RelativeLayout&gt; 20. 因为RecyclerView是自定义的，我们需要一个adapter类去渲染自定义xml布局，因此，在adapter包下，创建一个适配器类NavigationDrawerAdapter.java，然后粘贴下面的代码。这个适配器类适配nav_drawer_row.xml布局并呈现RecycleView抽屉菜单 import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.Collections; import java.util.List; /** * Created by Ravi Tamada on 12-03-2015. */ public class NavigationDrawerAdapter extends RecyclerView.Adapter&lt;NavigationDrawerAdapter.MyViewHolder&gt; &#123; List&lt;NavDrawerItem&gt; data = Collections.emptyList(); private LayoutInflater inflater; private Context context; public NavigationDrawerAdapter(Context context, List&lt;NavDrawerItem&gt; data) &#123; this.context = context; inflater = LayoutInflater.from(context); this.data = data; &#125; public void delete(int position) &#123; data.remove(position); notifyItemRemoved(position); &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = inflater.inflate(R.layout.nav_drawer_row, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; NavDrawerItem current = data.get(position); holder.title.setText(current.getTitle()); &#125; @Override public int getItemCount() &#123; return data.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView title; public MyViewHolder(View itemView) &#123; super(itemView); title = (TextView) itemView.findViewById(R.id.title); &#125; &#125; &#125; 21. 在activity包下，新建一个fragment叫做FragmentDrawer.java。在Android Studio中，新建fragment：_右键activity ⇒ New ⇒ Fragment ⇒ Fragment (Blank)_，并且给出你的fragment的名称 FragmentDrawer.java /** * Created by Ravi on 29/07/15. */ import android.content.Context; import android.os.Bundle; import android.support.v4.app.Fragment; import android.support.v4.widget.DrawerLayout; import android.support.v7.app.ActionBarDrawerToggle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.Toolbar; import android.view.GestureDetector; import android.view.LayoutInflater; import android.view.MotionEvent; import android.view.View; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; import info.androidhive.materialdesign.R; import info.androidhive.materialdesign.adapter.NavigationDrawerAdapter; import info.androidhive.materialdesign.model.NavDrawerItem; public class FragmentDrawer extends Fragment &#123; private static String TAG = FragmentDrawer.class.getSimpleName(); private RecyclerView recyclerView; private ActionBarDrawerToggle mDrawerToggle; private DrawerLayout mDrawerLayout; private NavigationDrawerAdapter adapter; private View containerView; private static String[] titles = null; private FragmentDrawerListener drawerListener; public FragmentDrawer() &#123; &#125; public void setDrawerListener(FragmentDrawerListener listener) &#123; this.drawerListener = listener; &#125; public static List&lt;NavDrawerItem&gt; getData() &#123; List&lt;NavDrawerItem&gt; data = new ArrayList&lt;&gt;(); // preparing navigation drawer items for (int i = 0; i &lt; titles.length; i++) &#123; NavDrawerItem navItem = new NavDrawerItem(); navItem.setTitle(titles[i]); data.add(navItem); &#125; return data; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // drawer labels titles = getActivity().getResources().getStringArray(R.array.nav_drawer_labels); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflating view layout View layout = inflater.inflate(R.layout.fragment_navigation_drawer, container, false); recyclerView = (RecyclerView) layout.findViewById(R.id.drawerList); adapter = new NavigationDrawerAdapter(getActivity(), getData()); recyclerView.setAdapter(adapter); recyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); recyclerView.addOnItemTouchListener(new RecyclerTouchListener(getActivity(), recyclerView, new ClickListener() &#123; @Override public void onClick(View view, int position) &#123; drawerListener.onDrawerItemSelected(view, position); mDrawerLayout.closeDrawer(containerView); &#125; @Override public void onLongClick(View view, int position) &#123; &#125; &#125;)); return layout; &#125; public void setUp(int fragmentId, DrawerLayout drawerLayout, final Toolbar toolbar) &#123; containerView = getActivity().findViewById(fragmentId); mDrawerLayout = drawerLayout; mDrawerToggle = new ActionBarDrawerToggle(getActivity(), drawerLayout, toolbar, R.string.drawer_open, R.string.drawer_close) &#123; @Override public void onDrawerOpened(View drawerView) &#123; super.onDrawerOpened(drawerView); getActivity().invalidateOptionsMenu(); &#125; @Override public void onDrawerClosed(View drawerView) &#123; super.onDrawerClosed(drawerView); getActivity().invalidateOptionsMenu(); &#125; @Override public void onDrawerSlide(View drawerView, float slideOffset) &#123; super.onDrawerSlide(drawerView, slideOffset); toolbar.setAlpha(1 - slideOffset / 2); &#125; &#125;; mDrawerLayout.setDrawerListener(mDrawerToggle); mDrawerLayout.post(new Runnable() &#123; @Override public void run() &#123; mDrawerToggle.syncState(); &#125; &#125;); &#125; public static interface ClickListener &#123; public void onClick(View view, int position); public void onLongClick(View view, int position); &#125; static class RecyclerTouchListener implements RecyclerView.OnItemTouchListener &#123; private GestureDetector gestureDetector; private ClickListener clickListener; public RecyclerTouchListener(Context context, final RecyclerView recyclerView, final ClickListener clickListener) &#123; this.clickListener = clickListener; gestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onSingleTapUp(MotionEvent e) &#123; return true; &#125; @Override public void onLongPress(MotionEvent e) &#123; View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null &amp;&amp; clickListener != null) &#123; clickListener.onLongClick(child, recyclerView.getChildPosition(child)); &#125; &#125; &#125;); &#125; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; View child = rv.findChildViewUnder(e.getX(), e.getY()); if (child != null &amp;&amp; clickListener != null &amp;&amp; gestureDetector.onTouchEvent(e)) &#123; clickListener.onClick(child, rv.getChildPosition(child)); &#125; return false; &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; &#125; &#125; public interface FragmentDrawerListener &#123; public void onDrawerItemSelected(View view, int position); &#125; &#125; 22. 最后，打开首页activity的布局文件activity_main.xml，按照下面这样修改。在这个布局中，我们添加了android.support.v4.widget.DrawerLayout，来显示导航抽屉菜单 你也必须写出你的fragment下FragmentDrawer的正确路径 actiivty_main.xml &lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/container_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include android:id=&quot;@+id/toolbar&quot; layout=&quot;@layout/toolbar&quot; /&gt; &lt;/LinearLayout&gt; &lt;FrameLayout android:id=&quot;@+id/container_body&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/fragment_navigation_drawer&quot; android:name=&quot;info.androidhive.materialdesign.activity.FragmentDrawer&quot; android:layout_width=&quot;@dimen/nav_drawer_width&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:layout=&quot;@layout/fragment_navigation_drawer&quot; tools:layout=&quot;@layout/fragment_navigation_drawer&quot; /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 现在，我们已经准备好所有的layout和class，让我们在MainActivity中做一些必要的修改，使得导航抽屉可以正常运行 23. 打开MainActivity.java并且做如下修改 activity需要实现FragmentDrawer.FragmentDrawerListener并且复写onDrawerItemSelected()**方法 创建一个**FragmentDrawer的实例，并设置这个菜单选择的监听器 MainActivity.java import android.support.v4.widget.DrawerLayout; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; import android.view.View; public class MainActivity extends AppCompatActivity implements FragmentDrawer.FragmentDrawerListener &#123; private Toolbar mToolbar; private FragmentDrawer drawerFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mToolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(mToolbar); getSupportActionBar().setDisplayShowHomeEnabled(true); drawerFragment = (FragmentDrawer) getSupportFragmentManager().findFragmentById(R.id.fragment_navigation_drawer); drawerFragment.setUp(R.id.fragment_navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), mToolbar); drawerFragment.setDrawerListener(this); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; @Override public void onDrawerItemSelected(View view, int position) &#123; &#125; &#125; 现在，如果你运行这个应用，你能够看到这个导航抽屉，包含一个header和列表 androd-material-design-navigation-drawer 3.3 实现导航抽屉的选择事件尽管导航抽屉成功运行了，但是你看到菜单的点击事件没有正常运行，这是因为我们也需要实现RecyclerView的click监听事件 因为我们有三个菜单项（Home, Friends &amp; Messages）在导航抽屉中，因此我们需要创建三个独立的fragment类为每一个菜单 24. 在res下面，新建一个xml文件叫做fragment_home.xml并添加以下代码 fragment_home.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;info.androidhive.materialdesign.activity.HomeFragment&quot;&gt; &lt;TextView android:id=&quot;@+id/label&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:textSize=&quot;45dp&quot; android:text=&quot;HOME&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;TextView android:layout_below=&quot;@id/label&quot; android:layout_centerInParent=&quot;true&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;12dp&quot; android:layout_marginTop=&quot;10dp&quot; android:gravity=&quot;center_horizontal&quot; android:text=&quot;Edit fragment_home.xml to change the appearance&quot; /&gt; &lt;/RelativeLayout&gt; 25. 在activity包下，新建一个fragment类，叫做HomeFragment.java并且添加以下代码 HomeFragment.java import android.app.Activity; import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; public class HomeFragment extends Fragment &#123; public HomeFragment() &#123; // Required empty public constructor &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_home, container, false); // Inflate the layout for this fragment return rootView; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); &#125; @Override public void onDetach() &#123; super.onDetach(); &#125; &#125; 26. 新建两个fragment类分别叫做：FriendsFragment.java、MessagesFragment.java，同样新建两个xml：fragment_friends.xml、fragment_messages.xml，按照上面步骤添加代码 27. 现在打开MainActivity.java，做以下修改 _displayView()_方法显示fragment，这个方法在**onDrawerItemSelected()**中被调用，当菜单被选择的时候，来渲染对应的布局 MainActivity.java import android.os.Bundle; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentTransaction; import android.support.v4.widget.DrawerLayout; import android.support.v7.app.ActionBarActivity; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Toast; public class MainActivity extends ActionBarActivity implements FragmentDrawer.FragmentDrawerListener &#123; private static String TAG = MainActivity.class.getSimpleName(); private Toolbar mToolbar; private FragmentDrawer drawerFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mToolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(mToolbar); getSupportActionBar().setDisplayShowHomeEnabled(true); drawerFragment = (FragmentDrawer) getSupportFragmentManager().findFragmentById(R.id.fragment_navigation_drawer); drawerFragment.setUp(R.id.fragment_navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), mToolbar); drawerFragment.setDrawerListener(this); // display the first navigation drawer view on app launch displayView(0); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; if(id == R.id.action_search)&#123; Toast.makeText(getApplicationContext(), &quot;Search action is selected!&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item); &#125; @Override public void onDrawerItemSelected(View view, int position) &#123; displayView(position); &#125; private void displayView(int position) &#123; Fragment fragment = null; String title = getString(R.string.app_name); switch (position) &#123; case 0: fragment = new HomeFragment(); title = getString(R.string.title_home); break; case 1: fragment = new FriendsFragment(); title = getString(R.string.title_friends); break; case 2: fragment = new MessagesFragment(); title = getString(R.string.title_messages); break; default: break; &#125; if (fragment != null) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.container_body, fragment); fragmentTransaction.commit(); // set the toolbar title getSupportActionBar().setTitle(title); &#125; &#125; &#125; 现在再来运行你的应用，你能够看到导航抽屉菜单的选择事件可以正常实现，并且对应的布局显示在toolbar下面","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://goghtsui.github.io/tags/Material-Design/"}]},{"title":"Android Material Design - Floating Labels for EditText","date":"2015-12-30T02:42:59.000Z","path":"2015/12/30/Android-Material-Design-Floating-Labels-for-EditText/undefined/","text":"原文作者：Ravi Tamada原文地址：http://www.androidhive.info/…aterial-design/ Android浮动标签在android设计支持库有介绍，在EditText上显示一个悬浮的标签。最初它在EditText中作为字段为空时的一个提示。当用户开始输入文本，它通过一个动画的形式，移动到悬浮标签的位置。 这篇文章通过一个简单的表单验证的例子，演示了Floating Lables的用法。 源码下载地址：http://download.androidhive.info/…dfyJJ0xyaJTvXugo0HTV0LBnG9w视频演示地址：yutube-display TextInputLayout在Material Design支持库中一个新的元素，叫作TextInputLayout，用于在EditText上展示悬浮标签。为了显示悬浮标签，EditText被TextInputLayout所包裹。你也可以给EditText设置一个错误的信息，通过使用setErrorEnabled()和setError()方法。 TextInputLayout采用了EditTextandroid:hint属性的值来作为悬浮标签显示。 &lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/input_layout_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/input_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;@string/hint_email&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 简单的表单验证示例现在让我们来创建一个简单的android应用，去真正的了解TextInputLayout的用法。这个应用包含了一个带有悬浮标签的简答表单，输入验证和错误信息启用。 1. 在Android Studio中，通过File ⇒ New Project并填好其它信息来新建一个项目。 2. 打开build.gradle并且添加Material Design支持库的依赖。 com.android.support:design:23.0.1 build.gradle dependencies &#123; compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) compile &#39;com.android.support:appcompat-v7:23.0.1&#39; compile &#39;com.android.support:design:23.0.1&#39; &#125; 3. 通过这里提到的步骤，应用Material Design主题，但这不是必须的。 4. 添加下面字符串到res ⇒ values =&gt; strings.xml下面。 strings.xml &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Floating Labels&lt;/string&gt; &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt; &lt;string name=&quot;hint_name&quot;&gt;Full Name&lt;/string&gt; &lt;string name=&quot;hint_email&quot;&gt;Email&lt;/string&gt; &lt;string name=&quot;hint_password&quot;&gt;Password&lt;/string&gt; &lt;string name=&quot;btn_sign_up&quot;&gt;Sign Up&lt;/string&gt; &lt;string name=&quot;err_msg_name&quot;&gt;Enter your full name&lt;/string&gt; &lt;string name=&quot;err_msg_email&quot;&gt;Enter valid email address&lt;/string&gt; &lt;string name=&quot;err_msg_password&quot;&gt;Enter the password&lt;/string&gt; &lt;/resources&gt; 5. 打开主activity的activity_main.xml布局文件，然后添加如下代码。这些代码创建了一个简单的表单，有三个输入框。这里你可以看到EditText被TextInputLayout所包裹。 activity_main.xml &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginTop=&quot;?attr/actionBarSize&quot; android:orientation=&quot;vertical&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; android:paddingTop=&quot;60dp&quot;&gt; &lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/input_layout_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/input_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:hint=&quot;@string/hint_name&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/input_layout_email&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/input_email&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;textEmailAddress&quot; android:hint=&quot;@string/hint_email&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/input_layout_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/input_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;textPassword&quot; android:hint=&quot;@string/hint_password&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;Button android:id=&quot;@+id/btn_signup&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/btn_sign_up&quot; android:background=&quot;@color/colorPrimary&quot; android:layout_marginTop=&quot;40dp&quot; android:textColor=&quot;@android:color/white&quot;/&gt; &lt;/LinearLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 6. 打开MainActivity.java并且按照以下代码修改，这里我已经添加了一些方法去验证用户的输入数据比如名字、email、密码。我也. 我也指定了TextWatcher给所有的edittext来验证用户正在输入的内容，当输入无效或者为空时，setError()方法就会被调用来显示错误信息。 MainActivity.java package info.androidhive.floatinglabels; import android.os.Bundle; import android.support.design.widget.TextInputLayout; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.text.Editable; import android.text.TextUtils; import android.text.TextWatcher; import android.view.View; import android.view.WindowManager; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; public class MainActivity extends AppCompatActivity &#123; private Toolbar toolbar; private EditText inputName, inputEmail, inputPassword; private TextInputLayout inputLayoutName, inputLayoutEmail, inputLayoutPassword; private Button btnSignUp; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); inputLayoutName = (TextInputLayout) findViewById(R.id.input_layout_name); inputLayoutEmail = (TextInputLayout) findViewById(R.id.input_layout_email); inputLayoutPassword = (TextInputLayout) findViewById(R.id.input_layout_password); inputName = (EditText) findViewById(R.id.input_name); inputEmail = (EditText) findViewById(R.id.input_email); inputPassword = (EditText) findViewById(R.id.input_password); btnSignUp = (Button) findViewById(R.id.btn_signup); inputName.addTextChangedListener(new MyTextWatcher(inputName)); inputEmail.addTextChangedListener(new MyTextWatcher(inputEmail)); inputPassword.addTextChangedListener(new MyTextWatcher(inputPassword)); btnSignUp.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; submitForm(); &#125; &#125;); &#125; /** * Validating form */ private void submitForm() &#123; if (!validateName()) &#123; return; &#125; if (!validateEmail()) &#123; return; &#125; if (!validatePassword()) &#123; return; &#125; Toast.makeText(getApplicationContext(), &quot;Thank You!&quot;, Toast.LENGTH_SHORT).show(); &#125; private boolean validateName() &#123; if (inputName.getText().toString().trim().isEmpty()) &#123; inputLayoutName.setError(getString(R.string.err_msg_name)); requestFocus(inputName); return false; &#125; else &#123; inputLayoutName.setErrorEnabled(false); &#125; return true; &#125; private boolean validateEmail() &#123; String email = inputEmail.getText().toString().trim(); if (email.isEmpty() || !isValidEmail(email)) &#123; inputLayoutEmail.setError(getString(R.string.err_msg_email)); requestFocus(inputEmail); return false; &#125; else &#123; inputLayoutEmail.setErrorEnabled(false); &#125; return true; &#125; private boolean validatePassword() &#123; if (inputPassword.getText().toString().trim().isEmpty()) &#123; inputLayoutPassword.setError(getString(R.string.err_msg_password)); requestFocus(inputPassword); return false; &#125; else &#123; inputLayoutPassword.setErrorEnabled(false); &#125; return true; &#125; private static boolean isValidEmail(String email) &#123; return !TextUtils.isEmpty(email) &amp;&amp; android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches(); &#125; private void requestFocus(View view) &#123; if (view.requestFocus()) &#123; getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE); &#125; &#125; private class MyTextWatcher implements TextWatcher &#123; private View view; private MyTextWatcher(View view) &#123; this.view = view; &#125; public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; public void afterTextChanged(Editable editable) &#123; switch (view.getId()) &#123; case R.id.input_name: validateName(); break; case R.id.input_email: validateEmail(); break; case R.id.input_password: validatePassword(); break; &#125; &#125; &#125; &#125;","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://goghtsui.github.io/tags/Material-Design/"},{"name":"EditText","slug":"EditText","permalink":"https://goghtsui.github.io/tags/EditText/"},{"name":"Floating Lables","slug":"Floating-Lables","permalink":"https://goghtsui.github.io/tags/Floating-Lables/"}]},{"title":"Android Material Design - Tabs","date":"2015-12-28T03:51:06.000Z","path":"2015/12/28/Android-Material-Design-Tabs/undefined/","text":"原作者：Ravi Tamada原文地址：http://www.androidhive.info/2015/09/android-material-design-working-with-tabs/ Android Design支持库 提供了很好的向后兼容性，在Material Design支持库中的组件中，像Navigation Drawer, FloatingAction Button, Snackbar, Tabs, Floating labels ， animation frameworks。在这里我们将学习怎样实现tabs。 在进一步深入了解之前，我建议先看一下tabs的文档，它可以告诉你在实现tabs的时候，什么该做什么不该做。 这里还有yutube的视频：到墙外看一看 使用Material首先我们创建一个新的项目并且应用Material主题，如果你不知道Material Design，那么可以看看文章Material Design入门 1.在Android Studio中，File =&gt; New Project并且填好其它信息去创建一个新项目。 2.打开build.gradle然后添加支持库com.android.support:design:23.0.1 build.gradle dependencies &#123; compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) compile &#39;com.android.support:appcompat-v7:23.0.1&#39; compile &#39;com.android.support:design:23.0.1&#39; &#125; 3.打开位于res =&gt; values下的colors.xml，并且添加以下颜色值： colors.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#125688&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#125688&lt;/color&gt; &lt;color name=&quot;textColorPrimary&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;windowBackground&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;navigationBarColor&quot;&gt;#000000&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#c8e8ff&lt;/color&gt; &lt;/resources&gt; 4.在res =&gt; values下的dimens.xml添加以下代码： dimens.xml &lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name=&quot;activity_horizontal_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;activity_vertical_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;tab_max_width&quot;&gt;264dp&lt;/dimen&gt; &lt;dimen name=&quot;tab_padding_bottom&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;tab_label&quot;&gt;14sp&lt;/dimen&gt; &lt;dimen name=&quot;custom_tab_layout_height&quot;&gt;72dp&lt;/dimen&gt; &lt;/resources&gt; 5. 打开res ⇒ values下的styles.xml，并添加以下主题。在styles.xml中这个主题是通用于所有安卓版本的。 styles.xml &lt;resources&gt; &lt;style name=&quot;MyMaterialTheme&quot; parent=&quot;MyMaterialTheme.Base&quot;&gt; &lt;/style&gt; &lt;style name=&quot;MyMaterialTheme.Base&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 6. 在res下面创建values-v21文件夹，然后创建另外一个styles.xml，写入以下主题，这个主题是适用于Android 5.0的。 styles.xml &lt;resources&gt; &lt;style name=&quot;MyMaterialTheme&quot; parent=&quot;MyMaterialTheme.Base&quot;&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 7. 最后打开AndroidManifest.xml并且修改android:theme属性为我们自定义的主题。 AndroidManifest.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;info.androidhive.materialtabs&quot; &gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/MyMaterialTheme&quot; &gt; &lt;activity android:name=&quot;.activity.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 运行这个应用，通过通知栏的颜色来验证一下Material Design主题。如果你看到通知栏颜色改变了，这就意味着Material Design主题已经被成功使用。 图例 现在我们已经有了Material Design主题的应用，接下来让我们开始添加tabs。但是在这之前。我们需要创建一些fragment来协助测试，所有这些fragment只有非常简单的UI，一个TextView而已。 8. 在你的包目录下，创建一个fragment，命名为OneFragment.java并添加以下代码： OneFragment.java package info.androidhive.materialtabs.fragments; import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import info.androidhive.materialtabs.R; public class OneFragment extends Fragment&#123; public OneFragment() &#123; // Required empty public constructor &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_one, container, false); &#125; &#125; 9. 在res ⇒ layout下添加fragment_one.xml，写入以下代码： fragment_one.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;info.androidhive.materialtabs.fragments.OneFragment&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/one&quot; android:textSize=&quot;40dp&quot; android:textStyle=&quot;bold&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;/RelativeLayout&gt; 10. 同样的，创建一些其它的fragment，并且写入像OneFragment.java一样的代码，我已经创建好了TwoFragment.java, ThreeFragment.java, FourFragemnt.java一直到TenFragment.java 固定标签当tabs是固定数目的时候，你可以使用这个方式。这些tabs固定在适当的位置。在design支持库中，一些新的元素像CoordinatorLayout、AppBarLayout、TabLayout等介绍了很多。我覆盖不到所有的情况，因为这不是本文的目的。 11. 打开布局文件activity_main.xml并修改为一下代码： app:tabMode – 定义tab的形式，在这我们定义为fixed activity_main.xml &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabMode=&quot;fixed&quot; app:tabGravity=&quot;fill&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 12. 打开MainActivity.java 并作以下修改： tabLayout.setupWithViewPager() – 适配ViewPager给TabLayout setupViewPager() – 通过添加适当的fragment来设置tabs的数量和tab的名字 ViewPagerAdapter – 自定义适配器类提供了ViewPager需要的额fragment MainActivity.java package info.androidhive.materialtabs.activity; import android.os.Bundle; import android.support.design.widget.TabLayout; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentPagerAdapter; import android.support.v4.view.ViewPager; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import java.util.ArrayList; import java.util.List; import info.androidhive.materialtabs.R; import info.androidhive.materialtabs.fragments.OneFragment; import info.androidhive.materialtabs.fragments.ThreeFragment; import info.androidhive.materialtabs.fragments.TwoFragment; public class MainActivity extends AppCompatActivity &#123; private Toolbar toolbar; private TabLayout tabLayout; private ViewPager viewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); viewPager = (ViewPager) findViewById(R.id.viewpager); setupViewPager(viewPager); tabLayout = (TabLayout) findViewById(R.id.tabs); tabLayout.setupWithViewPager(viewPager); &#125; private void setupViewPager(ViewPager viewPager) &#123; ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFragment(new OneFragment(), &quot;ONE&quot;); adapter.addFragment(new TwoFragment(), &quot;TWO&quot;); adapter.addFragment(new ThreeFragment(), &quot;THREE&quot;); viewPager.setAdapter(adapter); &#125; class ViewPagerAdapter extends FragmentPagerAdapter &#123; private final List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;(); private final List&lt;String&gt; mFragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager manager) &#123; super(manager); &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; public void addFragment(Fragment fragment, String title) &#123; mFragmentList.add(fragment); mFragmentTitleList.add(title); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mFragmentTitleList.get(position); &#125; &#125; &#125; 现在运行这个应用，你应该能看到tabs已经显示，并且能够通过滑动在他们之间切换。 2.1 屏幕宽度的标签如果你想要标签栏占据整个屏幕的宽度，你需要给TabLayout设置 **app:tabGravity=”fill”**属性。 2.2 中心对齐的标签如果你想要你的标签按照水平居中的形式来显示，你需要给TabLayout设置**app:tabGravity=”center”**的属性。 滚动标签当你有很多标签时，并且一个屏幕的空间放不下的时候，你可以使用滑动标签。标签可以滚动，给TabLayout设置**app:tabMode=”scrollable”**即可。 13. 打开activity_main.xml并且修改app:tabMode为scrollable。 &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabMode=&quot;scrollable&quot;/&gt; 14. 编辑MainActivity.java并且添加一些fragment到ViewPager通过**setupViewPager()**方法。我已经添加了10个fragment，这样做之后，你的MainActivity应该像下面这样。 MainActivity.java package info.androidhive.materialtabs.activity; import android.os.Bundle; import android.support.design.widget.TabLayout; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentPagerAdapter; import android.support.v4.view.ViewPager; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity &#123; private Toolbar toolbar; private TabLayout tabLayout; private ViewPager viewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); viewPager = (ViewPager) findViewById(R.id.viewpager); setupViewPager(viewPager); tabLayout = (TabLayout) findViewById(R.id.tabs); tabLayout.setupWithViewPager(viewPager); &#125; private void setupViewPager(ViewPager viewPager) &#123; ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFrag(new OneFragment(), &quot;ONE&quot;); adapter.addFrag(new TwoFragment(), &quot;TWO&quot;); adapter.addFrag(new ThreeFragment(), &quot;THREE&quot;); adapter.addFrag(new FourFragment(), &quot;FOUR&quot;); adapter.addFrag(new FiveFragment(), &quot;FIVE&quot;); adapter.addFrag(new SixFragment(), &quot;SIX&quot;); adapter.addFrag(new SevenFragment(), &quot;SEVEN&quot;); adapter.addFrag(new EightFragment(), &quot;EIGHT&quot;); adapter.addFrag(new NineFragment(), &quot;NINE&quot;); adapter.addFrag(new TenFragment(), &quot;TEN&quot;); viewPager.setAdapter(adapter); &#125; class ViewPagerAdapter extends FragmentPagerAdapter &#123; private final List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;(); private final List&lt;String&gt; mFragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager manager) &#123; super(manager); &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; public void addFrag(Fragment fragment, String title) &#123; mFragmentList.add(fragment); mFragmentTitleList.add(title); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mFragmentTitleList.get(position); &#125; &#125; &#125; 现在如果你再运行你的应用，你就可以看到很多tabs，而且具有欢动功能。 图文标签有时候你可能想要给标签添加图标。此前给标签添加图标是非常繁琐的过程，但是现在有了Material Design支持库，这就变得很容易了。所以你必须要做的就是调用**setIcon()**方法来设置适当的图标，这个图标就可以显示在标签文字前面了。 tabLayout.getTabAt(0).setIcon(tabIcons[0]); tabLayout.getTabAt(1).setIcon(tabIcons[1]); 15. 打开MainActivity.java并且按照下面来修改代码。在这里我已经添加了一个新的方法**setupTabIcons()**来设置标签的图标。 MainActivity.java import android.os.Bundle; import android.support.design.widget.TabLayout; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentPagerAdapter; import android.support.v4.view.ViewPager; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity &#123; private Toolbar toolbar; private TabLayout tabLayout; private ViewPager viewPager; private int[] tabIcons = &#123; R.drawable.ic_tab_favourite, R.drawable.ic_tab_call, R.drawable.ic_tab_contacts &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); viewPager = (ViewPager) findViewById(R.id.viewpager); setupViewPager(viewPager); tabLayout = (TabLayout) findViewById(R.id.tabs); tabLayout.setupWithViewPager(viewPager); setupTabIcons(); &#125; private void setupTabIcons() &#123; tabLayout.getTabAt(0).setIcon(tabIcons[0]); tabLayout.getTabAt(1).setIcon(tabIcons[1]); tabLayout.getTabAt(2).setIcon(tabIcons[2]); &#125; private void setupViewPager(ViewPager viewPager) &#123; ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFrag(new OneFragment(), &quot;ONE&quot;); adapter.addFrag(new TwoFragment(), &quot;TWO&quot;); adapter.addFrag(new ThreeFragment(), &quot;THREE&quot;); viewPager.setAdapter(adapter); &#125; class ViewPagerAdapter extends FragmentPagerAdapter &#123; private final List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;(); private final List&lt;String&gt; mFragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager manager) &#123; super(manager); &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; public void addFrag(Fragment fragment, String title) &#123; mFragmentList.add(fragment); mFragmentTitleList.add(title); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mFragmentTitleList.get(position); &#125; &#125; &#125; 图标标签仅仅设置图标的选项卡是和图文的选项卡是一样的，只是ViewPagerAdapter类的**getPageTitle()**方法返回值为null即可。 16. 打开MainActivity.java并按照下面的代码修改**getPageTitle()**方法，接着运行项目。 @Override public CharSequence getPageTitle(int position) &#123; // return null to display only the icon return null; &#125; 自定义图文选项卡当默认的选项卡布局不能达到你预期的输出效果时，自定义选项卡就非常实用了。在你自定义选项卡试图的时候，请务必遵循Android选项卡的规范建议。 当我们设置了图文选项卡时，你能够看到图标和文字是水平居中的，但是如果你想要放置图标在选项卡标签之上，你就必须使用一个自定义的view来完成它。 17. 在res ⇒ values下面,创建fonts.xml文件，并且添加以下字符串值。这个xml文件定义了选项卡中文字所使用的字体。 fonts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string name=&quot;font_fontFamily_medium&quot;&gt;sans-serif&lt;/string&gt; &lt;/resources&gt; 18. 在res ⇒ values-v21下面，创建另一个fonts.xml**文件。 fonts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string name=&quot;font_fontFamily_medium&quot;&gt;sans-serif-medium&lt;/string&gt; &lt;/resources&gt; 19. 打开activity_main.xml并且给TabLayout设置自定义的高度。设置这个高度显得非常重要，因为在选项卡标签上面放置图标需要更多的空间。 &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/custom_tab_layout_height&quot; app:tabMode=&quot;fixed&quot; app:tabGravity=&quot;fill&quot;/&gt; 20. 在res ⇒ layout下新建的一个xml文件custom_tab.xml，这个文件是用来自定义选项卡布局的。 custom_tab.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/tab&quot; android:textColor=&quot;@color/colorAccent&quot; android:textSize=&quot;@dimen/tab_label&quot; android:fontFamily=&quot;@string/font_fontFamily_medium&quot;/&gt; 21. 打开MainActivity.java并按照下面的代码做修改。这里你是否注意到setupTabIcon()方法。下面的代码中我已经给每一个选项卡使用了custom_tab.xml布局，。 TextView tabOne = (TextView) LayoutInflater.from(this).inflate(R.layout.custom_tab, null); tabOne.setText(&quot;ONE&quot;); tabOne.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_tab_favourite, 0, 0); tabLayout.getTabAt(0).setCustomView(tabOne); MainActivity.java import android.os.Bundle; import android.support.design.widget.TabLayout; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentPagerAdapter; import android.support.v4.view.ViewPager; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.LayoutInflater; import android.widget.TextView; import java.util.ArrayList; import java.util.List; import info.androidhive.materialtabs.R; import info.androidhive.materialtabs.fragments.OneFragment; import info.androidhive.materialtabs.fragments.ThreeFragment; import info.androidhive.materialtabs.fragments.TwoFragment; public class MainActivity extends AppCompatActivity &#123; private Toolbar toolbar; private TabLayout tabLayout; private ViewPager viewPager; private int[] tabIcons = &#123; R.drawable.ic_tab_favourite, R.drawable.ic_tab_call, R.drawable.ic_tab_contacts &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); viewPager = (ViewPager) findViewById(R.id.viewpager); setupViewPager(viewPager); tabLayout = (TabLayout) findViewById(R.id.tabs); tabLayout.setupWithViewPager(viewPager); setupTabIcons(); &#125; private void setupTabIcons() &#123; TextView tabOne = (TextView) LayoutInflater.from(this).inflate(R.layout.custom_tab, null); tabOne.setText(&quot;ONE&quot;); tabOne.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_tab_favourite, 0, 0); tabLayout.getTabAt(0).setCustomView(tabOne); TextView tabTwo = (TextView) LayoutInflater.from(this).inflate(R.layout.custom_tab, null); tabTwo.setText(&quot;TWO&quot;); tabTwo.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_tab_call, 0, 0); tabLayout.getTabAt(1).setCustomView(tabTwo); TextView tabThree = (TextView) LayoutInflater.from(this).inflate(R.layout.custom_tab, null); tabThree.setText(&quot;THREE&quot;); tabThree.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_tab_contacts, 0, 0); tabLayout.getTabAt(2).setCustomView(tabThree); &#125; private void setupViewPager(ViewPager viewPager) &#123; ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFrag(new OneFragment(), &quot;ONE&quot;); adapter.addFrag(new TwoFragment(), &quot;TWO&quot;); adapter.addFrag(new ThreeFragment(), &quot;THREE&quot;); viewPager.setAdapter(adapter); &#125; class ViewPagerAdapter extends FragmentPagerAdapter &#123; private final List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;(); private final List&lt;String&gt; mFragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager manager) &#123; super(manager); &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; public void addFrag(Fragment fragment, String title) &#123; mFragmentList.add(fragment); mFragmentTitleList.add(title); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mFragmentTitleList.get(position); &#125; &#125; &#125; 现在如果你运行这个程序，你就能看到图标被放置在选项卡标签的上面了。 我希望这篇文章对于Material Design支持库的使用，提供了一些非常有用的信息，如果你有任何问题，请在下面回复。","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://goghtsui.github.io/tags/Material-Design/"},{"name":"TabLayout","slug":"TabLayout","permalink":"https://goghtsui.github.io/tags/TabLayout/"}]},{"title":"Android Material Design - Snackbar","date":"2015-12-24T08:49:57.000Z","path":"2015/12/24/Android-Material-Design-Snackbar/undefined/","text":"原作者：Ravi Tamada原文地址：http://www.androidhive.info/…example/ Material Design中一个有趣的组件介绍就是**Snackbar。Snackbar就像Toast**消息，只是它提供了动作交互。Snackbar在屏幕底部显示，并且可以滑动关闭。 这篇文章讲述的是关于Snackbar和一些不同场景下的例子。 源码下载戳我下载 1.简单的Snackbar下面是一个简单的Snackbar语法。make方法接收三个参数：View、显示的信息、消息显示的持续时间。 通常传递 CoordinatorLayout 作为view参数是最好的选择，因为它允许Snackbar一些特性，像滑动取消、像FloatingActionButton控件的自动移动。 并且显示的持续时间应该是LENGTH_SHORT, LENGTH_LONG或者LENGTH_INDEFINITE。当LENGTH_INDEFINITE被使用时，snackbar显示的时间将是不确定的，而且可以滑动删除。 Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;Welcome to AndroidHive&quot;, Snackbar.LENGTH_LONG); snackbar.show(); 2.Snackbar与动作回调你也可以使用一个回调方法_setAction()_，使得它可以和我们有一些动作交互。 Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;Message is deleted&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;UNDO&quot;, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar1 = Snackbar.make(coordinatorLayout, &quot;Message is restored!&quot;, Snackbar.LENGTH_SHORT); snackbar1.show(); &#125; &#125;); snackbar.show(); 3.自定义SnackbarSnackbar默认文字颜色 white、默认背景是 #323232。你可以按照下面的方式修改： Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;No internet connection!&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;RETRY&quot;, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125; &#125;); // Changing message text color snackbar.setActionTextColor(Color.RED); // Changing action button text color View sbView = snackbar.getView(); TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text); textView.setTextColor(Color.YELLOW); snackbar.show(); 4.创建新项目现在我们创建一个demo来看看Snackbar动作，而且应用用CoordinatorLayout **和FloatingActionButton**。 1.在Android Studio中，执行File =&gt; New Project，然后填上所有的信息来创建一个新工程。 2.打开Build.gradle然后添加库的依赖build.gradle dependencies &#123; compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) compile &#39;com.android.support:appcompat-v7:23.0.1&#39; compile &#39;com.android.support:design:23.0.1&#39; &#125; 3.可选项，你可以应用material design的主题，通过这里的步骤。 4.打开布局文件，然后我添加了以下代码，是包含CoordinatorLayout、FloatingActionButton。 activity_main.xml &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/coordinatorLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;Button android:id=&quot;@+id/btnSimpleSnackbar&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;30dp&quot; android:text=&quot;Simple Snackbar&quot; /&gt; &lt;Button android:id=&quot;@+id/btnActionCallback&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;With Action Callback&quot; /&gt; &lt;Button android:id=&quot;@+id/btnCustomSnackbar&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;Custom Color&quot; /&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@android:drawable/ic_dialog_email&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 5.现在打开MainActivity.java然后按照下面的修改，这个activity包含了三个按钮及点击事件，实现了上面提到的不同样式的Snackbar。 MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.design.widget.CoordinatorLayout; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity &#123; private Toolbar mToolbar; private CoordinatorLayout coordinatorLayout; private Button btnSimpleSnackbar, btnActionCallback, btnCustomView; private FloatingActionButton fab; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); coordinatorLayout = (CoordinatorLayout) findViewById(R.id .coordinatorLayout); fab = (FloatingActionButton) findViewById(R.id.fab); mToolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(mToolbar); btnSimpleSnackbar = (Button) findViewById(R.id.btnSimpleSnackbar); btnActionCallback = (Button) findViewById(R.id.btnActionCallback); btnCustomView = (Button) findViewById(R.id.btnCustomSnackbar); btnSimpleSnackbar.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;Welcome to AndroidHive&quot;, Snackbar.LENGTH_LONG); snackbar.show(); &#125; &#125;); btnActionCallback.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;Message is deleted&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;UNDO&quot;, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar1 = Snackbar.make(coordinatorLayout, &quot;Message is restored!&quot;, Snackbar.LENGTH_SHORT); snackbar1.show(); &#125; &#125;); snackbar.show(); &#125; &#125;); btnCustomView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar = Snackbar .make(coordinatorLayout, &quot;No internet connection!&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;RETRY&quot;, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125; &#125;); // Changing message text color snackbar.setActionTextColor(Color.RED); // Changing action button text color View sbView = snackbar.getView(); TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text); textView.setTextColor(Color.YELLOW); snackbar.show(); &#125; &#125;); &#125; &#125; 6.运行这个项目，可以测试这几种效果。","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://goghtsui.github.io/tags/Material-Design/"},{"name":"Snackbar","slug":"Snackbar","permalink":"https://goghtsui.github.io/tags/Snackbar/"}]},{"title":"Parcelable vs Serializable","date":"2015-12-24T07:49:15.000Z","path":"2015/12/24/Parcelable-vs-Serializable/undefined/","text":"序论在Android中，我们需要传递对象的引用在activity和fragment之间，因此我们不得不放在Intent/Bundle中。 通过api我们了解到有两种选择，可以使用对象的**Parcelable或者Serializable**形式，作为Java的开发者，我们已经知道Serializable机制，那么为什么还有Parcelable？ 要回答这个问题，先让我们看看这两个方法。 Serializable，简单之主// access modifiers, accessors and constructors omitted for brevity public class SerializableDeveloper implements Serializable String name; int yearsOfExperience; List&lt;Skill&gt; skillSet; float favoriteFloat; static class Skill implements Serializable &#123; String name; boolean programmingRelated; &#125; &#125; Serializable的美在于你只需要将类和他的子类实现Serializable接口，这是一个标记接口，意味着没有方法来实现，Java可以简单有效的实现它的序列化。 这个方法的问题是，他使用到了反射，并且它是一个缓慢的进程。正是这个机制，创造了大量的临时对象，并且造成大量的gc。 Parcelable, 速度之王// access modifiers, accessors and regular constructors ommited for brevity class ParcelableDeveloper implements Parcelable &#123; String name; int yearsOfExperience; List&lt;Skill&gt; skillSet; float favoriteFloat; ParcelableDeveloper(Parcel in) &#123; this.name = in.readString(); this.yearsOfExperience = in.readInt(); this.skillSet = new ArrayList&lt;Skill&gt;(); in.readTypedList(skillSet, Skill.CREATOR); this.favoriteFloat = in.readFloat(); &#125; void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(yearsOfExperience); dest.writeTypedList(skillSet); dest.writeFloat(favoriteFloat); &#125; int describeContents() &#123; return 0; &#125; static final Parcelable.Creator&lt;ParcelableDeveloper&gt; CREATOR = new Parcelable.Creator&lt;ParcelableDeveloper&gt;() &#123; ParcelableDeveloper createFromParcel(Parcel in) &#123; return new ParcelableDeveloper(in); &#125; ParcelableDeveloper[] newArray(int size) &#123; return new ParcelableDeveloper[size]; &#125; &#125;; static class Skill implements Parcelable &#123; String name; boolean programmingRelated; Skill(Parcel in) &#123; this.name = in.readString(); this.programmingRelated = (in.readInt() == 1); &#125; @Override void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(programmingRelated ? 1 : 0); &#125; static final Parcelable.Creator&lt;Skill&gt; CREATOR = new Parcelable.Creator&lt;Skill&gt;() &#123; Skill createFromParcel(Parcel in) &#123; return new Skill(in); &#125; Skill[] newArray(int size) &#123; return new Skill[size]; &#125; &#125;; @Override int describeContents() &#123; return 0; &#125; &#125; &#125; 根据**google engineers**，这段代码明显运行的很快。其中一个原因就是，我们明确实例化的进程，而不是使用反射来推断它。支撑他的另一个原因就是，它也为此目的做了大量的优化。 无论怎样，可以明显的看出实现Parcelable不是免费的，他会有大量的样板代码，并且是类很难阅读和维护。 速度测试当然，我们想要知道Parcelable有多快。 方法论 1.模拟传递对象给activity的过程，通过将一个对象放入bundle并调用**[Bundle#writeToParcel(Parcel,int)](https://developer.android.com/intl/zh-cn/reference/android/os/Bundle.html#writeToParcel(android.os.Parcel, int)**，然后取出来。 2.循环执行1000次 3.取10次独立运行的内存占用平均值，其他应用使用这个cpu 4.被测试对象是上面展示的SerializableDeveloper和ParcelableDeveloper 5.在多个设备上测试 - android版本 LG Nexus 4 - Android 4.2.2 Samsung Nexus 10 - Android 4.2.2 HTC Desire Z - Android 2.3.3 结果Nexus 10 Serializable: 1.0004ms, Parcelable: 0.0850ms - 10.16x improvement. Nexus 4 Serializable: 1.8539ms - Parcelable: 0.1824ms - 11.80x improvement. Desire Z Serializable: 5.1224ms - Parcelable: 0.2938ms - 17.36x improvement. 想必你已经知道了，Parcelable比Serializable快了10倍。 本质如果你想要成为一个好公民，那就花费更多的时间来实现**Parcelable**，因为这将快10倍的速度，而且占用更少的资源。 然而，在大部分情况下，**Serializable**的慢并不是很明显，你可以随意使用它，但是记住，序列化是一个昂贵的操作，它将保持在一个低速状态。 如果你正在传递上千的序列化对象队列，整个过程很有可能超过了一秒钟，它可以使转换或旋转从纵向到横向感到十分缓慢。","tags":[{"name":"Parcelable","slug":"Parcelable","permalink":"https://goghtsui.github.io/tags/Parcelable/"},{"name":"Serializable","slug":"Serializable","permalink":"https://goghtsui.github.io/tags/Serializable/"},{"name":"序列化","slug":"序列化","permalink":"https://goghtsui.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Android Studio Tips of the Day(2)","date":"2015-12-23T06:22:27.000Z","path":"2015/12/23/Android-Studio-Tips-of-the-Day(2)/undefined/","text":"原作者：Philippe Breault原文地址：http://www.developerphil.com/…the-day-roundup-2/ 关于快捷键Android Studio 提供了不同的按键对应关系(在快捷键和动作之间的映射).你能看到你正在使用的案件映射，通过Settings-&gt;KeyMap. 1.重复的行 Mac Win&amp;Linux cmd+d ctrl+d 它可以复制当前行并且粘贴它到下一行,不会影响剪切板的内容。 2.扩大/缩小选择 Mac Win&amp;Linux alt+up/down ctrl+w / ctrl+shift+w 以光标为基点,在上下文扩展选择的范围。例如:它将选择当前的变量,然后该语句,然后是这个方法等。 3.环绕(包装) Mac Win&amp;Linux cmd+alt+t ctrl+alt+t 这个操作可以包装一个结构的代码块。通常是一个 if 语句,一个循环、一个 try-catch 或者是一个 _runnable_。如果你什么都没选, 那么它只会包裹当前行。 4.最近列表 Mac Win&amp;Linux cmd+e ctrl+e 使用这个功能,你可以看到最近查看过的文件列表。 5.自动代码 Mac Win&amp;Linux cmd+j ctrl+j 它可以快速插入代码片段。更有趣的是它带有合理的默认值,并通过参数引导你完成插入。 其他提示: 如果你知道缩写,你也可以不用快捷方式。你仅仅需要如果缩写并且使用_Tab_key 完成即可。 6.移动方法 Mac Win&amp;Linux cmd+alt+up/down ctrl+shift+up/down 这是一个类似移动行的快捷方式,但是移动的是整个方法。没必要使用复制-粘贴,就可以上下移动方法。例如:你可以重新排序字段和内部类。 7.完成语句 Mac Win&amp;Linux cmd+shift+enter ctrl+shift+enter 它会自动生成丢失的代码来完成一条语句,它通常的使用情景是: 添加一个分号在行的末尾,即时光标不在行尾 在_if、while、for_的后面添加一个括号或者大括号 添加一个大括号在方法声明之后 其他提示: 如果一条语句已经完成,它会进入下一行,即时光标没有在当前行的最后一个字符. 8.最后一次编辑的位置 Mac Win&amp;Linux cmd+shift+backspace ctrl+shift+backspace 它会让你浏览你最后一次修改的位置,这个和点击工具栏的返回按钮是不一样的。它会带你在你修改的历史记录中浏览。 9.整合行和文字 Mac Win&amp;Linux ctrl+shift+j ctrl+shift+j 它能比你在行尾模拟删除键要做的更多,它可以保留当前的格式规则,并且它还可以: 合并两个注释行,并且删除无用的// 合并多行字符串,并且去除+、”” 整合字段和任务 其他提示: 如果你选择了一个字符串,跨越多行,那么它就可以将其整合成一行 10.查找 Mac Win&amp;Linux alt+f1 alt+f1 获取当前文件,并且询问你在哪选择它。他可以在_project、structure_或者文件管理器中打开它。每一个动作都有一个数字或字母前缀,这是调用它的快捷方式。 你可以从文件或者直接从_project_试图调用测方法。 11.展开/删除这个操作将会移除包裹的代码,它可以移除一个if_语句、_while 循环、try-catch 或者runnable 。这和包裹的快捷方式是完全相反的。","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"快捷键","slug":"快捷键","permalink":"https://goghtsui.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"tips of the Day","slug":"tips-of-the-Day","permalink":"https://goghtsui.github.io/tags/tips-of-the-Day/"}]},{"title":"Android Studio Tips of the Day(1)","date":"2015-12-22T09:19:51.000Z","path":"2015/12/22/Android-Studio-Tips-of-the-Day(1)/undefined/","text":"原作者：Philippe Breault原文地址：http://www.developerphil.com/…day-roundup-1/ 关于快捷键Android Studio 提供了不同的按键对应关系(在快捷键和动作之间的映射).你能看到你正在使用的案件映射，通过Settings-&gt;KeyMap. 1.高亮显示 Mac Win&amp;Linux cmd+shift+f7 ctrl+shift+f7 高亮显示光标所在的字符，这不仅仅是一个简单的匹配模式，它会了解当前的范围，并且高亮范围内同类的字符。你可以向上、向下浏览，通过：Edit -&gt; Find -&gt; Find Next/Previous 其他提示： 高亮一个方法中的“return”或者“throw”，其他方法也会同样高亮显示 高亮类声明中“extends”或者“implements”，同样会高亮 override/implemented的方法 高亮一个 import 会同样高亮使用它的地方 可以通过 Escape 取消高亮 2.在方法和内部类之间移动 Mac Win&amp;Linux ctrl+up/down alt+up/down 在当前文件中，移动光标到下一个方法或者类的名字开头。 如果你在方法内，向上就会将光标移动到该方法的名字开头。它非常有用，因为它让你在正确的地方重构或者发现方法的用法。 3.类结构弹窗 Mac Win&amp;Linux cmd+f12 ctrl+f12 用来展示当前类的概要和内部的导航.最好的事情是你可以使用你的键盘过滤。这是一件非常高效的方法，去定位到一个你知道其名字的方法。 其他提示： 输入过滤列表时，你可以使用驼峰匹配。例如：输入**”oCr”将查找到“onCreate”** 你也可以切换复选框来显示匿名内部类。假如你想要查找onClickListener中的onClick方法，这个就非常好用。 4.调用层级结构弹窗 Mac Win&amp;Linux ctrl+alt+h ctrl+alt+h 它可以显示一个方法的声明和调用之间可能的路径。 5.定义快速查询 Mac Win&amp;Linux alt+space ctrl+shift+i 有没有想要查看一个方法或者类的实现，但是又不想离开当前的页面？使用这个快捷键就可以在当前页面通过窗口的形式展现。 6.折叠展开代码块 Mac Win&amp;Linux alt+plus/minus ctrl+shift+plus/minus 这个功能的目的是让你隐藏你此刻不关心的东西。他将以最简单的形式隐藏整个代码块（例如：当你打开一个新的文件的时候忽略 _import_列表）。一个更有趣的用法是，它会隐藏周围简单的匿名内部类模块，并使它看起来像一个lambda表达式。 其他提示： 你可以设置默认，通过 Edit -&gt; Code Folding. 7.书签 切换书签 Mac Win&amp;Linux f3 f11 通过助记符切换书签 Mac Win&amp;Linux alt+f3 ctrl+f11 如果你分配了一个数据，你可以通过快捷方式 ctrl+number 回到书签 显示书签 Mac Win&amp;Linux cmd+f3 shift+f11 8.符号查找 Mac Win&amp;Linux cmd+shift+a ctrl+shift+a 对于Android Studio，你可以通过它的名字，调用任何你知道的菜单或者符号！这对于你曾经有一段时间使用过，但却没有快捷方式的命令是非常有用的。 其他提示： 如果有相关联的快捷键，会一同显示 9.行上下移动 Mac Win&amp;Linux alt+shift+up/down alt+shift+up/down 10.删除行 Mac Win&amp;Linux cmd+backspace ctrl+y","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"快捷键","slug":"快捷键","permalink":"https://goghtsui.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"tips of the Day","slug":"tips-of-the-Day","permalink":"https://goghtsui.github.io/tags/tips-of-the-Day/"}]},{"title":"Java的连接与初始化","date":"2015-12-09T04:52:53.000Z","path":"2015/12/09/Java的连接与初始化/undefined/","text":"原文作者：iceAeterna原文链接：http://www.cnblogs.com/iceAeterNa/p/4876747.html 序言Java虚拟机通过装载、连接、初始化来使得一个Java类型可以被Java程序所使用，如下图所示，其中连接过程又分为验证、准备、解析三个部分。其中部分类的解析过程可以推迟到程序真正使用其某个符号引用时再去解析。 解析解析过程可以推迟到类的初始化之后再进行，但这是有条件的，Java虚拟机必须在每个类或接口主动使用时进行初始化。以下为主动使用的情况： 创建某个类新的实例(无论直接通过new创建出来的，还是通过反射、克隆、序列化创建的) 使用某个类的静态方法 访问某个类或接口的静态字段 调用JavaAPI中的某些反射方法 初始化某个类的子类(要求其祖先类都要被初始化，否则无法正确访问其继承的成员) 启动某个标明为启动类的类(含有main()方法)主动使用会导致类的初始化，其超类均将在该类的初始化之前被初始化，但通过子类访问父类的静态字段或方法时，对于子类(或子接口、接口的实现类)来说，这种访问就是被动访问，或者说访问了该类(接口)中的不在该类(接口)中声明的静态成员。 Grandpa的定义如下： package com.ice.passiveaccess; public class Grandpa &#123; static&#123; System.out.println(&quot;Grandpa was initialized.&quot;); &#125; &#125; Parent的定义如下： package com.ice.passiveaccess; public class Parent extends Grandpa&#123; static String language = &quot;Chinese&quot;; static&#123; System.out.println(&quot;Parent was initialized.&quot;); &#125; &#125; Cindy的定义如下： package com.ice.passiveaccess; public class Cindy extends Parent&#123; static&#123; System.out.println(&quot;Child was initialized.&quot;); &#125; &#125; 现在通过Cindy访问父类的language成员: package com.ice.passiveaccess; public class PassiveAccessTest &#123; public static void main(String args[])&#123; System.out.println(Cindy.language); &#125; &#125; 结果如下： Grandpa was initialized. Parent was initialized. Chinese 可见这是被动访问，Cindy自身并没有初始化 装载装载的过程： (1).找到该类型的class文件，产生一个该类型的class文件二进制数据流(ClassLoader需要实现的loadClassData()方法) (2).解析该二进制数据流为方法区内的数据结构 (3).创建一个该类型的java.lang.Class实例 在加载器的相关代码中可以看到，最终通过defineClass()创建一个Java类型对象(Class对象)。 验证class文件校验器需要四趟独立的扫描来完成验证工作，其中： 第一趟扫描在装载时进行，会对class文件进行结构检查，如 (1).对魔数进行检查，以判断该文件是否是一个正常的class文件 (2).对主次版本号进行检查，以判断class文件是否与java虚拟机兼容 (3).对class文件的长度和类型进行检查，避免class文件部分缺失或被附加内容。 第二趟扫描在连接过程中进行，会对类型数据进行语义检查，主要检查各个类的二进制兼容性(主要是查看超类和子类的关系)和类本身是否符合特定的语义条件 (1).final类不能拥有子类 (2).final方法不能被重写(覆盖) (3).子类和超类之间没有不兼容的方法声明 (4).检查常量池入口类型是否一致(如CONSTANT_Class常量池的内容是否指向一个CONSTANT_Utf8字符串常量池) (5).检查常量池的所有特殊字符串，以确定它们是否是其所属类型的实例，以及是否符合特定的上下文无关语法、格式 第三趟扫描为字节码验证，其验证内容和实现较为复杂，主要检验字节码是否可以被java虚拟机安全地执行。 第四趟扫描在解析过程中进行，为对符号引用的验证。在动态连接过程中，通过保存在常量池的符号引用查找被引用的类、接口、字段、方法时，在把符号引用替换成直接引用时，首先需要确认查找的元素真正存在，然后需要检查访问权限、查找的元素是否是静态类成员而非实例成员。 准备为类变量分配内存、设置默认初始值(内存设置初始值，而非对类变量真正地进行初始化，即类中声明int i = 5，但实际上这里是分配内存并设置初始值为0) 解析在类的常量池中寻找类、接口、字段、方法的符号引用，将这些符号引用替换成直接引用 初始化对类变量赋予指定的初始值(这个时候int i = 5就必须赋予i以初值5)。这个初始值的给定方式有两种，一种是通过类变量的初始化语句，一种是静态初始化语句。而这些初始化语句都将被Java编译器一起放在方法中。如前面所述，一个类的初始化需要初始化其直接超类，并递归初始化其祖先类，初始化是通过调用类的初始化方法完成的。此外，对于接口，并不需要初始化其父接口，而只需要执行该接口的接口初始化方法就可以了。 注意： (1).在初始化阶段，只会为类变量(静态全局变量)进行初始化工作，并且当类变量声明为final类型切初始化语句采用了常量表达式方式进行初始化赋值，那么，也不会对其进行初始化，它将会直接被编译器计算并保存在常量池中，并且对这些变量的使用也将直接将其变量值嵌入到字节码中。如UsefulParameter类如下： Class UsefulParameter&#123; static final int height = 2; static final int width = height * 2; &#125; 类Area的类变量初始化如下： Class Area&#123; static int height = UsefulParameter.height * 2 ; static int width = UsefulParameter.width * 2; &#125; 在Area的&lt; clinit&gt;中，将直接把2、4嵌入到字节码中: (2).接口的初始化与类有所不同，在初始化阶段，会为在接口中声明的所有public、static和final类型的、无法被编译为常量的字段进行初始化 类实例化这里需要明白什么是类初始化，什么是类实例化，以及类的实例对象的初始化 如前面所述，类初始化时对类(静态)变量赋予指定的初始值，类初始化之后就可以访问类的静态字段和方法，而访问类的非静态(实例)字段和方法，就需要创建类的对象实例，故类的实例化是在类的初始化之后，是在堆上创建一个该类的对象。类的静态方法和字段属于类，作为类型数据保存在方法区，其生命周期取决于类，而实例方法和字段位于Java堆，其生命周期取决于对象的生命周期。 **类的初始化会从祖先类到子类、按出现顺序，对类变量的初始化语句、静态初始化语句块依次进行初始化。而对类实例的初始化也类似，会从祖先类到子类、按出现顺序，对类成员的初始化语句、实例初始化块、构造方法依次进行初始化。 ** 比如： package com.ice.init; public class Parent &#123; public static int i = print(&quot;parent static:i&quot;); public int ii = print(&quot;parent:ii&quot;); static&#123; print(&quot;父类静态初始化&quot;); &#125; &#123; print(&quot;父类实例初始化&quot;); &#125; public Parent(String str) &#123; System.out.println(&quot;parent constructor:&quot; + str); &#125; public static int print(String str)&#123; System.out.println(&quot;initial:&quot; + str); return i; &#125; &#125; 子类Child如下： package com.ice.init; public class Child extends Parent&#123; public static int i = print(&quot;child static:i&quot;); public int ii = print(&quot;child:ii&quot;); static&#123; print(&quot;子类静态初始化&quot;); &#125; &#123; print(&quot;子类实例初始化&quot;); &#125; public Child(String str) &#123; super(str); System.out.println(&quot;Child constructor:&quot; + str); &#125; public static int print(String str)&#123; System.out.println(&quot;initial:&quot; + str); return i; &#125; public static void main(String args[])&#123; Child child = new Child(&quot;cindy&quot;); &#125; &#125; 其初始化顺序为： initial:parent static:i initial:父类静态初始化 initial:child static:i initial:子类静态初始化 initial:parent:ii initial:父类实例初始化 parent constructor:cindy initial:child:ii initial:子类实例初始化 Child constructor:cindy Java编译器为每个类生成了至少一个实例初始化方法&lt; init &gt;，一个&lt; init &gt;方法分为三部分： 另一个初始化方法&lt; init &gt;()，对任意实例成员的初始化的字节码，构造方法的方法体的字节码 &lt; init &gt;方法的调用如下：若&lt; init &gt;指明从this()方法明确调用另一个构造方法，那么将调用另一个构造方法，否则，若该类有直接超类，那么，若&lt; init &gt;指明从super()方法明确调用其超类的构造方法，那么将调用超类的构造方法，否则，将默认调用超类的无参构造方法。这样，将从其祖先类到该类，分别完成对应的实例成员的初始化(可能被子类覆盖) 接下来以一道题结束本节：判断输出： package com.ice.init; class T implements Cloneable&#123; public static int k = 0; public static T t1 = new T(&quot;t1&quot;); public static T t2 = new T(&quot;t2&quot;); public static int i = print(&quot;i&quot;); public static int n = 99; public int j = print(&quot;j&quot;); &#123; print(&quot;构造块&quot;); &#125; static &#123; print(&quot;静态块&quot;); &#125; public T(String str) &#123; System.out.println((++k) + &quot;:&quot; + str + &quot; i=&quot; + i + &quot; n=&quot; + n); ++n; ++ i; &#125; public static int print(String str)&#123; System.out.println((++k) +&quot;:&quot; + str + &quot; i=&quot; + i + &quot; n=&quot; + n); ++n; return ++ i; &#125; public static void main(String[] args)&#123; T t = new T(&quot;init&quot;); &#125; &#125; 题解如下： (1).首先T类被加载、连接后进行初始化，会先对字段k、t1、t2、i、n以及static块进行初始化。(2).t1实例的初始化会初始化实例成员j，(实际上先进行父类实例内容的初始化)先调用静态方法print，并执行实例初始化块{}， 输出： 1: j i=0 n= 0(i和n都还没有初始化) 2:构造块 i=1 n=1(3)随后调用t1实例的构造函数，输出： 3:t1 i=2 n=2(4).类似有t2实例的初始化： 4: j i=3 n= 3 5:构造块 i=4 n=4 6:t2 i=5 n=5(5).i的初始化： 7.i i=6 n=6(6).n的初始化和静态块的初始化： 8.静态块 i=7 n=99(n已经被初始化)(7).t实例的初始化： 9.j i=8 n= 100 10.构造块 i=9 n= 101 11.init i=10 n= 102","tags":[{"name":"类初始化","slug":"类初始化","permalink":"https://goghtsui.github.io/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://goghtsui.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Java","slug":"Java","permalink":"https://goghtsui.github.io/tags/Java/"}]},{"title":"通过Swiftype实现hexo站内搜索","date":"2015-11-25T09:30:54.000Z","path":"2015/11/25/通过Swiftype实现hexo站内搜索/undefined/","text":"hexo默认提供的是google的搜索，但是国内很蛋疼，无意中了解到swiftype效果不错，之前也看了一些方法不是很凑效，无奈自己研究了一下，可以正常使用了，这里就把方法share给大家，下面就直接进入正题吧。 注册swiftype账号官方地址：https://swiftype.com/ 创建搜索引擎注册完账号，接下来就是创建搜索引擎了，这里都是以图片引导，关键步骤都有;1、CREATE AN ENGINE：2、继续点击创建： 3、填写自己的域名，不带最后的反斜杠，点击VERIFY，4个验证项，通过之后会让你输入引擎的名字：4、接下来是让你配置sitemap（关于sitemap自行搜索教程），地址统一是：域名/sitemap.xml5.1、点击COMPLETE SETUP，创建完成，会进入到如下界面，这里提供的代码就是需要在hexo配置的：5.2、向下滚动，可以点击content 查看自己的哪些数据被抓取出来了，跳转后页面右侧而且还可以测试搜索功能：6、点击上面的INTEGRATE -&gt; INSTALL SEARCH ，进行一些关键的配置：7、点击CHANGE CONFIGURATION：8、进行一些更详细的配置，4个部分，样式默认就好，也可以自己选，这里就说下面两个部分（results container - 搜索结果页），我使用的是默认的，本页面底部有自定义搜索页的案例。9、配置Search field，这个就是搜索框-input的相关配置了，hexo主题默认就有，而且swiftype提供的SEARCH FIELD都是一样的input标签： 如果都保持默认设置的话，完成到步骤5.1就可以看下面的教程了。 hexo主题配置（pacman）我的主题是Pacman的，这里就以pacman为例，其实没有本质的区别，大部分都是在主题目录的文件。 1、首先打开pacman\\_config.yml文件在末尾添加如下代码，提供对swiftype的支持： swift_search: enable: true 2、 在hexo\\source目录（注意不是pacman主题的source目录）下新建一个search文件夹（如果不存在的），在里面新建一个index.md，index.md中写入如下代码： layout: search title: search --- 3、 切换的到pacman\\layout\\_partial目录下，大部分的代码配置都在这里完成的。先打开header.ejs，把 &lt;li&gt; ... ... &lt;/li&gt; 之间的代码清空（我的默认是google的搜索，这里再添加上swftype的搜索，也就是第一个if部分），整合代码如下，直接copy过去就行： &lt;% if (theme.swift_search&amp;&amp;theme.swift_search.enable)&#123; %&gt; &lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;label&gt;Search&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;/form&gt; &lt;% &#125;else if (theme.google_cse&amp;&amp;theme.google_cse.enable)&#123; %&gt; &lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;label&gt;Search&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; name=&quot;q&quot; maxlength=&quot;20&quot; placeholder=&quot;&lt;%= __(&#39;search&#39;) %&gt;&quot; /&gt; &lt;/form&gt; &lt;% &#125; else &#123; %&gt; &lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;label&gt;Search&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;search&quot; name=&quot;q&quot; autocomplete=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;&lt;%= __(&#39;search&#39;) %&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &#39;&#39;) %&gt;&quot;&gt; &lt;/form&gt; &lt;% &#125; %&gt; 4、将原来的search.ejs中的代码清空，替换为以下的代码，其实主要就是为了控制结果的显示样式（后期可以自己调整），注意：将最下面的&lt;script ... &gt; ... 部分替换成swiftype给你的js代码。 &lt;% if(theme.swift_search.enable) &#123; %&gt; &lt;div id=&quot;container&quot; class=&quot;page&quot;&gt; &lt;div id=&quot;st-results-container&quot; class=&quot;st-search-container&quot; style=&quot;width:80%&quot;&gt;正在加载搜索结果，请稍等。&lt;/div&gt; &lt;style&gt;.st-result-text &#123; background: #fafafa; display: block; border-left: 0.5em solid #ccc; -webkit-transition: border-left 0.45s; -moz-transition: border-left 0.45s; -o-transition: border-left 0.45s; -ms-transition: border-left 0.45s; transition: border-left 0.45s; padding: 0.5em; &#125; @media only screen and (min-width: 768px) &#123; .st-result-text &#123; padding: 1em; &#125; &#125; .st-result-text:hover &#123; border-left: 0.5em solid #ea6753; &#125; .st-result-text h3 a&#123; color: #2ca6cb; line-height: 1.5; font-size: 22px; &#125; .st-snippet em &#123; font-weight: bold; color: #ea6753; &#125;&lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(w,d,t,u,n,s,e)&#123;w[&#39;SwiftypeObject&#39;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&#39;script&#39;,&#39;//s.swiftypecdn.com/install/v2/st.js&#39;,&#39;_st&#39;); _st(&#39;install&#39;,&#39;w7ca3xWstLkz2UvAeyAJ&#39;,&#39;2.0.0&#39;); &lt;/script&gt; &lt;% &#125; %&gt; 5、打开footer.ejs或header.ejs，在最后一个标签（&lt;/div&gt;）之前添加swiftype分配给你的js代码（同上），我的是： &lt;script type=&quot;text/javascript&quot;&gt; (function(w,d,t,u,n,s,e)&#123;w[&#39;SwiftypeObject&#39;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&#39;script&#39;,&#39;//s.swiftypecdn.com/install/v2/st.js&#39;,&#39;_st&#39;); _st(&#39;install&#39;,&#39;w7ca3xWstLkz2UvAeyAJ&#39;,&#39;2.0.0&#39;); &lt;/script&gt; 到这里所有的修改都已经完成了，如果没有问题的话，命令行执行： &gt; hexo clean &gt; hexo d -g 等部署完成，你就可以打开你的Blog任性的搜索了 推荐这里推荐一篇其他大神的Blog，可以自定义搜索结果页面，点我跳转.","tags":[{"name":"hexo","slug":"hexo","permalink":"https://goghtsui.github.io/tags/hexo/"},{"name":"swiftype","slug":"swiftype","permalink":"https://goghtsui.github.io/tags/swiftype/"},{"name":"pacman","slug":"pacman","permalink":"https://goghtsui.github.io/tags/pacman/"}]},{"title":"[Win10]快捷键之Win组合键","date":"2015-11-25T01:27:42.000Z","path":"2015/11/25/Win10-快捷键之Win组合键/undefined/","text":"Win组合键 Shortcut Description Windows Key Open and close the Start menu. +1,+2,etc. Switch to the desktop and launch the nth application in the taskbar. For example, +1 launches whichever application is first in the list, numbered from left to right. +A Open the action center. +B Highlight the notification area. +C Launch Cortana into listening mode[注1]. Users can begin to speak to Cortana immediately. +D Switch between Show Desktop (hides/shows any applications and other windows) and the previous state. +E Switch to the desktop and launch File Explorer with the Quick Access tab displayed. +H Open the action center. +I Open the action center. +K Open the Connect pane to connect to wireless displays and audio devices. +L Lock the device and go to the Lock screen. +M Switch to the desktop and minimize all open windows. +O Lock device orientation. +P Open the Project pane to search and connect to external displays and projectors. +R Display the Run dialog box. +S Launch Cortana.[注2] Users can begin to type a query immediately. +T Cycle through the apps on the taskbar. +U Launch the Ease of Access Center. +A Cycle through notifications. +V Open the action center. +X Open the advanced menu in the lower-left corner of the screen. +Z Open the app-specific command bar. +Enter Launch Narrator. + Space Switch input language and keyboard layout. +Tab Open Task view. +, Peek at the desktop. +Plus Sign Zoom in. +Minus Sign Zoom out. +ESCAPE Close Magnifier. +LEFT ARROW Dock the active window to the left half of the monitor. +RIGHT ARROW Dock the active window to the right half of the monitor. +UP ARROW Maximize the active window vertically and horizontally. +DOWN ARROW Restore or minimize the active window. +SHIFT UP ARROW Maximize the active window vertically, maintaining the current width. +SHIFT DOWN ARROW Restore or minimize the active window vertically, maintaining the current width. +SHIFT LEFT ARROW With multiple monitors, move the active window to the monitor on the left. +SHIFT RIGHT ARROW With multiple monitors, move the active window to the monitor on the right. +HOME Minimize all nonactive windows; restore on second keystroke. +PRNT SCRN Take a picture of the screen and place it in the Computer&gt;Pictures&gt;Screenshots folder. +CTRL+LEFT/RIGHT ARROW Switch to the next or previous virtual desktop. +CTRL+D Create a new virtual desktop. +CTRL_F4 Close the current virtual desktop. +? Launch the Windows Feedback App. [注1]: If Cortana is unavailable or disabled, this shortcut has no function. [注2]: Cortana is only available in certain countries/regions, and some Cortana features might not be available everywhere. If Cortana is unavailable or disabled, this command opens Search.","tags":[{"name":"快捷键","slug":"快捷键","permalink":"https://goghtsui.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Win10","slug":"Win10","permalink":"https://goghtsui.github.io/tags/Win10/"}]},{"title":"[推荐]Markdown编辑器(PC+手机端)","date":"2015-11-24T07:14:12.000Z","path":"2015/11/24/推荐-Markdown编辑器/undefined/","text":"开篇相信大家都有去过Github吧，这是一个大牛集结，学习的好去处，可以说大部分开源项目都托管在这上面，我以AndroidSwipeLayou为例，我们看到的是这样的页面：上面是代码目录结构，下面是什么？对，README.md！下面的内容都是README.md来描述的信息，我当时不知道.md是什么文件，也不知道它可以写出这么酷炫的文字和页面效果。md是markdown的简写，markdown提供了非常友好的文字处理能力，在了解到Markdown之后，才知道原来还可以这么玩，使用过了才知道它的强大之处。Github在添加README.md时就相当于是一个在线编辑器，而且还有转换预览，其实你可以在这里编辑，然后copy到任何支持的地方使用，但是离线的时候怎么办？于是开始寻找一款高效的编辑器，没错Sublime text，它已经成为一款程序员必备软件，无奈我没始终没安装上markdown的插件（请自行google安装教程），只好放弃了，但是最后我找到了各种Markdown的编辑器，下面就为大家一一揭晓。 在线编辑器 - 马克飞象官方地址：点我跳转这是oschina提供的一个在线的编辑器，可以实时预览、Html效果预览 Windows - MarkdownPad官网地址：点我跳转官方描述：MarkdownPad is a full-featured Markdown editor for Windows.这是我现在使用的PC端的Markdown编辑器，这是一款标准的Markdown编辑器，即时预览，谁用谁知道，有图有真相。 Gmail - Markdown Here这是一个Chrome的插件，它是用来在编写gmail时提供markdown的语法支持，还可以即时预览，以后你就可以打造属于自己炫酷的邮件了Chrome扩展插件：编辑gmail邮件：gmail的预览，点击图一插件按钮即可看到图二预览效果： Android - MarkdownX在这个年代，手机的功能已经强大到无法想象的地步了，Google提供的Android系统就为我们移动办公提供了一个很好的平台。手机端IDE你值得拥有（手机编写代码确实有点蛋疼），这里我要说的是一款Markdown编辑器，必备的功能 - 时时预览，在编辑页面右滑就可以预览，而且还可以同步Dropbox，是不是很强大！哦，果粉用户的你可以忽略这一段。下图来自google play： 这里只是我的个人感觉不错的编辑器，当然还有很多好的编辑器，主要是适合你的才是最好的，如果你有非常好的软件或编辑器可以告诉我，我也可以添加上去。主要是能让我们可以快速高效的编写更优美的代码和页面。","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://goghtsui.github.io/tags/Markdown/"},{"name":"马克飞象","slug":"马克飞象","permalink":"https://goghtsui.github.io/tags/%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/"},{"name":"MarkdownPad","slug":"MarkdownPad","permalink":"https://goghtsui.github.io/tags/MarkdownPad/"},{"name":"MarkdownX","slug":"MarkdownX","permalink":"https://goghtsui.github.io/tags/MarkdownX/"}]},{"title":"Java之静态绑定和动态绑定","date":"2015-11-24T02:07:20.000Z","path":"2015/11/24/Java之静态绑定和动态绑定/undefined/","text":"概念 程序绑定：绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来，Java中绑定分为绑定分为 静态绑定和动态绑定 动态绑定：在面向过程中又称为后期绑定，在程序运行期进行了绑定，根据实际情况有选择的进行绑定 静态绑定：在面向过程中又称为前期绑定，在程序编译期进行了绑定，即在还没运行时，就已经加载到内存对比 动态绑定 又称为后期绑定 发生在运行时期 虚方法（可以被子类重写的方法）会根据运行时的对象进行动态绑定 动态绑定使用对象信息来完成 典型应用是方法的重写（Override） 静态绑定 又称为前期绑定 发生在编译时期 使用private或static或final修饰的变量或者方法（包括构造方法） 静态绑定使用类信息来完成 典型应用是方法重载（Overload） 运行期Java的编译过程是将Java源文件编译成字节码（.class文件，JVM可执行代码）的过程，在这个过程中Java是不与内存打交道的，在这个过程中编译器会进行语法的分析，如果语法不正确就会报错 编译期Java的运行过程是指JVM（Java虚拟机）装载字节码文件并解释执行，在这个过程才是真正的创建内存，执行Java程序 Java字节码的执行有两种方式： 即时编译方式：解释器先将字节编译成机器码，然后再执行该机器码 解释执行方式：解释器通过每次解释并执行一小段代码来完成java字节码程序的所有操作。 Java程序在执行过程中其实是进行了两次转换，先将源文件转成字节码再转换成机器码。这也正是Java能一次编译，到处运行的原因。在不同的平台上装上对应的Java虚拟机，就可以实现相同的字节码转换成不同平台上的机器码，从而在不同的平台上运行 验证关于final、static、private和构造方法是前期绑定的理解： private对于private的方法，首先它对外是不可见的，所以肯定不能被继承，那么就没办法通过子类的对象来调用，而只能通过类自身的对象来调用，因此就可以说private方法和定义这个方法的类绑定在了一起 finalfinal方法虽然可以被继承，但不能被重写（覆盖），虽然子类对象可以调用，但是调用的都是父类中所定义的那个final方法，（由此我们可以知道将方法声明为final类型，一是为了防止方法被覆盖，二是为了有效地关闭java中的动态绑定) static对于static方法，可以被子类继承，但是不能被子类重写（覆盖），但是可以被子类隐藏就是说如果父类里有一个static方法，它的子类里如果没有对应的方法，那么当子类对象调用这个方法时就会使用父类中的方法。而如果子类中定义了相同的方法，则会调用子类的中定义的方法。唯一的不同就是，当子类对象向上转型为父类对象时，不论子类中有没有定义这个静态方法，该对象都会使用父类中的静态方法。因此这里说静态方法可以被隐藏而不能被覆盖。这与子类隐藏父类中的成员变量是一样的。隐藏和覆盖的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏的变量和方法，而不能访问父类被覆盖的方法由上面我们可以得出结论，如果一个方法不可被继承或者继承后不可被覆盖，那么这个方法就采用的静态绑定。 构造构造方法也是不能被继承的，我们知道子类是通过super()来调用父类的无参构造方法，来完成对父类的初始化，因此编译时也可以知道这个构造方法到底是属于哪个类 示例代码 public class SuperClass &#123; protected String attribute = &quot;from SuperClass&quot;; public String getAttribute() &#123; return attribute; &#125; public static void print(SuperClass superClass) &#123; System.out.println(&quot; static method &quot; + superClass.attribute); &#125; &#125; public class SubClass extends SuperClass &#123; protected String attribute = &quot;from SubClass&quot;; public String getAttribute() &#123; return attribute; &#125; public static void print(SuperClass superClass) &#123; System.out.println(&quot; static method &quot; + superClass.attribute); &#125; public static void main(String[] args) &#123; SuperClass superClass = new SubClass(); SubClass subClass = new SubClass(); superClass.print(superClass); subClass.print(subClass); System.out.println(&quot; attribute &quot; + superClass.attribute); System.out.println(&quot; method &quot; + superClass.getAttribute()); &#125; &#125; 输出结果 static method from SuperClass static method from SuperClass attribute from SuperClass method from SubClass 反编译使用JDK自带的javap命令反编译看看：&gt;javap -c SubClass Warning: Binary file SubClass contains com.gogh.bind.SubClass Compiled from &quot;SubClass.java&quot; public class com.gogh.bind.SubClass extends com.gogh.bind.SuperClass &#123; protected java.lang.String attribute; public com.gogh.bind.SubClass(); Code: 0: aload_0 1: invokespecial #10 // Method com/gogh/bind/SuperClass.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: ldc #12 // String from SubClass 7: putfield #14 // Field attribute:Ljava/lang/String; 10: return public java.lang.String getAttribute(); Code: 0: aload_0 1: getfield #14 // Field attribute:Ljava/lang/String; 4: areturn public static void print(com.gogh.bind.SuperClass); Code: 0: getstatic #24 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #30 // class java/lang/StringBuilder 6: dup 7: ldc #32 // String static method 9: invokespecial #34 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: aload_0 13: getfield #37 // Field com/gogh/bind/SuperClass.attribute:Ljava/lang/String; 16: invokevirtual #38 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #42 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #45 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return public static void main(java.lang.String[]); Code: 0: new #1 // class com/gogh/bind/SubClass 3: dup 4: invokespecial #54 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: new #1 // class com/gogh/bind/SubClass 11: dup 12: invokespecial #54 // Method &quot;&lt;init&gt;&quot;:()V 15: astore_2 16: aload_1 17: invokestatic #55 // Method com/gogh/bind/SuperClass.print:(Lcom/gogh/bind/SuperClass;)V 20: aload_2 21: invokestatic #57 // Method print:(Lcom/gogh/bind/SuperClass;)V 24: getstatic #24 // Field java/lang/System.out:Ljava/io/PrintStream; 27: new #30 // class java/lang/StringBuilder 30: dup 31: ldc #58 // String attribute 33: invokespecial #34 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 36: aload_1 37: getfield #37 // Field com/gogh/bind/SuperClass.attribute:Ljava/lang/String; 40: invokevirtual #38 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 43: invokevirtual #42 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 46: invokevirtual #45 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 49: getstatic #24 // Field java/lang/System.out:Ljava/io/PrintStream; 52: new #30 // class java/lang/StringBuilder 55: dup 56: ldc #60 // String method 58: invokespecial #34 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 61: aload_1 62: invokevirtual #62 // Method com/gogh/bind/SuperClass.getAttribute:()Ljava/lang/String; 65: invokevirtual #38 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 68: invokevirtual #42 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 71: invokevirtual #45 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 74: return &#125; 通过javap我们只能看到静态绑定的部分，就是两个print方法的调用和superClass.attribute，直接看main方法里面的内容： 17: invokestatic #55 // Method com/gogh/bind/SuperClass.print:(Lcom/gogh/bind/SuperClass;)V调用的SuperClass.print方法 21: invokestatic #57 // Method print:(Lcom/gogh/bind/SuperClass;)V 37: getfield #37 // Field com/gogh/bind/SuperClass.attribute:Ljava/lang/String;这个也是调用的SuperClass.print方法总结Java中的static方法和final方法属于前期绑定，子类无法重写final方法，除了static方法和final方法之外的其他方法属于后期绑定，运行时能判断对象的类型进行绑定。 与方法不同，在处理Java类中的成员变量（静态和非静态）时，并不是采用运行时绑定，而是一般意义上的静态绑定。所以在向上转型的情况下，对象的方法可以找到子类，而对象的属性（成员变量）还是父类的属性（子类对父类成员变量的隐藏）。 Java因为什么对属性要采取静态的绑定方法？这是因为静态绑定是有很多的好处，它可以让我们在编译期就发现程序中的错误，而不是在运行期，这样就可以提高程序的运行效率！由于动态绑定需要在运行时确定执行哪个方法实现或者变量，比起静态绑定起来要耗时。对方法采取动态绑定是为了实现多态，多态是Java的一大特色，多态也是面向对象的关键技术之一，所以Java是以效率为代价来实现多态这是很值得的，所以在不影响整体设计的情况下，我们可以考虑将方法或者变量使用private，static或者final进行修饰。 内容来自互联网+个人见解，如果有哪里有问题，请联系我并指正，我会及时纠正处理。","tags":[{"name":"动态绑定","slug":"动态绑定","permalink":"https://goghtsui.github.io/tags/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"name":"静态绑定","slug":"静态绑定","permalink":"https://goghtsui.github.io/tags/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/"},{"name":"重载","slug":"重载","permalink":"https://goghtsui.github.io/tags/%E9%87%8D%E8%BD%BD/"},{"name":"重写","slug":"重写","permalink":"https://goghtsui.github.io/tags/%E9%87%8D%E5%86%99/"}]},{"title":"Java重载匹配优先级","date":"2015-11-23T08:31:05.000Z","path":"2015/11/23/Java重载匹配优先级/undefined/","text":"前情提要Java面向对象的三个基本特征：继承、封装和多态；多态主要体现在重载和重写； 示例代码无意间看到这样一个问题，为了方便直观，就用代码来描述问题，有这样一个类： public class OverloadPriority &#123; public static void print(Object arg) &#123; System.out.println(&quot;parameter type = Object&quot;); &#125; public static void print(int arg) &#123; System.out.println(&quot;parameter type = int&quot;); &#125; public static void print(long arg) &#123; System.out.println(&quot;parameter type = long&quot;); &#125; public static void print(double arg) &#123; System.out.println(&quot;parameter type = double&quot;); &#125; public static void print(float arg) &#123; System.out.println(&quot;parameter type = float&quot;); &#125; public static void print(char arg) &#123; System.out.println(&quot;parameter type = char&quot;); &#125; public static void print(Character arg) &#123; System.out.println(&quot;parameter type = Character&quot;); &#125; public static void print(char... arg) &#123; System.out.println(&quot;parameter type = char...&quot;); &#125; public static void print(Serializable arg) &#123; System.out.println(&quot;parameter type = Serializable&quot;); &#125; public static void print(Comparable&lt;?&gt; arg) &#123; System.out.println(&quot;parameter type = Comparable&quot;); &#125; public static void main(String[] args) &#123; // int print(&#39;g&#39;); &#125; &#125; 可以看到我们这里重载了print(xxx)这个方法，不同类型的参数，那么在调用上会出现什么问题呢？这里就以char类型为例来分析一下。 main方法执行print(‘g’)，输出结果毫无疑问就是： parameter type = char 那么注释掉print(char arg)这个方法，会输出什么结果呢？ parameter type = int 那么注释掉print(int arg)这个方法，会输出什么结果呢？ parameter type = long 这是为什么呢？ 这就是重载当中参数类型的优先级问题。我们都知道’g’除了表示字符g之外，还能表示数字103（g的ASCII码是103），所以会输出为int，发生了类型转换，类型自动提升，结果依次是char -&gt; int -&gt; long -&gt; double -&gt; float -&gt; Character -&gt; Serializable or Comparable -&gt; Object -&gt; char…(变长参数，即char元素数组) 总结遇上重载时，会查找类型最匹配的参数，然后提升类型、封装类型、匹配接口、继承关系型、变长参数类型 注意 变长参数的重载优先级最低 char到byte或short之间的转换是不安全的 在Serializable和Comparable同时存在的情况下会报异常： The method print(Object) is ambiguous for the type OverloadPriority （意思是无法确定应该使用哪一个重载方法， 因为Character实现了Serializable和Comparable这两个接口， 而接口匹配的优先级是一样的，编译器无法判断转型为哪种类型， 提示类型模糊，无法正常编译） 接口无法匹配之后，就会开始查找匹配的父类，优先级是顺着继承链，由下往上进行匹配 所以在重载方法的时候大家一定要注意这些细节问题，这样可能导致最后输出的结果不是你想要的结果，大家可以编写这样的一段代码测试一下","tags":[{"name":"重载","slug":"重载","permalink":"https://goghtsui.github.io/tags/%E9%87%8D%E8%BD%BD/"},{"name":"java","slug":"java","permalink":"https://goghtsui.github.io/tags/java/"}]},{"title":"Android之Log混淆","date":"2015-11-18T08:38:59.000Z","path":"2015/11/18/Android之Log混淆/undefined/","text":"作为Android开发工程师，项目开发的过程中，日志的打印是必不可少的，通过这些日志我们可以很好分析程序运行的状况与正确性，可以使用的日志输出有哪种形式呢？发布release版本应该怎么屏蔽掉这些日志呢？ 日志形式 Java形式System.out.println(&quot; log for test &quot;); 这个一般不提倡使用 Android LogLog.d(TAG, &quot; log for test &quot;); 这个是Android标准的日志输出类：android.util.Log TAG定义关于TAG的命名简单说一下，基本上有以下几种形式： 人名 Log.d(&quot;gogh&quot; &quot; log for test &quot;); 与代码无关，无法定位日志的位置 类名private static final String TAG = LogUtils.class.getSimpleName(); Log.d(TAG, &quot; log for test &quot;); 经过混淆的类，类名会改变为a、b这种形式，相应的TAG值也会改变，同样无法定位相关代码域。 TAG定义推荐那么哪种形式的TAG定义相对来说比较规范呢？给大家推荐一种相对规范的定义形式： public class Utils &#123; public static final String TAG = &quot;Utils&quot;; public String setText(String text)&#123; Logger.d(TAG, &quot; setText text = &quot; + text ); // do something &#125; &#125; 基本的规范是： 日志所在类 日志所在的方法 基本的信息这样的log是不是很好了就，对调试程序而言，比较直观，可读性不叫强，容易定位，关键是不会因为代码的混淆改变TAG的值。 屏蔽日志我们的开发分为很多个阶段，但最终还是要有一个release版本发布，就需要把日志输出屏蔽掉，这一步相信大家都接触过了，那么就简单分析一下这一步。#####运行时屏蔽这个应该是使用的最多的，那么何为运行时屏蔽呢？就是在我们自定义的log工具类中设置一个值来开关日志，例如： public class Logger &#123; private static final boolean ENABLE = &quot;true; public static void d(String tag, String message)&#123; if(ENABLE)&#123; android.util.Log.d(tag, message); &#125; &#125; &#125; Logger.d(XXX, &quot;VERSION = &quot; + Build.VERSION.SDK_INT); 编写代码的过程中我们可以使用Logger.d(xxx, xxx);的形式来打印日志，在发布打包时将ENABLE修改为false就可以关闭日志。程序在运行的过程中就不会显示日志，但是message部分的方法（Build.VERSION.SDK_INT）还是执行到了，稍后解释。 编译期屏蔽这个就很简单了，在打包发布的时候加入代码混淆，如下： -assumenosideeffects class com.gogh.Logger&#123; public static *** i(...); &#125; 但是为了为了防止还有使用原生log的日志输出，直接混淆原生的log类，如下： -assumenosideeffects class android.util.Log &#123; public static *** v(...); public static *** d(...); public static *** i(...); public static *** w(...); public static *** e(...); &#125; 这样就可以达到平日日志输出的效果了 对比描述运行时屏蔽其实很好理解，log中的日志输出是通过一个值控制的，这个输出的操作是在值判断通过之后进行的，而方法的调用需要传递多个参数，参数的传递肯定是在判断之前发生的，所以参数中的字串的拼接是会执行到的，方法同样也会被调用到，只是你看不到日志输出而已 编译期就是在编译过程中，Proguard进行优化，发生了内联操作，将dumpDebugInfo的被调用的方法体实现提取到调用的地方。在log相关的调用做了处理，结果是这里没有任何关于Logger.d(xxx,xxx)的调用，但是字串的拼接还是存在的，只是没有了方法的调用，这个可以通过反编译看看相关的代码片段 总结理论上编译期屏蔽相对于运行期屏蔽更优","tags":[{"name":"Log","slug":"Log","permalink":"https://goghtsui.github.io/tags/Log/"}]},{"title":"解决Android Studio中Terminal无法输入的问题","date":"2015-11-16T02:14:09.000Z","path":"2015/11/16/解决Android-Studio中Terminal无法输入的问题/undefined/","text":"问题描述：Windows系统下Android Studio中的Terminal无法获取焦点，不能输入文字。 问题原因：这个是因为系统升级造成的不兼容问题，在Windows环境开发的朋友们估计早早的就升级Win10了吧，UI非常的炫酷。然而AS中的Terminal使用的还是Windows中的cmd控制台，也就是位于C:\\Windows\\System32\\目录下的cmd.exe。Win10下的cmd相对于早期版本的cmd做了一些改进，导致了这里描述的问题。 解决方案：下面给出具体的操作步骤，有图有真相： 1、win+R组合键打开运行窗口，输入cmd ，点击OK 2、在出现的cmd窗口中，右键点击标题栏-&gt;Properties，出现如下窗口： 3、勾选 Use legacy console（requires relaunch）即使用旧版控制台（需要重启生效），就这么简单的操作就可以解决问题了，赶快试试吧！","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://goghtsui.github.io/tags/Android-Studio/"},{"name":"Terminal","slug":"Terminal","permalink":"https://goghtsui.github.io/tags/Terminal/"}]},{"title":"Android之简单实现ButterKnife中的injectView的方案","date":"2015-11-13T01:37:14.000Z","path":"2015/11/13/Android之简单实现ButterKnife中的injectView的方案/undefined/","text":"首先说这里面用的知识点，注解、反射。 Android中findViewById(int resId)接受一个int的id参数，即通过资源id就可以找到对应的View。通过注解(annotation),我们可以资源id声明在对应的field上面，通过Java的反射，遍历每个field，找到对应的id，就可以初始化这个field（即view）。 1、注解声明 // 表示用在字段上 @Target(ElementType.FIELD) // 表示在生命周期是运行时 @Retention(RetentionPolicy.RUNTIME) //注解类，实现findViewById功能 public @interface FindView &#123; int findViewByResId() default 0; &#125; 2、反射注入 Class&lt;?&gt; clazz = this.getClass(); // 获得Activity中声明的字段 Field[] fields = clazz.getDeclaredFields(); //遍历所有字段 for (Field field : fields) &#123; // 是否有我们自定义的注解类标志 if (field.isAnnotationPresent(FindView.class)) &#123; FindView inject = field.getAnnotation(FindView.class); int mId = inject.findViewByResId(); View view; if (mId &gt; 0) &#123; view = findViewById(mId); field.setAccessible(true); field.set(this, view);// 给我们要找的字段设置值 &#125; &#125; &#125; 3、测试 @FindView(findViewByResId = R.id.id_text) private TextView mText; 总结：是不是很简单，这算是一个入门，接下来大家可以好好利用这种原理，实现不一样的功能了。个人觉得这个不是特别好，每次都要通过反射来初始化，大家还是结合自己的开发环境酌情使用。","tags":[{"name":"ButterKnife","slug":"ButterKnife","permalink":"https://goghtsui.github.io/tags/ButterKnife/"},{"name":"InjectView","slug":"InjectView","permalink":"https://goghtsui.github.io/tags/InjectView/"},{"name":"annotation","slug":"annotation","permalink":"https://goghtsui.github.io/tags/annotation/"}]}]